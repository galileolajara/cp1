include <stdio.h>  {
   using C = LibC;
   using X = Posix;
   using LibC {
      printf(fmt:char[]):intc @var-args @no-decl @real-name;
      sprintf(str:char[], fmt:char[]):intc @var-args @no-decl @real-name;
      scanf(fmt:char[]):intc @var-args @no-decl @real-name;
      sscanf(str:char[], fmt:char[]):intc @var-args @no-decl @real-name;

      var out:File @no-decl(stdout);
      struct File[] @no-decl(FILE) {
         printf(f:this, str:char[]):intc @var-args @no-decl(fprintf);
         flush(f:this):intc @no-decl(fflush);
         write(f:this, buf:ref, size:usz):usz @inline {
            return fwrite(buf, 1, size, f);
         }
         putc(c:intc, f:this):intc @no-decl(fputc);
         close(f:this):intc @no-decl(fclose);
      }
      rename(old:char[], new:char[]):intc @no-decl @real-name;
      fopen(path:char[], mode:char[]):File @no-decl @real-name;
      fdopen(fd:X.Fd, mode:char[]):File @no-decl @real-name;
      fclose(f:File):intc @no-decl @real-name;
      fwrite(buf:ref, size1:usz, size2:usz, f:File):usz @no-decl @real-name;
      tempnam(dir:char[], pfx:char[]):char[] @no-decl @real-name;

      var stdout-buf-data:char[];
      var stdout-buf-cap:u32;
      var stdout-buf-len:u32;
      stdout(so:Stdout) {
      }
      stdout-bytes(data:ref, size:usz) @inline {
         stdout-reserve(size);
         C.memcpy(&.stdout-buf-data[.stdout-buf-len], data, size);
         .stdout-buf-len += size;
      }
      stdout-u32(val:u32) {
         stdout-reserve(10);
         if val == 0 {
            .stdout-buf-data[.stdout-buf-len++] = ''0;
         } else {
            // integer to string, count the digits
            var data:char[];
            data = &.stdout-buf-data[.stdout-buf-len];
            +digits = 0;
            loop {
               data[digits++] = (val % 10) + ''0;
               val /= 10;
               if val == 0 { break }
            }
            // reverse the string
            +start = 0;
            +end = digits - 1;
            loop start < end {
               +tmp = data[start];
               data[start] = data[end];
               data[end] = tmp;
               start++;
               end--;
            }
            .stdout-buf-len += digits;
         }
      }
      stdout-reserve(len:u32) @inline {
         +space = .stdout-buf-cap - .stdout-buf-len;
         if space < len {
            if .stdout-buf-cap == 0 {
               .stdout-buf-cap = 256;
            } else {
               .stdout-buf-cap += .stdout-buf-cap;
            }
            space = .stdout-buf-cap - .stdout-buf-len;
            loop space < len {
               .stdout-buf-cap += .stdout-buf-cap;
               space = .stdout-buf-cap - .stdout-buf-len;
            }
            C.realloc-arr(.stdout-buf-data, .stdout-buf-cap);
         }
      }
      stdout-cstr(str:char[]) @inline {
         stdout-bytes(str, C.strlen(str));
      }
      stdout-char(val:char) @inline {
         stdout-reserve(1);
         .stdout-buf-data[.stdout-buf-len++] = val;
      }
      stdout-flush() {
         1:X.Fd.write(.stdout-buf-data, .stdout-buf-len);
         .stdout-buf-len = 0;
      }
      struct Stdout[] {
         str(so:this, str:char[]) @inline {
            stdout-cstr(str);
         }
         str(so:this, str:char[], len:u32) @inline {
            stdout-bytes(str, len);
         }
         cstr(so:this, str:char[], len:u32) @inline {
            stdout-bytes(str, len);
         }
         end(so:this) {
            stdout-flush();
         }
      }
   }
   using u32 {
      stdout(val:this, so:C.Stdout) {
         C.stdout-u32(val);
      }
   }
   using u8 {
      stdout(val:this, so:C.Stdout) {
         C.stdout-u32(val);
      }
   }
   using char {
      stdout(val:this, so:C.Stdout) {
         C.stdout-char(val);
      }
   }
}
