require "LibCp1/stdout.cp1";
require "LibC/stdio.cp1";
require "LibC/stdlib.cp1";
require "LibC/string.cp1";
require "Posix/unistd.cp1";
require "Posix/fcntl.cp1";
using C = LibC;
using C1 = LibCp1;
using X = Posix;
using Cp1 {
#BuildCommonCodes{compile:true}
var include-stdint:bool;
var include-stdbool:bool;
var include-stddef:bool;
var expr-is-processed:u8[];
var func-head-outputted-c:i32;
var func-head-outputted-v:Func[];
var func-body-outputted-c:i32;
var func-body-outputted-v:Func[];
struct BasicType[
   method-c:i32,
   method-cap:i32,
   method-v:Func[],
];
var basic-type:BasicType.[BasicTypeId#COUNT];
basic-type(t:BasicTypeId):At @inline {
   return t;
}
var ctx-begin-row:u32;
var ctx-begin-col:u32;
var ctx-end-row:u32;
var ctx-end-col:u32;
var ctx-func:DeclFunc;
var ctx-func-id:Func;
var file-c:File;
var file-cap:File;
var file-v:FileData.[];
enum File[#nil = -1, #0]:i32 {
   ptr(f:this):FileData @inline {
      return .file-v[f];
   }
   path(f:this):char[] @inline {
      return f.ptr().path;
   }
   path-len(f:this):u16 @inline {
      return f.ptr().path-len;
   }
   stdout-reserve(f:this, so:C1.StdOut, unused:intc) {
      so.reserve += f.ptr().path-len;
   }
   stdout(f:this, so:C1.StdOut, unused:intc) {
      C1.stdout-cstr-nr(f.ptr().path);
   }
   jscode(f:this, jc:JsCode) {
      jscode-cstr(f.ptr().path);
   }
}
struct FileData[
   path:char[],
   path-len:u16,
   data:ref,
   id-table:Id[],
   at-table:At[],
   cvar-table:Cvar[],
];
var id-table:Id[];
var include-table-cap:i32;
var include-table:Include[];
var at-table:At[];
var cvar-table:Cvar[];
id-add(id-len:u8, id-str:char[]):Id {
   found! = .id-map.get-or-insert(id-str, id-len, .id-c);
   if found != -1 { return found }
   // loop j = 0; .id-c; j++ {
   //    if (&&, .id-len-v[j] == id-len, C.memcmp(.id-str-v[j], id-str, id-len) == 0) {
   //       return j;
   //    }
   // }
   id-idx! = .id-c++;
   if .id-cap <= .id-c {
      old-cap! = .id-cap;
      grow(.id-cap, .id-c);
      realloc(.id-len-v, .id-cap, old-cap);
      realloc(.id-str-v, .id-cap, old-cap);
      realloc(.id-c-name-v, .id-cap, old-cap); 
   }
   .id-len-v[id-idx] = id-len;
   .id-str-v[id-idx] = id-str;
   return id-idx;
}
var import-new-c:u32;
var import-v:Include[];
var import-file-v:File[];
var import-required-v:u8[];
var import-cap:u32;
var import-c:u32;
import(path:Include, require:bool, file:File) {
   loop i = 0; .import-c; i++ {
      // C1.stdout{"import " path " " path:base " checking if exists, " i:u32 " = " path ''\n}
      if .import-v[i] == path {
         // C1.stdout{"re-import " path ''\n}
         if require {
            if (.import-required-v[i >> 3] & (1 << (i & 7))) == 0 {
               C1.stdout{"Error, '" path "' was previously an import-only of '" .import-file-v[i] "' but is now required by '" file "'\n"}
               C1.stdout{"Consider requiring '" path "' instead of importing it on '" .import-file-v[i] "'.\n"}
               C1.stdout{"Or you may import '" path "' on '" file "' instead of requiring it.\n"}
               C.exit(#failure);
            }
         }
         return;
      }
   }
   // C1.stdout{"import " path " " path:base ''\n}
   if true {
      i! = .import-c++;
      if .import-cap < .import-c {
         grow(.import-cap, .import-c);
         C.realloc-arr(.import-v, .import-cap);
         C.realloc-arr(.import-file-v, .import-cap);
         C.realloc-arr(.import-required-v, (.import-cap + 7) >> 3);
      }
      .import-v[i] = path;
      .import-file-v[i] = file;
      if require {
         .import-required-v[i >> 3] |= 1 << (i & 7);
      } else {
         .import-required-v[i >> 3] &= 0xff ^ (1 << (i & 7));
      }
      // C1.stdout{"import " path " added as " i:u32 ''\n}
   }
   .import-new-c++;
}
sqlite-init();
read-cp1(path:char[], path-len:u32):ref;
req-parse(in-path-cp1:char[], in-path-cp1-len:u8, require:bool):char[];
read(in-path-cp1:char[], in-path-cp1-len:u16, strdup:bool, require:bool) {
   // C1.stdout{"read " in-path-cp1 "\n"}
   in-path! = req-parse(in-path-cp1, in-path-cp1-len, require);

   var r-begin:Rdr.;
   r-begin.reff = read-file(in-path, in-size!);
   if r-begin.reff == null {
      C1.stdout{"Cannot open file for reading: " in-path-cp1 ''\n}
      // var i:u8[] = [];
      // i[0] = 0;
      C.exit(#failure);
   }

   file-idx! = .file-c++;
   if .file-cap <= .file-c {
      old-cap! = .file-cap;
      .file-cap = grow(.file-c:base):File;
      realloc(.file-v, .file-cap:base, old-cap:base);
   }
   file! = .file-v[file-idx];
   if strdup {
      var path:char[];
      quick-alloc-arr(path, in-path-cp1-len + 1);
      C.memcpy(path, in-path-cp1, in-path-cp1-len);
      path[in-path-cp1-len] = ''\0;
      file.path = path;
   } else {
      file.path = in-path-cp1;
   }
   file.path-len = in-path-cp1-len;
   file.data = r-begin.reff;

   var r:Rdr.;
   r.reff = r-begin.reff;
   if true {
      id-c! = r.n();
      // C1.stdout{"There are " id-c " ids\n"}
      quick-alloc-arr(.id-table, id-c);
      file.id-table = .id-table;
      loop i = 0; id-c; i++ {
         id-len! = r.n1();
         id-str! = r.charr;
         r.pos += id-len + 1;
         .id-table[i] = id-add(id-len, id-str);
      }
   }
   if true {
      include-c! = r.n();
      // C1.stdout{"There are " include-c " includes\n"}
      if .include-table-cap <= include-c {
         old-cap! = .include-table-cap;
         grow(.include-table-cap, include-c);
         realloc(.include-table, .include-table-cap, old-cap);
      }
      loop i = 0; include-c; i++ {
         include-len! = r.n1();
         include-str! = r.reff;
         r.pos += include-len + 1;
         // found! = -1;
         // loop j = 0; .include-c; j++ {
         //    if (&&, .include-len-v[j] == include-len, C.memcmp(.include-str-v[j], include-str, include-len) == 0) {
         //       found = j;
         //       break;
         //    }
         // }
         .include-table[i] = include-add(include-len, include-str);
      }
   }
   if true {
      at-c! = r.n();
      // C1.stdout{"There are " at-c " at\n"}
      quick-alloc-arr(.at-table, at-c);
      file.at-table = .at-table;
      var at-type:NameType;
      loop i = 0; at-c; i++ {
         at-type.rd(r);
         if at-type == #basic {
            BasicTypeId.rd(basic!, r);
            .at-table[i] = basic-type(basic);
         } else {
            At.rd(at-parent!, r);
            Id.rd(at-name!, r);
            // C1.stdout{"read at type " at-type ''  at-type.cp1-name() ''  at-name ''\n}
            // C1.stdout{"- parent " at-parent ''\n}
            // C1.stdout{"- name " at-name ''\n}
            found! = .at-map.get-or-insert(at-parent, at-type, at-name, .at-c:base);
            // loop j = 0; .at-c; j++ {
            //    at! = .at-v[j];
            //    if (&&, at.parent == at-parent, at.type == at-type, at.name.id == at-name) {
            //       found = j;
            //       break;
            //    }
            // }
            // C1.stdout{"found " found ''\n}
            // C1.stdout{"at " i ", name-c " at-name-c ", found " found ''\n}
            if found == -1 {
               at-idx! = .at-c++;
               // C1.stdout{"1 as " at-idx ''\n}
               if .at-cap <= .at-c {
                  old-cap! = .at-cap;
                  .at-cap = grow(.at-c:base):At;
                  realloc(.at-v, .at-cap:base, old-cap:base);
               }
               at! = .at-v[at-idx];
               at.init(at-type, at-parent, at-name);
               .at-table[i] = at-idx:At;
            } else {
               // C1.stdout{"2 as " found ''\n}
               .at-table[i] = found:At;
            }
         }
      }
   }
   if true {
      cvar-c! = r.n():Cvar;
      quick-alloc-arr(.cvar-table, cvar-c:base);
      file.cvar-table = .cvar-table;
      // C1.stdout{"There are " cvar-c " cvars\n"}
      // C.out.flush();
      cvar-begin! = .cvar-c;
      .cvar-c += cvar-c;
      if .cvar-cap <= .cvar-c {
         old-cap! = .cvar-cap;
         .cvar-cap = grow(.cvar-c:base):Cvar;
         realloc(.cvar-v, .cvar-cap:base, old-cap:base);
      }
      // malloc(.cvar-table, .cvar-c);
      // file.cvar-table = .cvar-table;
      loop cvar-idx = cvar-begin, i = 0; cvar-c; cvar-idx++; i++ {
         cvar! = .cvar-v[cvar-idx];
         cvar.file = file-idx;
         cvar.include.rd(r);
         cvar.at.rd(r);
         cvar.decl.rd(r);
         cvar.flags.rd(r);
         cvar.row = r.n();
         cvar.col = r.n();
         name! = cvar.decl.name;
         // .cvar-table[i] = cvar-idx;

         at! = cvar.at.ptr();
         cvar-v! = at.cvar-v;
         loop i = 0; at.cvar-c; i++ {
            cvar2! = cvar-v[i].ptr();
            if cvar2.decl.name == name {
               C1.stdout{file-idx '': cvar.row '': cvar.col ": Cannot declare constant '" name "' because it was already declared at " cvar2.file '': cvar2.row '': cvar2.col "\n"}
               C.exit(#failure);
            }
         }
         at-cvar-idx! = at.cvar-c++;
         if at.cvar-cap <= at.cvar-c {
            old-cap! = at.cvar-cap;
            grow(at.cvar-cap, at.cvar-c);
            realloc(at.cvar-v, at.cvar-cap, old-cap);
            cvar-v = at.cvar-v;
         }
         cvar-v[at-cvar-idx] = cvar-idx;
         if (cvar.flags & #set-expr) != #0 {
            cvar.expr-set.rd(r);
         } else {
            cvar.last-cvar.rd(r);
         }
         .cvar-table[i] = cvar-idx;
      }
   }
   if true {
      gvar-c! = r.n():Gvar;
      // C1.stdout{"There are " gvar-c " gvars\n"}
      // C.out.flush();
      gvar-begin! = .gvar-c;
      .gvar-c += gvar-c;
      if .gvar-cap <= .gvar-c {
         old-cap! = .gvar-cap;
         .gvar-cap = grow(.gvar-c:base):Gvar;
         realloc(.gvar-v, .gvar-cap:base, old-cap:base);
      }
      // malloc(.gvar-table, .gvar-c);
      // file.gvar-table = .gvar-table;
      loop gvar-idx = gvar-begin, i = 0; gvar-c; gvar-idx++; i++ {
         gvar! = .gvar-v[gvar-idx];
         gvar.include.rd(r);
         gvar.at.rd(r);
         gvar.decl.rd(r);
         gvar.row = r.n();
         gvar.col = r.n();
         gvar.file = file-idx;
         name! = gvar.decl.name;
         // .gvar-table[i] = gvar-idx;

         at! = gvar.at.ptr();
         gvar-v! = at.gvar-v;
         loop i = 0; at.gvar-c; i++ {
            gvar2! = gvar-v[i].ptr();
            if gvar2.decl.name == name {
               C1.stdout{file-idx '': gvar.row '': gvar.col ": Cannot declare global variable '" name "' because it was already declared at " gvar2.file '': gvar2.row '': gvar2.col "\n"}
               C.exit(#failure);
            }
         }
         at-gvar-idx! = at.gvar-c++;
         if at.gvar-cap <= at.gvar-c {
            old-cap! = at.gvar-cap;
            grow(at.gvar-cap, at.gvar-c);
            realloc(at.gvar-v, at.gvar-cap, old-cap);
            gvar-v = at.gvar-v;
         }
         gvar-v[at-gvar-idx] = gvar-idx;
      }
   }
   enum-c! = r.n():Enum;
   // C1.stdout{"There are " enum-c " enums\n"}
      // C.out.flush();
   e-idx-begin! = .enum-c;
   .enum-c += enum-c;
   if .enum-cap <= .enum-c {
      old-cap! = .enum-cap;
      .enum-cap = grow(.enum-c:base):Enum;
      realloc(.enum-v, .enum-cap:base, old-cap:base);
   }
   loop e-idx = e-idx-begin; enum-c; e-idx++ {
      var e:EnumData;
      quick-alloc-one(e);
      .enum-v[e-idx] = e;
      e.file = file-idx;
      e.begin-row = r.n();
      e.begin-col = r.n();
      e.end-row = r.n();
      e.end-col = r.n();
      e.include.rd(r);
      e.at.rd(r);
      e.base-type.rd(r);
      e.flags.rd(r);
      e.overload-get-last = #nil;
      e.overload-set-last = #nil;
      e.overload-math-last = #nil;
      e.overload-compare-last = #nil;
      e.overload-if-begin = #nil;
      e.overload-if-else = #nil;
      e.overload-if-end = #nil;
      e.overload-statement = #nil;
      at-i! = e.at;
      at! = at-i.ptr();
      if at.def != #undefined {
         C1.stdbuf{file-idx '': e.begin-row '': e.begin-col ": Cannot define enum " at.name.id " because it was already defined as "}
         if at.def == #struct {
            s! = at.decl.structt.ptr();
            C1.stdout{"struct at " s.file '': s.begin-row '': s.begin-col "\n"}
         } else {
            s! = at.decl.enumm.ptr();
            C1.stdout{"enum at " s.file '': s.begin-row '': s.begin-col "\n"}
         }
         C.exit(#failure);
      }
      at.decl.enumm = e-idx;
      at.def = #enum;
      if (e.flags & #real-name) != #0 {
         e.real-name.rd(r);
      } else {
         e.real-name = #nil;
      }
      if (e.flags & #soa-field) != #0 {
         e.soa-field-gvar-at.rd(r);
         e.soa-field-gvar-id.rd(r);
      }
      // C1.stdout{"printing at of enum:\n"}
      // loop {
      //    if at.type == #basic {
      //       C1.stdout{"- #basic #" at.name.basic.cp1-name() ''\n}
      //    } else {
      //       C1.stdout{"- #" at.type.cp1-name() ''  at.name.id ''\n}
      //    }
      //    if at.parent == #root { break }
      //    at = at.parent.ptr();
      // }
   }
   struct-c! = r.n():Struct;
   // C1.stdout{"There are " struct-c:base " structs\n"}
   s-idx-begin! = .struct-c;
   .struct-c += struct-c;
   if .struct-cap <= .struct-c {
      old-cap! = .struct-cap;
      .struct-cap = grow(.struct-c:base):Struct;
      realloc(.struct-v, .struct-cap:base, old-cap:base);
   }
   loop s-idx = s-idx-begin; struct-c; s-idx++ {
      fvar-c! = r.n1();
      var s:StructData;
      quick-alloc-plus(s, FvarData[usz] * fvar-c);
      .struct-v[s-idx] = s;
      s.file = file-idx;
      s.fvar-c = fvar-c;
      s.begin-row = r.n();
      s.begin-col = r.n();
      s.end-row = r.n();
      s.end-col = r.n();
      s.include.rd(r);
      s.at.rd(r);
      s.flags.rd(r);
      at-i! = s.at;
      at! = at-i.ptr();
      if at.def != #undefined {
         C1.stdbuf{file-idx '': s.begin-row '': s.begin-col ": Cannot define struct " at.name.id " because it was already defined as "}
         if at.def == #enum {
            e! = at.decl.enumm.ptr();
            C1.stdout{"enum at " e.file '': e.begin-row '': e.begin-col ''\n}
         } else {
            s2! = at.decl.structt.ptr();
            C1.stdout{"struct at " s2.file '': s2.begin-row '': s2.begin-col ''\n}
         }
         C.exit(#failure);
      }
      // C1.stdout{"at(" at-i ") is a struct: " at.name.id ", parent is " at.parent ''\n}
      at.decl.structt = s-idx;
      at.def = #struct;
      // s.name.rd(r);
      // C1.stdout{s.begin-row '': s.begin-col " - " s.end-row '': s.end-col ": /" s.name ''(}
      loop j = 0; fvar-c; j++ {
         fvar! = s.fvar-v[j];
         fvar.decl.rd(r);
         // if j != 0 {
         //    C1.stdout{", "}
         // }
         // fvar.decl.type.write(C.out);
         // C1.stdout{''  fvar.decl.name ""}
      }
      // C1.stdout{")\n"}
      if (s.flags & #real-name) != #0 {
         s.real-name.rd(r);
      } else {
         s.real-name = #nil;
      }
      if (s.flags & #aligned) != #0 {
         s.aligned = r.n();
      }
   }
   func-c! = r.n():Func;
   // C1.stdout{"There are " func-c " functions\n"}
      // C.out.flush();
   f-idx-begin! = .func-c;
   .func-c += func-c;
   if .func-cap <= .func-c {
      old-cap! = .func-cap;
      .func-cap = grow(.func-c:base):Func;
      realloc(.func-v, .func-cap:base, old-cap:base);
   }
   loop f-idx = f-idx-begin; func-c; f-idx++ {
      farg-c! = r.n1();
      var f:DeclFunc;
      quick-alloc-plus(f, Farg[usz] * farg-c);
      .func-v[f-idx] = f;
      f.farg-c = farg-c;
      f.file = file-idx;
      f.begin-row = r.n();
      f.begin-col = r.n();
      f.end-row = r.n();
      f.end-col = r.n();
      f.include.rd(r);
      f.at.rd(r);
      at-i! = f.at;
      f.decl.rd(r);
      var r0:Rdr.;
      r0.reff = f;
      // C1.stdout{"func :" f.decl.name " was declared on an at:\n"}
      // if true {
      //    at-i! = f.at;
      //    loop {
      //       at! = at-i.ptr();
      //       C1.stdout{"- " at.name.id ''\n}
      //       at-i = at.parent;
      //       if at-i == #root { break }
      //    }
      // }
      // C1.stdout{f.begin-row '': f.begin-col " - " f.end-row '': f.end-col ": :" f.decl.name ''(}
      f.lvar-c = #0;
      .ctx-func = f;
      .ctx-func-id = f-idx;
      // grow(f.lvar-cap, farg-c);
      // malloc(f.lvar-v, f.lvar-cap);
      loop j = 0; farg-c; j++ {
         farg! = f.farg-v[j];
         farg.rd(r);
         // if j != 0 {
         //    C1.stdout{", "}
         // }
         // farg.decl.type.write(C.out);
         // C1.stdout{''  farg.decl.name ""}
      }
      this-idx! = r.n1():i8;
      f.this-idx = this-idx;
      if this-idx != -1 {
         f.this-group = r.n1();
      }
      group-c! = r.n1();
      f.group-c = group-c;
      loop i = 0; group-c; i++ {
         f.group-v[i] = r.n1();
      }
      // C1.stdout{")\n"}
      f.flags.rd(r);
      if (f.flags & #real-name) != #0 {
         f.real-name.rd(r);
      } else {
         f.real-name = #nil;
      }
      if (f.flags & #meta-method) != #0 {
         f.meta-method-prefix1.rd(r);
         f.meta-method-prefix2.rd(r);
         f.meta-method-end1.rd(r);
      }
      if (f.flags & #case) != #0 {
         f.cas.rd(r);
      }
      if (f.flags & #decl) != #0 {
         len! = r.n();
         f.decl-len = len;
         f.decl-str = quick-alloc(len + 1);
         C.memcpy(f.decl-str, r.reff, len);
         f.decl-str[len] = 0;
         r.pos += len;
      }
      f.overload = r.n1():Overload;
      at! = at-i.ptr();
      name! = f.decl.name;
      func-v! = at.func-v;
      loop i = 0; at.func-c; i++ {
         func2! = func-v[i].ptr();
         if (func2.decl.name == name) && (func2.farg-c == farg-c) && (func2.group-c == group-c) && (C.memcmp(func2.group-v, f.group-v, group-c) == 0) {
            C1.stdout{file-idx '': f.begin-row '': f.begin-col ": Cannot declare function '" name "' because it was already declared at " func2.file '': func2.begin-row '': func2.begin-col "\n"}
            C.exit(#failure);
         }
      }
      at-func-idx! = at.func-c++;
      if at.func-cap <= at.func-c {
         old-cap! = at.func-cap;
         grow(at.func-cap, at.func-c);
         realloc(at.func-v, at.func-cap, old-cap);
         func-v = at.func-v;
      }
      func-v[at-func-idx] = f-idx;
   }
   Func.rd(func-main!, r);
   if func-main != #nil {
      func-main += f-idx-begin;
      if .func-main != #nil {
         first! = .func-main.ptr();
         second! = func-main.ptr();
         C1.stdout{"There are more than one function with @main attribute, first is " first.file '': first.begin-row '': first.begin-col " and second is " file-idx '': second.begin-row '': second.begin-col ''\n}
         C.exit(#failure);
      }
      .func-main = func-main;
   }
   loop f-idx = f-idx-begin; func-c; f-idx++ {
      f! = .func-v[f-idx];
      if (f.flags & #has-body) == #0 { continue }
      size! = r.n4();
      f.body-file-pos = r.pos - r-begin.pos;
      r.pos += size;
   }
   loop r.n() {
      Include.rd(path!, r);
      require2! = r.b();
      import(path, require2 && require, file-idx);
   }
   template-code-idx-begin! = .template-code-c;
   template-code-c! = r.n():TemplateCode;
   // C1.stdout{"there are " template-code-c:base " template codes\n"}
   old-template-code-c! = .template-code-c;
   .template-code-c += template-code-c;
   if .template-code-cap <= .template-code-c {
      old-cap! = .template-code-cap;
      .template-code-cap = grow(.template-code-c:base):TemplateCode;
      realloc(.template-code-v, .template-code-cap:base, old-cap:base);
   }
   loop i = template-code-idx-begin; template-code-c; i++ {
      td! = .template-code-v[i];
      td.name.rd(r);
      td.row = r.n();
      td.line-c = r.n();
      td.with-reflection = r.b();
      td.no-cache = r.b();
      td.code-len = r.n();
      td.code-crc32c = r.n4();
      td.code = r.p1;
      r.pos += td.code-len;
      td.at.rd(r);
      td.file = file-idx;
      loop j = 0; old-template-code-c; j++ {
         td2! = .template-code-v[j];
         if (td2.name == td.name) && (td2.at == td.at) {
            C1.stdout{file-idx '': td.row ": Template code '" td.name "' was redeclared. Previously declared at " td2.file '': td2.row ''\n}
            C.exit(#failure);
         }
      }
      // C1.stdout{"template " td.name "\n"}
   }
   loop r.n() {
      var ti:TemplateInstData. = ?;
      ti.name.rd(r);
      ti.row = r.n();
      ti.col = r.n();
      ti.arg-len = r.n();
      ti.arg-crc32c = r.n4();
      ti.arg = r.charr;
      r.pos += ti.arg-len;
      ti.at.rd(r);
      ti.file = file-idx;
      ti.require = require;
      template-inst(ti);
   }
}
// var out:C.File;
var process-first:Func;
var process-last:Func;
var func-in-process:u8[];
var include-is-outputted:u8[];
var include-outputted-c:i32;
var include-outputted-v:Include[];
var cvar-is-outputted:u8[];
var cvar-outputted-c:i32;
var cvar-outputted-v:Cvar[];
var gvar-is-outputted:u8[];
var gvar-outputted-c:i32;
var gvar-outputted-v:Gvar[];
var enum-is-outputted:u8[];
var enum-outputted-c:i32;
var enum-outputted-v:Enum[];
var struct-is-outputted:u8[];
var struct-outputted-c:i32;
var struct-outputted-v:Struct[];
// var current-dir:char[1024];
// var current-dir-len:u16;
var include-dir:char[1024];
var include-dir-len:u16;
var define-v:char[][];
var define-len-v:u16[];
var define-c:u16;
var include-path-v:char[][];
var include-path-len-v:u16[];
var include-path-c:u8;

var id-set:Id;
var id-add:Id;
var id-eq:Id;
var id-ne:Id;
var id-gt:Id;
var id-ge:Id;
var id-lt:Id;
var id-le:Id;

c-init(crc32c:u32);
quickjs-begin(file:char[], file-len:u8, tc-name:char[], tc-name-len:u8, code-crc32c:u32, arg-crc32c:u32, require:bool):bool;
quickjs-hex(data:char[], code-crc32c:u32):u32;
quickjs-end(js-data:char[], js-data-len:u32, require:bool);
include "build-crc32c.c" {
   build-crc32c():u32 @no-decl;
}
main(arg-c:intc, arg-v:char[][]):intc @main {
   "#ifdef _WIN32";
   // Remove .exe from binary path
   if true {
      arg! = arg-v[0];
      len! = C.strlen(arg);
      if (arg[len - 4] == ''.) && (arg[len - 3] == ''e) && (arg[len - 2] == ''x) && (arg[len - 1] == ''e) {
         arg[len - 4] = ''\0;
      }
   }
   // Convert path separators from '\' to '/'
   loop i = 0; arg-c; i++ {
      arg! = arg-v[i];
      if arg[0] == ''- { continue }
      loop j = 0; ; j++ {
         if arg[j] == ''\0 {
            break;
         } elif arg[j] == ''\\ {
            arg[j] = ''/;
         }
      }
   }
   "#endif";
   input-file-c! = 0:u16;
   var input-file-v:char[][];
   var input-file-len-v:u8[];
   C.malloc-arr(input-file-v, arg-c * ref[usz]);
   C.malloc-arr(input-file-len-v, arg-c * u8[usz]);
   C.malloc-arr(.include-path-v, arg-c * ref[usz]);
   C.malloc-arr(.include-path-len-v, arg-c * u16[usz]);
   C.malloc-arr(.define-v, arg-c * ref[usz]);
   C.malloc-arr(.define-len-v, arg-c * u8[usz]);
   var output-file:char[] = null;
   watermark! = false;
   process-all! = false;
   var comment-for-func:char[] = null;
   comment-for-func-len! = 0;
   var crc32c = build-crc32c();
   loop i = 1; i < arg-c {
      arg! = arg-v[i++];
      if arg[0] == ''- {
         if arg[2] == ''\0 {
            if arg[1] == ''w {
               watermark = true;
            } elif arg[1] == ''c {
               output-file = arg-v[i++];
               if output-file == null {
                  C1.stdout{"The option -c must be followed by a path\n"}
                  "goto usage;";
               }
            } elif arg[1] == ''F {
               // For hacking the output C code,
               // to determine the beginning and end of function bodies
               comment-for-func = arg-v[i++];
               if comment-for-func == null {
                  C1.stdout{"The option -F must be followed by a path\n"}
                  "goto usage;";
               }
               comment-for-func-len = C.strlen(comment-for-func);
            } elif arg[1] == ''I {
               arg = arg-v[i++];
               if arg == null {
                  C1.stdout{"The option -I must be followed by a path\n"}
                  "goto usage;";
               }
               arg-len! = C.strlen(arg);
               if arg[arg-len] != ''/ {
                  arg[arg-len++] = ''/;
               }
               // Allocate +256 of memory so we can use
               // include paths as scratch when checking for file existence
               var mem:char[];
               C.malloc-arr(mem, arg-len + 256);
               C.memcpy(mem, arg, arg-len);
               .include-path-v[.include-path-c] = mem;
               .include-path-len-v[.include-path-c] = arg-len;
               .include-path-c++;
            } elif arg[1] == ''P {
               process-all = true;
            } else {
               "invalid_option:;";
               if arg[1] == ''\0 {
                  C1.stdout{"Invalid option '-'\n"}
               } else {
                  C1.stdout{"Invalid option '-" arg[1] "'\n"}
               }
               "goto usage;";
            }
         } elif arg[1] == ''D {
            var def:char[] = &arg[2];
            def-len! = C.strlen(def);
            if def-len == 0 {
               C1.stdout{"The option -D must follow the syntax -D[key=value] without space.\n"}
               "goto usage;";
            }
            crc32c = crc32c(crc32c, def, def-len);
            .define-v[.define-c] = def;
            .define-len-v[.define-c] = def-len;
            .define-c++;
         } else {
            "goto invalid_option;";
         }
      } else {
         arg-len! = C.strlen(arg);
         if arg-len > 255 {
            C1.stdout{"The path '" arg "' exceeds 255 bytes, please use shorter paths\n"}
            "goto usage;";
         }
         input-file-v[input-file-c] = arg;
         input-file-len-v[input-file-c] = arg-len;
         input-file-c++;
      }
   }
   bin! = arg-v[0];
   var abs-path = .include-dir; // :char[512];
   var abs-path-len:u16 = 0;
   if bin[0] == ''/ {
      abs-path-len = C.strlen(bin);
      C.memcpy(abs-path, bin, abs-path-len);
      abs-path[abs-path-len] = ''\0;
   } else {
      has-slash! = false;
      loop i = 0; ; i++ {
         if bin[i] == ''\0 { break; }
         if bin[i] == ''/ {
            has-slash = true;
            break;
         }
      }
      if has-slash {
         "#ifdef _WIN32";
         var cwd:char[1024];
         X.getcwd(cwd, 1024);
         C.strcpy(abs-path, &cwd[2]);
         var i = 0;
         loop ; ; i++ {
            if abs-path[i] == ''\0 {
               break;
            } elif abs-path[i] == ''\\ {
               abs-path[i] = ''/;
            }
         }
         abs-path[i++] = ''/;
         C.strcpy(&abs-path[i], bin);
         "#else";
         C.realpath(bin, abs-path);
         "#endif";
      } else {
         path! = C.strdup(C.getenv("PATH"));
         var found;
         "#ifdef _WIN32";
         loop i = 0; path[i] != ''\0; i++ {
            if path[i] == ''\\ {
               path[i] = ''/;
            }
         }
         found = C.strtok(path, ";");
         "#else";
         found = C.strtok(path, ":");
         "#endif";
         fd! = X.Fd#nil;
         loop found != null {
            "#ifdef _WIN32";
            C.sprintf(abs-path, "%s/%s.exe", found, bin);
            "#else";
            C.sprintf(abs-path, "%s/%s", found, bin);
            "#endif";
            fd = X.open(abs-path, #rdonly);
            if fd != #nil {
               fd.close();
               break;
            }
            "#ifdef _WIN32";
            found = C.strtok(null, ";");
            "#else";
            found = C.strtok(null, ":");
            "#endif";
         }
         if fd == #nil {
            C1.stdout{"Cannot run " bin " because we can't detect its absolute path\n"}
            C.exit(#failure);
         }
         C.free(path);
      }
   }
   slash1! = C.strrchr(abs-path, ''/);
   slash1[0] = ''\0;
   slash2! = C.strrchr(abs-path, ''/);
   slash2[0] = ''\0;
   .include-dir-len = C.strlen(.include-dir);
   c-init(crc32c);
   if (input-file-c == 0) || (output-file == null) {
      "usage:";
      C1.stdout{
        "Usage: " arg-v[0] " [options] [file.cp1] [file2.cp1...]\n"
      '= Options:
      '=    -c [path]   Output C file to [path]
      '=    -I [path]   Add path to the search directory
      '=    -D[key=val] Add a key-value pair to variable 'D' in metaprograms' codes.
      '=    -w          Add disclaimer (watermark) at the top of the output C file
      '=                that says the output is generated by Cp1
      '=    -P          Process all functions.
      }
      return 1;
   }

   if false {
      quick-alloc-undo(0);
   }

   .id-map.init();
   .include-map.init();
   .at-map.init();
   quick-alloc-init();
   .func-main = #nil;

   loop type = 0:BasicTypeId; BasicTypeId#COUNT; type++ {
      at-idx! = .at-c++;
      if .at-cap <= .at-c {
         old-cap! = .at-cap;
         .at-cap = grow(.at-c:base):At;
         realloc(.at-v, .at-cap:base, old-cap:base);
      }
      at! = .at-v[at-idx];
      at.init(#basic, #root, type:Id);
   }

   // if true {
   //    at-i! = basic-type(#bool);
   // }

   .import-cap = 32;
   C.malloc-arr(.import-v, .import-cap);
   C.malloc-arr(.import-file-v, .import-cap);
   C.malloc-arr(.import-required-v, (.import-cap + 7) >> 3);
   .template-inst-cap = 32:TemplateInst;
   C.malloc-arr(.template-inst-v, .template-inst-cap:base);

   loop i = 0; input-file-c; i++ {
      inc! = include-add(input-file-len-v[i], input-file-v[i]);
      if !inc.validate(err!) {
         C1.stdbuf{"Command line argument path "}
         err.print(inc);
         C.exit(#failure);
      }
      import(inc, true, #nil);
   }
   loop {
      "import_now:;";
      new-c! = .import-new-c;
      if new-c == 0 { break }
      .import-new-c = 0;
      loop i = .import-c - new-c; new-c; i++ {
         path! = .import-v[i];
         read(path.str(), path.len(), false, (.import-required-v[i >> 3] & (1 << (i & 7))) != 0);
      }
   }

   if .template-inst-new-c:base != 0 {
      // process template instantiations
      if .jscode-buf-cap == 0 {
         .jscode-buf-cap = 4096;
         C.malloc-arr(.jscode-buf-data, .jscode-buf-cap);
      }
      new-c! = .template-inst-new-c;
      .template-inst-new-c = 0:TemplateInst;
      loop i = .template-inst-c - new-c; new-c; i++ {
         ti! = .template-inst-v[i];
         at! = ti.at;
         name! = ti.name;
         found! = false;
         // C1.stdout{"template instantiation of " ti.name "; " ti.arg, ti.arg-len " " ti.arg-len "\n"}
         loop j = 0:TemplateCode; .template-code-c; j++ {
            tc! = .template-code-v[j];
            if (at == tc.at) && (name == tc.name) {
               if quickjs-begin(tc.file.path(), tc.file.path-len(), tc.name.str(), tc.name.len(), tc.code-crc32c, ti.arg-crc32c, ti.require) {
                  .jscode-buf-len = 0;
                  jscode{
                  '= let cp1_out = [];
                  '= function O(line) {
                  '=    cp1_out.push(line);
                  '= }
                  '= let cp1_path = scriptArgs[0] + ".cp1";
                  '= let D = {};
                  }
                  loop i = 0; .define-c {
                     jscode{"D." .define-v[i], .define-len-v[i] ";\n"}
                  }
                  if tc.with-reflection {
                     jscode{
                     '= let cp1_refl = {
                     '- "root":
                     }
                     At#root.jscode-write();
                     jscode{",\n"}
                     loop at-idx = 2:At; .at-c - 2:At; at-idx++ {
                        at! = at-idx.ptr();
                        if at.parent == #relative { continue }
                        jscode{''"}
                        at-idx.jscode-write-name();
                        jscode{'<":>}
                        at-idx.jscode-write();
                        jscode{",\n"}
                     }
                     jscode{
                     '= };
                     '= for (let key in cp1_refl) {
                     '=    let type = cp1_refl[key];
                     '=    let types = type.types = {};
                     '=    if (key == "root") {
                     '=       for (let type2 of type.typev) {
                     '=          let child = cp1_refl[type2];
                     '=          types[type2] = child;
                     '=          child.parent = key;
                     '=       }
                     '=    } else {
                     '=       for (let type2 of type.typev) {
                     '=          let child = cp1_refl[key + "." + type2];
                     '=          types[type2] = child;
                     '=          child.parent = key;
                     '=       }
                     '=    }
                     '=    let functions = type.functions = {};
                     '=    for (let func of type.functionv) {
                     '=       functions[func.name] = func;
                     '=    }
                     '= }
                     '= function cp1_resolve_type(type, name) {
                     '=    if (!type.startsWith("..")) return type;
                     '=    let key = name + type.substr(1);
                     '=    if (key in cp1_refl) {
                     '=       return key;
                     '=    }
                     '=    let parent = cp1_refl[name].parent;
                     '=    key = parent + type.substr(1);
                     '=    if (key in cp1_refl) {
                     '=       return key;
                     '=    }
                     '=    while (parent in cp1_refl) {
                     '=       parent = cp1_refl[parent].parent;
                     '=       key = parent + type.substr(1);
                     '=       if (key in cp1_refl) {
                     '=          return key;
                     '=       }
                     '=    }
                     '=    return type;
                     '= }
                     '= for (let key in cp1_refl) {
                     '=    let type = cp1_refl[key];
                     '=    for (let func of type.functionv) {
                     '=       for (let argv of func.argvv) {
                     '=          for (let arg of argv) {
                     '=             arg.type = cp1_resolve_type(arg.type, key);
                     '=          }
                     '=       }
                     '=       func.type = cp1_resolve_type(func.type, key);
                     '=    }
                     '= }
                     }
                  }
                  jscode{
                    "let arg = {" ti.arg, ti.arg-len "};\n"
                  }
                  if tc.no-cache {
                     jscode{
                     '= O("// XXXXXXXX - CRC32C\n");
                     }
                  } else {
                     jscode{
                     '= if ("cp1_no_cache" in arg) O("// XXXXXXXX - CRC32C\n");
                     '- else O("
                     }
                     .jscode-buf-len += quickjs-hex(&.jscode-buf-data[.jscode-buf-len], tc.code-crc32c);
                     jscode{
                       "- CRC32C\\n\");\n"
                     }
                  }
                  code! = tc.code;
                  i! = 0;
                  line-num! = tc.row;
                  loop tc.line-c {
                     line-num++;
                     line-len! = (code[i] | (code[i + 1] << 8)):u16;
                     i += 2;
                     if line-len == 0 {
                        jscode{'= O("\n");
                        }
                     } else {
                        var line:char[] = &code[i];
                        if (line-len & 0x8000) == 0 {
                           jscode{"O(`" line, line-len "\\n`);\n"}
                        } else {
                           line-len &= 0x7fff;
                           jscode{"     " line, line-len}
                        }
                        i += line-len;
                     }
                  }
                  jscode{
                  '= {
                  }
                  "#ifdef _WIN32";
                  jscode{
                    "   let tmp_path = scriptArgs[0] + \".cp1-" X.getpid():u32 "\";\n"
                  }
                  "#else";
                  jscode{
                  '=    let tmp_path = scriptArgs[0] + ".cp1-" + os.getpid();
                  }
                  "#endif";
                  jscode{
                  '=    let file = std.open(tmp_path, "wb");
                  '=    file.puts(cp1_out.join(""));
                  '=    file.close();
                  '=    if (os.platform == "win32") os.remove(cp1_path);
                  '=    os.rename(tmp_path, cp1_path);
                  '= }
                  }
                  quickjs-end(.jscode-buf-data, .jscode-buf-len, ti.require);
               }
               found = true;
               break;
            }
         }
         if !found {
            C1.stdout{ti.file '': ti.row ": Error, cannot instantiate the template '" name "' because its code was not found.\n"}
            C.exit(#failure);
         }
      }
      "goto import_now;";
   }

   loop f-idx = 0:Func; .func-c; f-idx++ {
      f! = f-idx.ptr();
      if f.this-idx != -1 {
         at! = f.at.ptr();
         // C1.stdout{"at(" f.at ").type = #" at.type.cp1-name() ", " at.decl.struct ''\n}
         // C.out.flush();
         if at.type == #struct-enum {
            if at.decl.enumm == #nil {
               C1.stdout{f.file '': f.begin-row '': f.begin-col ": function using 'this' was declared on " at.name.id " which is not defined\n"}
               C.exit(#failure);
            }
            if at.def == #struct {
               t! = at.decl.structt.ptr();
               t-method-idx! = t.method-c++;
               if t.method-cap <= t.method-c {
                  old-cap! = t.method-cap;
                  grow(t.method-cap, t.method-c);
                  realloc(t.method-v, t.method-cap, old-cap);
               }
               t.method-v[t-method-idx] = f-idx;
            } elif at.def == #enum {
               t! = at.decl.enumm.ptr();
               t-method-idx! = t.method-c++;
               if t.method-cap <= t.method-c {
                  old-cap! = t.method-cap;
                  grow(t.method-cap, t.method-c);
                  realloc(t.method-v, t.method-cap, old-cap);
               }
               t.method-v[t-method-idx] = f-idx;
            } else {
               C1.stdout{f.file '': f.begin-row '': f.begin-col ": function using 'this' was declared on " at.name.id " which is not a struct or enum\n"}
               C.exit(#failure);
            }
         } elif at.type == #basic {
            t! = .basic-type[at.name.basic];
            t-method-idx! = t.method-c++;
            if t.method-cap <= t.method-c {
               old-cap! = t.method-cap;
               grow(t.method-cap, t.method-c);
               realloc(t.method-v, t.method-cap, old-cap);
            }
            t.method-v[t-method-idx] = f-idx;
         } else {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": function using 'this' was declared on a type that's not a struct or enum\n"}
            C.exit(#failure);
         }
      }
   }

   if .func-main != #nil {
      f! = .func-main.ptr();
      f.real-name = id-add(4, "main");
      f.flags |= #real-name;
   }

   .id-set = id-add(3, "set");
   .id-add = id-add(3, "add");
   .id-eq = id-add(2, "eq");
   .id-ne = id-add(2, "ne");
   .id-gt = id-add(2, "gt");
   .id-ge = id-add(2, "ge");
   .id-lt = id-add(2, "lt");
   .id-le = id-add(2, "le");

   if true {
      func-c8! = (.func-c:base + 7) >> 3;
      quick-alloc-arr(.func-in-process, func-c8);
      quick-alloc-arr(.func-head-outputted-v, .func-c:base);
      quick-alloc-arr(.func-body-outputted-v, .func-c:base);
   }
   if true {
      include-c8! = (.include-c + 7) >> 3;
      quick-alloc-arr(.include-is-outputted, include-c8);
      quick-alloc-arr(.include-outputted-v, .include-c);
   }
   if true {
      cvar-c8! = (.cvar-c:base + 7) >> 3;
      quick-alloc-arr(.cvar-is-outputted, cvar-c8);
      quick-alloc-arr(.cvar-outputted-v, .cvar-c:base);
   }
   if true {
      gvar-c8! = (.gvar-c:base + 7) >> 3;
      quick-alloc-arr(.gvar-is-outputted, gvar-c8);
      quick-alloc-arr(.gvar-outputted-v, .gvar-c:base);
   }
   if true {
      enum-c8! = (.enum-c:base + 7) >> 3;
      quick-alloc-arr(.enum-is-outputted, enum-c8);
      quick-alloc-arr(.enum-outputted-v, .enum-c:base);
   }
   if true {
      struct-c8! = (.struct-c:base + 7) >> 3;
      quick-alloc-arr(.struct-is-outputted, struct-c8);
      quick-alloc-arr(.struct-outputted-v, .struct-c:base);
   }

   // process the main function
   .process-first = #nil;
   .process-last = #nil;

   loop f-idx = 0:Func; .func-c; f-idx++ {
      f! = f-idx.ptr();
      if f.overload == #get {
         // C1.stdout{"overload-get\n"}
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-get is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 1) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-get must have exactly 1 argument only\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         if f.decl.type != f.at {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-get must have a return type same as the namespace where it was declared\n"}
            C.exit(#failure);
         }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-get;
         f.list1-prev = e.overload-get-last;
         e.overload-get-last = f-idx;
      } elif f.overload == #set {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-set is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if f.this-idx == -1 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-set is only applicable to methods\n"}
            C.exit(#failure);
         }
         if f.this-idx != 0 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-set must have 'this' as the first argument\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 4) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-set must have exactly 3 arguments only\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-set must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-set;
         f.list1-prev = e.overload-set-last;
         e.overload-set-last = f-idx;
      } elif f.overload == #math {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-math is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if f.this-idx == -1 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-math is only applicable to methods\n"}
            C.exit(#failure);
         }
         if f.this-idx != 0 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-math must have 'this' as the first argument\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 3) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-math must have exactly 2 arguments only\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-math must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-math;
         f.list1-prev = e.overload-math-last;
         e.overload-math-last = f-idx;
      } elif f.overload == #compare {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-compare is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if f.this-idx == -1 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-compare is only applicable to methods\n"}
            C.exit(#failure);
         }
         if f.this-idx != 0 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-compare must have 'this' as the first argument\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 3) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-compare must have exactly 2 arguments only\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-compare must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-compare;
         f.list1-prev = e.overload-compare-last;
         e.overload-compare-last = f-idx;
      } elif f.overload == #if-begin {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-begin is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if f.this-idx == -1 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-begin is only applicable to methods\n"}
            C.exit(#failure);
         }
         if f.this-idx != 0 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-begin must have 'this' as the first argument\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 2) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-begin must have exactly 1 argument\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-begin must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-if-begin;
         if e.overload-if-begin != #nil {
            f2! = e.overload-if-begin.ptr();
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": cannot activate @overload-if-begin because there's already a function with @overload-if-begin at " f2.file '': f2.begin-row '': f2.begin-col "\n"}
            C.exit(#failure);
         }
         e.overload-if-begin = f-idx;
      } elif f.overload == #if-else {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-else is only applicable to enum types\n"}
            C.exit(#failure);
         }
         // if f.this-idx == -1 {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-else is only applicable to methods\n"}
         //    C.exit(#failure);
         // }
         // if f.this-idx != 0 {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-else must have 'this' as the first argument\n"}
         //    C.exit(#failure);
         // }
         if (f.farg-c != 1) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-else must have exactly 1 argument\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-else must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-if-else;
         if e.overload-if-else != #nil {
            f2! = e.overload-if-else.ptr();
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": cannot activate @overload-if-else because there's already a function with @overload-if-else at " f2.file '': f2.begin-row '': f2.begin-col "\n"}
            C.exit(#failure);
         }
         e.overload-if-else = f-idx;
      } elif f.overload == #if-end {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-end is only applicable to enum types\n"}
            C.exit(#failure);
         }
         // if f.this-idx == -1 {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-if-end is only applicable to methods\n"}
         //    C.exit(#failure);
         // }
         // if f.this-idx != 0 {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-end must have 'this' as the first argument\n"}
         //    C.exit(#failure);
         // }
         if (f.farg-c != 0) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-end must have no arguments\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         // if f.decl.type != f.at {
         //    C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-if-end must have a return type same as the namespace where it was declared\n"}
         //    C.exit(#failure);
         // }
         e! = at.decl.enumm.ptr();
         // e.flags |= #overload-if-end;
         if e.overload-if-end != #nil {
            f2! = e.overload-if-end.ptr();
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": cannot activate @overload-if-end because there's already a function with @overload-if-end at " f2.file '': f2.begin-row '': f2.begin-col "\n"}
            C.exit(#failure);
         }
         e.overload-if-end = f-idx;
      } elif f.overload == #statement {
         at! = f.at.ptr();
         if at.def != #enum {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-statement is only applicable to enum types\n"}
            C.exit(#failure);
         }
         if f.this-idx == -1 {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": @overload-statement is only applicable to methods\n"}
            C.exit(#failure);
         }
         if (f.farg-c != 1) || (f.group-c != 1) {
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": functions with @overload-statement must have no arguments\n"}
            C.exit(#failure);
         }
         if !f-idx.process-later() { return -1 }
         e! = at.decl.enumm.ptr();
         if e.overload-statement != #nil {
            f2! = e.overload-statement.ptr();
            C1.stdout{f.file '': f.begin-row '': f.begin-col ": cannot activate @overload-statement because there's already a function with @overload-statement at " f2.file '': f2.begin-row '': f2.begin-col "\n"}
            C.exit(#failure);
         }
         e.overload-statement = f-idx;
      }
   }
   if process-all {
      loop f-i = 0:Func; .func-c; f-i++ {
         f! = f-i.ptr();
         if !f-i.process-later() {
            C.exit(#failure);
         }
      }
   } else {
      if .func-main != #nil {
         if !.func-main.process-later() {
            C.exit(#failure);
         }
      }

      loop f-i = 0:Func; .func-c; f-i++ {
         f! = f-i.ptr();
         if (f.flags & #process) != #0 {
            if !f-i.process-later() {
               C.exit(#failure);
            }
         }
      }
   }

   loop .process-first != #nil {
      f-i! = .process-first;
      .process-first = #nil;
      .process-last = #nil;
      loop {
         if !f-i.process-now() { return -1 }
         f! = f-i.ptr();
         f-i = f.process-next; 
         if f-i == #nil { break }
      }
   }

   loop i = 0; .func-head-outputted-c; i++ {
      f-idx! = .func-head-outputted-v[i];
      f! = f-idx.ptr();
      if (f.flags & #no-decl) != #0 { continue }
      if (f.flags & #decl) != #0 {
         continue;
      }
      .ctx-func = f;
      loop l = 0:Lvar; f.lvar-c; l++ {
         if !l.process() {
            C.exit(#failure);
         }
      }
   }

   // C1.stdout{"finished processing, writing...\n"}
   // .out = C.fopen(arg-v[arg-c - 1], "wb");
   .output-cap = 4096;
   C.malloc-arr(.output-data, .output-cap);
   if watermark {
      output{"// Generated by Cp1\n"}
   }
   loop i = 0; .cvar-outputted-c; i++ {
      c-i! = .cvar-outputted-v[i];
      c! = c-i.ptr();
      if c.include != #nil {
         c.include.output();
      }
   }
   loop i = 0; .enum-outputted-c; i++ {
      e-i! = .enum-outputted-v[i];
      e! = e-i.ptr();
      if e.include != #nil {
         e.include.output();
      }
   }
   loop i = 0; .struct-outputted-c; i++ {
      s-i! = .struct-outputted-v[i];
      s! = s-i.ptr();
      if s.include != #nil {
         s.include.output();
      }
   }
   loop i = 0; .gvar-outputted-c; i++ {
      g-i! = .gvar-outputted-v[i];
      g! = g-i.ptr();
      if g.include != #nil {
         g.include.output();
      }
   }
   loop i = 0; .func-head-outputted-c; i++ {
      f-idx! = .func-head-outputted-v[i];
      f! = f-idx.ptr();
      row! = f.begin-row;
      col! = f.begin-col;
      if f.decl.type != #nil {
         f.decl.type.output(f.file, row, col);
      }
      loop i = 0; f.farg-c; i++ {
         f.farg-v[i].decl.type.output(f.file, row, col);
      }
      if f.include != #nil {
         f.include.output();
      }
      if (f.flags & #cp1-name) != #0 {
         at! = f.at.ptr();
         loop i = 0, v = at.cvar-v; at.cvar-c; i++ {
            cvar! = v[i];
            if (cvar.ptr().flags & #as-enum) != #0 {
               cvar.process();
            }
         }
      }
   }
   if .include-stdint {
      output{"#include <stdint.h>\n"}
   }
   if .include-stdbool {
      output{"#include <stdbool.h>\n"}
   }
   if .include-stddef {
      output{"#include <stddef.h>\n"}
   }
   loop i = 0; .include-outputted-c; i++ {
      inc! = .include-outputted-v[i];
      if inc.str()[0] == ''[ {
         var str:char[] = &inc.str()[1];
         output{str, inc.len() - 2}
      } else {
         output{"#include " inc ''\n}
      }
   }
   loop i = 0; .cvar-outputted-c; i++ {
      c-i! = .cvar-outputted-v[i];
      c! = c-i.ptr();
      if (c.decl.flags & #no-decl) != #0 {
         continue;
      }
      output{"#define "}
      c-i.write();
      output{'' }
      if (c.flags & #set-expr) != #0 {
         output{''(}
         c.expr-set.write();
         output{'')}
      } elif c.last-cvar != #nil {
         output{''(}
         c.last-cvar.write();
         output{" + 1)"}
      } else {
         output{''0}
      }
      output{''\n}
   }
   loop i = 0; .enum-outputted-c; i++ {
      e-i! = .enum-outputted-v[i];
      e! = e-i.ptr();
      if (e.flags & #no-decl) != #0 {
         continue;
      }
      output{"typedef "}
      e.base-type.write();
      output{'' }
      e.at.write();
      output{";\n"}
   }
   loop i = 0; .struct-outputted-c; i++ {
      s-i! = .struct-outputted-v[i];
      s! = s-i.ptr();
      if (s.flags & #union) != #0 {
         output{"union "}
      } else {
         output{"struct "}
      }
      s.at.write-space();
      if (s.flags & #union) != #0 {
         output{";\nunion "}
      } else {
         output{";\nstruct "}
      }
      s.at.write-space();
      if s.fvar-c == 0 {
         output{" {\nchar unused;\n}"}
      } else {
         output{" {\n"}
         loop j = 0; s.fvar-c; j++ {
            fvar! = s.fvar-v[j];
            fvar.decl.write-type(#fvar);
            output{";\n"}
         }
         output{"}"}
      }
      if (s.flags & #aligned) != #0 {
         output{" __attribute__((aligned(" s.aligned ")))"}
      }
      output{";\n"}
   }
   loop i = 0; .gvar-outputted-c; i++ {
      g-i! = .gvar-outputted-v[i];
      g! = g-i.ptr();
      if (g.decl.flags & #no-decl) != #0 { continue }
      if (g.decl.flags & #extern) != #0 {
         output{"extern "}
      }
      g.decl.write-type(#gvar);
      output{";\n"}
   }
   loop i = 0; .func-head-outputted-c; i++ {
      f-idx! = .func-head-outputted-v[i];
      f! = f-idx.ptr();
      if (f.flags & #no-decl) != #0 { continue }
      if (f.flags & #decl) != #0 {
         if (&&, f.decl-str[0] == ''#, f.decl-str[1] == '' ) {
            output{"#define "}
            f.write();
            output{''(}
            loop j = 0; f.farg-c; j++ {
               if j != 0 {
                  output{", "}
               }
               output{f.farg-v[j].decl.name}
            }
            output{") "}
            output-bytes(&f.decl-str[2], f.decl-len - 2);
         } else {
            output-bytes(f.decl-str, f.decl-len);
         }
         output{''\n}
         continue;
      }
      .ctx-func = f;
      if (f.flags & #inline) != #0 {
         output{"static inline "}
      }
      if f.decl.type == #nil {
         output{"void"}
      } else {
         f.decl.type.write-type-info(f.decl.type-info, 0);
      }
      output{'' }
      f.write();
      output{''(}
      // if .func-main == f-idx {
      //    output{" main("}
      // } else {
      //    output{''  f.decl.name.c-name ''(}
      // }
      loop j = 0; f.farg-c; j++ {
         if j != 0 {
            output{", "}
         }
         f.farg-v[j].decl.write-lvar-type(j:Lvar);
      }
      if (f.flags & #cp1-name) != #0 {
         output{") {\nswitch(_Le_0) {\n"}
         at! = f.at.ptr();
         loop i = 0, v = at.cvar-v; at.cvar-c; i++ {
            cvar-i! = v[i];
            cvar! = cvar-i.ptr();
            if (cvar.flags & #as-enum) == #0 { continue }
            if (cvar.flags & #no-name) != #0 { continue }
            output{"case "}
            cvar-i.write();
            output{": return \"" cvar.decl.name "\";\n"}
         }
         output{"}\nreturn \"(ERROR)\";\n}\n"}
      } else {
         output{");\n"}
      }
   }
   loop i = 0; .func-body-outputted-c; i++ {
      f-idx! = .func-body-outputted-v[i];
      f! = f-idx.ptr();
      .ctx-func = f;
      .nest-id = 0;
      if (f.flags & #inline) != #0 {
         output{"static inline "}
      }
      if f.decl.type == #nil {
         output{"void"}
      } else {
         f.decl.type.write-type-info(f.decl.type-info, 0);
      }
      output{'' }
      f.write();
      output{''(}
      // if .func-main == f-idx {
      //    output{" main("}
      // } else {
      //    output{''  f.decl.name.c-name ''(}
      // }
      loop j = 0; f.farg-c; j++ {
         if j != 0 {
            output{", "}
         }
         f.farg-v[j].decl.write-lvar-type(j:Lvar);
      }
      if comment-for-func != null {
         output{") { // " comment-for-func, comment-for-func-len ''\n}
      } else {
         output{") {\n"}
      }
      f.stmt-space.write();
      if comment-for-func != null {
         output{"} // " comment-for-func, comment-for-func-len ''\n}
      } else {
         output{"}\n"}
      }
   }
   // .out = C.fopen(arg-v[arg-c - 1], "wb");
   write-file(output-file, .output-data, .output-len);
   return 0;
}
using Func {
   in-process(f-idx:this):bool {
      num! = f-idx:u32;
      n3! = num >> 3;
      n17! = 1 << (num & 7);
      return (.func-in-process[n3] & n17) != 0;
   }
   process-later(f-idx:this):bool {
      num! = f-idx:u32;
      n3! = num >> 3;
      n17! = 1 << (num & 7);
      if (.func-in-process[n3] & n17) != 0 { return true }
      .func-in-process[n3] |= n17;
      f! = f-idx.ptr();
      old-ctx-func! = .ctx-func;
      .ctx-func = f;
      f-at! = f.at;
      f-file! = f.file;
      f-row! = f.begin-row;
      f-col! = f.begin-col;
      loop j = 0; f.farg-c; j++ {
         if !f.farg-v[j].decl.process(f-file, f.farg-v[j].row, f.farg-v[j].col, f-at) {
            return false;
         }
      }
      if f.decl.type != #nil {
         f.decl.type = at-validate(f.decl.type, f-at, f-file, f-row, f-col);
         if f.decl.type == #nil {
            return false;
         }
         at! = f.decl.type.ptr();
         if (&&, at.type != #basic, at.decl.structt == #nil) {
            C1.stdout{f-file '': f-row '': f-col ": Error, the type '" at.name.id "' used as return type for function '" f.decl.name "' was not defined\n"}
            C.exit(#failure);
         }
         f.decl.type.finalize(f.decl.type-info, f-row, f-col);
      }
      .func-head-outputted-v[.func-head-outputted-c++] = f-idx;
      if (f.flags & #has-body) != #0 {
         f.process-next = #nil;
         if .process-first == #nil {
            .process-first = f-idx;
            .process-last = f-idx;
         } else {
            f-last! = .process-last.ptr();
            f-last.process-next = f-idx;
            .process-last = f-idx;
         }
      }
      if (f.flags & #meta-method) != #0 {
         prefix! = f.meta-method-prefix1;
         prefix-str! = prefix.str();
         prefix-len! = prefix.len();
         end! = f.meta-method-end1;
         end-str! = end.str();
         end-len! = end.len();
         var name:char[];
         C.malloc-arr(name, prefix-len + 1 + 3 + 1);
         C.memcpy(name, prefix-str, prefix-len);
         name[prefix-len] = ''-;
         C.memcpy(&name[prefix-len + 1], "arr", 3 + 1);
         // C1.stdout{''\' name "'\n"}
         f.meta-method-arr1 = id-add(prefix-len + 1 + 3, name);
         C.malloc-arr(name, prefix-len + 1 + 4 + 1);
         C.memcpy(name, prefix-str, prefix-len);
         name[prefix-len] = ''-;
         C.memcpy(&name[prefix-len + 1], "cstr", 4 + 1);
         // C1.stdout{''\' name "'\n"}
         f.meta-method-cstr1 = id-add(prefix-len + 1 + 4, name);
         C.malloc-arr(name, prefix-len + 1 + end-len + 1);
         C.memcpy(name, prefix-str, prefix-len);
         name[prefix-len] = ''-;
         C.memcpy(&name[prefix-len + 1], end-str, end-len + 1);
         f.meta-method-end1 = id-add(prefix-len + 1 + end-len, name);
         prefix = f.meta-method-prefix2;
         if prefix != #nil {
            prefix-str = prefix.str();
            prefix-len = prefix.len();
            C.malloc-arr(name, prefix-len + 1 + 3 + 1);
            C.memcpy(name, prefix-str, prefix-len);
            name[prefix-len] = ''-;
            C.memcpy(&name[prefix-len + 1], "arr", 3 + 1);
            // C1.stdout{''\' name "'\n"}
            f.meta-method-arr2 = id-add(prefix-len + 1 + 3, name);
            C.malloc-arr(name, prefix-len + 1 + 4 + 1);
            C.memcpy(name, prefix-str, prefix-len);
            name[prefix-len] = ''-;
            C.memcpy(&name[prefix-len + 1], "cstr", 4 + 1);
            // C1.stdout{''\' name "'\n"}
            f.meta-method-cstr2 = id-add(prefix-len + 1 + 4, name);
            C.malloc-arr(name, prefix-len + 1 + end-len + 1);
            C.memcpy(name, prefix-str, prefix-len);
            name[prefix-len] = ''-;
            C.memcpy(&name[prefix-len + 1], end-str, end-len + 1);
            f.meta-method-end2 = id-add(prefix-len + 1 + end-len, name);
         }
      }
      .ctx-func = old-ctx-func;
      return true;
   }
   process-now(f-idx:this):bool {
      f! = f-idx.ptr();
      .ctx-func = f;
      // C1.stdout{"func :" f.decl.name ''\n}

      // f.lvar-c = #0;
      // grow(f.lvar-cap, f.farg-c);
      // malloc(f.lvar-v, f.farg-c);
      // loop i = 0; f.farg-c; i ++ {
      //    farg! = f.farg-v[i];
      //    f.lvar-v[i].row = f.begin-row;
      //    f.lvar-v[i].col = f.begin-col;
      //    f.lvar-v[i].decl.copy-from(farg.decl);
      //    f.lvar-v[i].flags = #0;
      //    // C1.stdout{f.begin-row '': f.begin-col ": lvar '" f.lvar-v[i].decl.name "' has a type of " f.lvar-v[i].decl.type ''\n}
      // }
      // f.lvar-c = f.farg-c:Lvar;
      var r:Rdr.;
      file! = f.file.ptr();
      r.reff = file.data;
      .id-table = file.id-table;
      .at-table = file.at-table;
      .cvar-table = file.cvar-table;
      r.pos += f.body-file-pos;
      // stmt-c! = r.n();
      // C1.stdout{"  function has " stmt-c " statements\n"}
      // f.stmt-c = 0;
      // f.stmt-cap = 0;
      // f.stmt-v = null;
      // if true {
      //    // add a stmt lvars
      //    quick-alloc-one(+(s:StmtSpace));
      //    s.lvar-c = 0;
      //    grow(s.lvar-cap, s.lvar-c);
      //    malloc(s.lvar-v, s.lvar-cap);
      //    f.stmt-push(s.base, f.begin-row, f.begin-col, f.begin-row, f.begin-col, #space);
      // }
      f.lvars-rd(r);
      f.stmt-space.rd(r, null);
      s! = f.stmt-space.stmt-first;
      loop s != null {
         .ctx-begin-row = s.begin-row;
         .ctx-begin-col = s.begin-col;
         .ctx-end-row = s.end-row;
         .ctx-end-col = s.end-col;
         // C1.stdout{f.decl.name ''  s.begin-row '': s.begin-col " - " s.end-row '': s.end-col ''\n}
         if !s.process() {
            return false;
         }
         s = s.stmt-next;
      }
      // loop i = 0; f.stmt-c; i ++ {
      //    s! = f.stmt-v[i];
      //    .ctx-begin-row = s.begin-row;
      //    .ctx-begin-col = s.begin-col;
      //    .ctx-end-row = s.end-row;
      //    .ctx-end-col = s.end-col;
      //    if !s.process(f-idx) {
      //       return false;
      //    }
      // }

      if (f.flags & #no-body) == #0 {
         .func-body-outputted-v[.func-body-outputted-c++] = f-idx;
      }
      return true;
   }
   is-set(f-idx:this, v:u8[]):bool @inline {
      return (v[f-idx >> 3] & (1 << (f-idx & 7))) != 0;
   }
   set(f-idx:this, v:u8[]) @inline {
      v[f-idx >> 3] |= 1 << (f-idx & 7);
   }
}
}
