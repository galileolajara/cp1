using 'c = 'libc;
using 'c1 = 'libcp1;
using 'cp1 {
struct 'at-map[data'u64[(#hash-table-size + 7) >> 3]] {
   init(m'this);
   get-or-insert(m'this, parent'at, type'name-type, name'id, val'i32)'i32 {
      return m.get-or-insert(parent'u32 | (type'u32 << 30), name, val);
   }
   get-or-insert(m'this, parent-and-type'u32, name'id, val'i32)'i32;
}
struct 'map[data'u64[(#hash-table-size + 7) >> 3]] {
   init(m'this);
   get-or-insert(m'this, str'char[], len'u8, val'i32)'i32;
}
enum 'overload[#nil, #get, #set, #assign, #math, #bools, #compare, #if-begin, #if-else, #if-end, #statement]'u8;
crc32c(crc32c'u32, data'ref, size'u32)'u32 @real-name;
var id-map'map.;
var include-map'map.;
var at-map'at-map.;
meta #BuildCommonCodes {
   using 'cp1 {
      struct 'struct-data[
#  if (arg.compile) {
         file'file,
#  }
         begin-row'u32,
         begin-col'u32,
         end-row'u32,
         end-col'u32,
         include'include,
         at'at,
         flags'struct-flags,
         real-name'id,
#  if (arg.compile) {
         method-c'i32,
         method-cap'i32,
         method-v'func[],
#  }
         aligned'u32,
         fvar-c'u32,
         fvar-v'fvar-data.[0],
      ];
      struct 'stmt-if[
         base'stmt.,
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
         is-overload'bool,
         overload-type'at,
#  }
      ];
      struct 'stmt-if-elif[
         base'stmt.,
         expr'expr-i,
#  if (arg.compile) {
         expr-else'expr-i,
         val'value.,
         is-overload'bool,
#  }
      ];
      struct 'stmt-if-else[
         base'stmt.,
#  if (arg.compile) {
         if-begin'stmt-if,
         expr'expr-i,
#  }
      ];
      struct 'stmt-if-end[
         base'stmt.,
#  if (arg.compile) {
         if-begin'stmt-if,
         expr'expr-i,
#  }
      ];
      struct 'stmt-switch[
         base'stmt.,
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
#  }
         cases'expr-i,
#  if (arg.compile) {
         case-func-c'u32,
         case-func-v'stmt-switch-case-func.[],
#  }
      ];
      struct 'stmt-case-item[
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      using 'lvar {
#  if (arg.compile) {
         ptr(l'this)'lvar-data @inline {
            return .ctx-func.lvar-v[l];
         }
         name(l'this)'id @inline {
            return l.ptr().decl.name;
         }
#  }
#  if (!arg.compile) {
         ptr(l'this)'lvar-data @inline {
            return .ctx-func.lvar-v[l];
         }
         name(l'this)'id @inline {
            return l.ptr().decl.name;
         }
#  }
      }
      struct 'enum-data[
#  if (arg.compile) {
         file'file,
#  }
         begin-row'u32,
         begin-col'u32,
         end-row'u32,
         end-col'u32,
         include'include,
         at'at,
         base-type'at,
         flags'enum-flags,
         soa-field-gvar-at'at,
         soa-field-gvar-id'id,
         real-name'id,
#  if (arg.compile) {
         method-c'i32,
         method-cap'i32,
         method-v'func[],
         overload-get-last'func,
         overload-set-last'func,
         overload-math-last'func,
         overload-bools-last'func,
         overload-compare-last'func,
         overload-if-begin'func,
         overload-if-else'func,
         overload-if-end'func,
         overload-statement'func,
#  }
      ];
      struct 'expr-compare[
         base'expr.,
         left'expr-i,
         right'expr-i,
         type'compare,
#  if (arg.compile) {
         left-val'value.,
         right-val'value.,
         is-overload'bool,
#  }
      ];
      struct 'expr-assign[
         base'expr.,
         left'expr-i,
         right'expr-i,
         type'assign,
#  if (arg.compile) {
         left-val'value.,
         right-val'value.,
         is-overload'bool,
#  }
         is-stmt'bool,
      ];
      struct 'expr-lvar[
         base'expr.,
         lvar'lvar,
// #  if (!arg.compile) {
         decl'bool,
// #  }
      ];
      struct 'expr-index[
         base'expr.,
         left'expr-i,
         right'expr-i,
#  if (arg.compile) {
         left-val'value.,
         right-val'value.,
#  }
      ];
      struct 'expr-math-item[
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      struct 'expr-math[
         base'expr.,
         left'expr-i,
         right'expr-i,
         type'math,
#  if (arg.compile) {
         left-val'value.,
         right-val'value.,
         is-overload'bool,
#  }
         item-c'u8,
#  if (!arg.compile) {
         item-cap'u8,
#  }
         item-v'expr-math-item.[],
      ];
      struct 'expr-bools-item[
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      struct 'expr-bools[
         base'expr.,
         left'expr-i,
         right'expr-i,
         type'bools,
#  if (arg.compile) {
         left-val'value.,
         right-val'value.,
         is-overload'bool,
#  }
         item-c'u8,
#  if (!arg.compile) {
         item-cap'u8,
#  }
         item-v'expr-bools-item.[],
      ];
      struct 'expr-fvar[
         base'expr.,
         expr'expr-i,
         member'id,
#  if (arg.compile) {
         fvar'fvar,
         val'value.,
#  }
      ];
      struct 'expr-soa-field[
         base'expr.,
         expr'expr-i,
         group'id,
         field'id,
#  if (arg.compile) {
         expr2'expr-i,
         val'value.,
#  }
      ];
      struct 'expr-cvar[
         base'expr.,
         at'at,
         name'id,
#  if (arg.compile) {
         cvar'cvar,
         try'at,
#  }
      ];
      struct 'expr-ref[
         base'expr.,
         expr'expr-i,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      struct 'expr-unary[
         base'expr.,
         expr'expr-i,
         type'unary,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      struct 'expr-cast-fast[
         base'expr.,
         expr'expr-i,
         type'at,
#  if (arg.compile) {
         val'value.,
#  }
      ];
      struct 'expr-gvar[
         base'expr.,
#  if (!arg.compile) {
         at'at,
         name'id,
#  }
#  if (arg.compile) {
         gvar'gvar,
#  }
      ];
      struct 'decl-gvar[
#  if (arg.compile) {
         file'file,
#  }
         row'u32,
         col'u32,
         include'include,
         at'at,
         flags'gvar-flags,
         decl'decl-var-data.,
      ];
      struct 'cvar-data[
#  if (arg.compile) {
         file'file,
#  }
         row'u32,
         col'u32,
         include'include,
         at'at,
         flags'cvar-flags,
         // real-name:Id,
         decl'decl-var-data.,
         expr-set'expr-i,
         last-cvar'cvar,
      ];
      struct 'decl-var-data[
         name'id,
         type'at,
         flags'var-flags,
         real-name'id,
         type-info'type-info.,
         size-c'u8,
         size-expr-v'expr-i[],
#  if (arg.compile) {
         size-value-v'value.[],
#  }
      ];
      struct 'carg[
         reff'i8,
         expr'expr-i,
#  if (arg.compile) {
         value'value.,
#  }
      ];
      struct 'expr-func[
         base'expr.,
         at'at,
         func-name'id,
#  if (arg.compile) {
         func-idx'func,
#  }
         group-c'u8,
         group-v'u8[#expr-carg-group-limit],
         carg-c'u8,
         carg-v'carg.[0],
      ];
      struct 'expr-meta-func[
         base'expr.,
#  if (!arg.compile) {
         at'at,
         func-name'id,
         lvar'expr-i,
         lvars'expr-i[],
         group-c'u8,
         group-v'u8[#expr-carg-group-limit],
         carg-c'u8,
         carg-v'carg.[0],
#  }
#  if (arg.compile) {
         expr-c'u8,
         expr-v'expr-i[0],
#  }
      ];
      struct 'expr-meta-method[
         base'expr.,
#  if (!arg.compile) {
         thiss'expr-i,
         func-name'id,
         lvar'expr-i,
         lvars'expr-i[],
         group-c'u8,
         group-v'u8[#expr-carg-group-limit],
         carg-c'u8,
         carg-v'carg.[0],
#  }
#  if (arg.compile) {
         expr-c'u8,
         expr-v'expr-i[0],
#  }
      ];
      struct 'expr-method[
         base'expr.,
         thiss'expr-i,
         func-name'id,
#  if (arg.compile) {
         func-idx'func,
         this-value'value.,
#  }
         group-c'u8,
         group-v'u8[#expr-carg-group-limit],
         carg-c'u8,
         carg-v'carg.[0],
      ];
      struct 'decl-func[
#  if (arg.compile) {
         process-next'func,
         file'file,
#  }
         begin-row'u32,
         begin-col'u32,
         end-row'u32,
         end-col'u32,
         include'include,
         at'at,
         // name:Id,
         flags'func-flags,
         real-name'id,
         meta-method-prefix1'id,
         meta-method-prefix2'id,
#  if (arg.compile) {
         meta-method-arr1'id,
         meta-method-cstr1'id,
         meta-method-arr2'id,
         meta-method-cstr2'id,
         meta-method-end1'id,
         meta-method-end2'id,
         list1-prev'func,
#  } else {
         meta-method-end'id,
#  }
         decl-str'char[],
         decl-len'i32,
         overload'overload,
         cas'id,
         // type:At,
         decl'decl-var-data.,
#  if (!arg.compile) {
         stmt-space'stmt-space,
#  }
#  if (arg.compile) {
         stmt-space'stmt-space.,
#  }
      //    stmt-c:u32,
      // #  if (arg.compile) {
      //    stmt-cap:u32,
      // #  }
      //    stmt-v:Stmt[],
#  if (arg.compile) {
         lvar-c'lvar,
         // lvar-cap:Lvar,
         lvar-v'lvar-data.[],
         // lvar-name-v:Id[],
         body-file-pos'u32,
#  }
#  if (!arg.compile) {
         lvar-c'lvar,
         lvar-cap'lvar,
         lvar-v'lvar-data[],
#  }
         this-idx'i8,
         this-group'i8,
         group-c'i8,
         group-v'i8[#expr-carg-group-limit],
         farg-c'u8,
         farg-v'farg.[0],
      ];
      struct 'at-data[
         type'name-type,
         parent'at,
         name'at-name.,
#  if (arg.compile) {
         func-c'i32,
         func-cap'i32,
         func-v'func[],
         gvar-c'i32,
         gvar-cap'i32,
         gvar-v'gvar[],
         cvar-c'i32,
         cvar-cap'i32,
         cvar-v'cvar[],
         decl'at-type.,
         def'at-def,
#  }
      ];
      struct 'template-code-data[
         code'u8[],
         code-len'u32,
         code-crc32c'u32,
         name'id,
         at'at,
         row'u32,
         line-c'u32,
         with-reflection'bool,
         no-cache'bool,
#  if (arg.compile) {
         file'file,
#  }
      ];
      struct 'template-inst-data[
         arg'char[],
         arg-len'u32,
         arg-crc32c'u32,
         name'id,
         at'at,
         row'u32,
         col'u32,
#  if (arg.compile) {
         file'file,
         require'bool,
#  }
      ];
   }
}
var quick-alloc-c'i32;
var quick-alloc-cap'i32;
var quick-alloc-v'ref;
quick-alloc-init() {
   .quick-alloc-cap = 4 * 1024;
   .quick-alloc-v = 'c.malloc(.quick-alloc-cap);
   'c.memset(.quick-alloc-v, 0, .quick-alloc-cap);
}
quick-alloc(size'i32)'ref @real-name(qalloc) {
   if size > 1024 {
      mem! = 'c.malloc(size);
      'c.memset(mem, 0, size);
      return mem;
   }
   // mem! = C.malloc(size);
   // C.memset(mem, 0, size);
   // return mem;
   // snap to usz
   // if ref[usz] == 8 {
      size = (size + 7) & (-1 ^ 7); // align to u64
   // } else {
      // size = (size + 3) & (-1 ^ 3);
   // }
   if size <= (.quick-alloc-cap - .quick-alloc-c) {
      var r'rdr.;
      r.reff = .quick-alloc-v;
      r.pos += .quick-alloc-c;
      .quick-alloc-c += size;
      return r.reff;
   }
   // expand
   grow(.quick-alloc-cap, .quick-alloc-c + size);
   if .quick-alloc-cap > (64 * 1024) {
      .quick-alloc-cap = 64 * 1024;
   }
   .quick-alloc-v = 'c.malloc(.quick-alloc-cap);
   'c.memset(.quick-alloc-v, 0, .quick-alloc-cap);
   // C1.stdout{"expanding to " .quick-alloc-cap ''\n}
   .quick-alloc-c = size;
   return .quick-alloc-v;
}
quick-alloc-undo(size'i32) @real-name(qalloc_undo) {
   // if ref[usz] == 8 {
      size = (size + 7) & (-1 ^ 7);
   // } else {
      // size = (size + 3) & (-1 ^ 3);
   // }
   .quick-alloc-c -= size;
}
quick-alloc-one(r'ref)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-arr(r'ref, c'i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) * (c))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-plus(r'ref, plus'i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) + plus)>)
   @inline {
   quick-alloc(0);
}
malloc(r'ref)
   @no-body
   @decl('<# r = malloc(sizeof(r[0])); memset(r, 0, sizeof(r[0]))>)
   @inline {
   'c.malloc(0);
}
malloc-arr(r'ref, c'i32)
   @no-body
   @decl('<# r = malloc(sizeof(r[0]) * (c)); memset(r, 0, sizeof(r[0]) * (c))>)
   @inline {
   'c.malloc(0);
}
realloc(r'ref, c'i32, oldc'i32)
   @no-body
   @decl('<# r = realloc(r, sizeof(r[0]) * (c)); memset(r + (oldc), 0, sizeof(r[0]) * ((c) - (oldc)))>)
   @inline {
   'c.realloc(null, 0);
}
include "num.c" {
   grow(cap'i32, c'i32)
      @decl('<# cap = Fpow2gteq((c) + 8)>);
   grow(c'i32)'i32
      @decl('<# Fpow2gteq((c) + 8)>);
}
#decl-at-name-limit'i32 = 3;
union 'at-name[id'id, basic'basic-type-id];
union 'at-type[structt'struct, enumm'enum];
enum 'at-def[#undefined, #module, #struct, #enum, #basic]'u8;
using 'at-data {
   init(at'this, type'name-type, parent'at, name'id) {
      at.type = type;
      at.parent = parent;
      at.name.id = name;
      at.func-c = 0;
      at.func-cap = 0;
      at.func-v = null;
      at.gvar-c = 0;
      at.gvar-cap = 0;
      at.gvar-v = null;
      at.decl.structt = #nil;
      at.def = #undefined;
   }
}
enum 'name-type[#module, #struct-enum, #basic]'u8 {
   rd(i'this&, r'rdr) @inline {
      i = r.n1()'name-type;
   }
   wr(i'this, w'wtr) @inline {
      w.n1(i'base);
   }
   cp1-name(e'this)'char[] @cp1-name;
}
var at-c'at;
var at-cap'at;
var at-v'at-data.[];
enum 'at[#nil = -1, #root, #relative]'i32 {
   finalize(at-i'this, ti'type-info, row'u32, col'u32)'bool {
      at! = at-i.ptr();
      if at.def == #struct {
         if ti.built-in {
            if ti.ref-v[0] != 0 {
               'c1.stdout{.ctx-func.file '': row '': col ": Can't use dot symbol '.' because type '" at.name.id "' has reference\n"}
               return false;
            }
            ti.ref-v[0] = -1;
         // } else {
         //    if !ti.built-in {
         //       C.err.printf("%s:%d:%d: Missing dot symbol '.' because type '/%s' is a value\n", .ctx-func.file.path(), row, col, at.name.id.str());
         //       return false;
         //    }
         }
      } else {
         if ti.built-in {
            'c1.stdout{.ctx-func.file '': row '': col ": Can't use dot symbol '.' because type '" at.name.id "' is not a struct\n"}
            return false;
         }
      }
      return true;
   }
   output(at-i'this, file'file, row'u32, col'u32) {
      at! = at-i.ptr();
      switch at.type {
         case #struct-enum {
            if at.def == #struct {
               if at.decl.structt == #nil {
                  'c1.stdout{file '': row '': col ": Error, struct '/" at.name.id "' was not defined\n"}
                  'c.exit(#failure);
               }
               at.decl.structt.output();
            } elif at.def == #enum {
               if at.decl.enumm == #nil {
                  'c1.stdout{file '': row '': col ": Error, enum '\\" at.name.id "' was not defined\n"}
                  'c.exit(#failure);
               }
               at.decl.enumm.output();
            }
         }
         // case #basic {
         //    switch at.name.basic {
         //       case #bool {
         //          .include-stdbool = true;
         //       }
         //       case #usz {
         //          .include-stddef = true;
         //       }
         //       case #i8 {
         //          .include-stdint = true;
         //       }
         //       case #u8 {
         //          .include-stdint = true;
         //       }
         //       case #i16 {
         //          .include-stdint = true;
         //       }
         //       case #u16 {
         //          .include-stdint = true;
         //       }
         //       case #i32 {
         //          .include-stdint = true;
         //       }
         //       case #u32 {
         //          .include-stdint = true;
         //       }
         //       case #i64 {
         //          .include-stdint = true;
         //       }
         //       case #u64 {
         //          .include-stdint = true;
         //       }
         //    }
         // }
      }
   }
   write-type-info(td'this, ti'type-info, add'i32)'bool {
      if ti.const {
         output{"const "}
      }
      ti.count();
      td.write-type();
      s! = td.count-stars0(ti) + add;
      if s > 0 {
         output-bytes("********************************", s);
      }
      return true;
   }
   count-stars(td'this, ti'type-info)'i32 {
      if td == #root {
         return td.count-stars0(ti) + 1;
      } else {
         return td.count-stars0(ti);
      }
   }
   pointer(td'this)'i32 @inline {
      if td.ptr().def == #struct {
         return 1;
      } else {
         return 0;
      }
   }
   count-stars0(td'this, ti'type-info)'i32 {
      return ti.star-c + td.pointer();
   }
   write-type(td'this)'bool {
      td.write();
//    if td.typeType == #value {
//       if td.real.baseDecl == null {
//          loc! = td.location;
//          C.err.printf("%s:%d:%d: base type was null\n", loc.path, loc.row, loc.col);
//          return false;
//       }
//       return td.real.baseDecl.write()struct Type[t];
//    }
//    if td.real.basicType == #none {
//       if td.real.typestruct Def[
//       ] else {
//          if :Config.target == #c {
//             if td.real.is-union() {
//                t.write("union "#);
//             } else {
//                t.write("struct "#);
//             }
//          }
//       }
//       td.write(t);
//    } else {
//       td.write(t);
//    }
      return true;
   }
   ptr(i'this)'at-data @inline {
      return .at-v[i];
   }
   rd(i'this&, r'rdr) @inline {
      idx! = (r.n() - 1)'at;
      if idx == #nil {
         i = #nil;
      } else {
         i = .at-table[idx];
      }
   }
   put-to-header(at'this) {
      if (.at-in-header-v[at'base >> 3] & (1 << (at'base & 7))) == 0 {
         .at-in-header-v[at'base >> 3] |= 1 << (at'base & 7);
         .at-in-header-idx-v[at] = .at-in-header-c;
         .at-in-header-at-v[.at-in-header-c++] = at'base;
         if (&&, at != #root, at != #relative) {
            at.ptr().parent.put-to-header();
         }
      }
   }
   wr-header(id'this, w'wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + .at-in-header-idx-v[id]);
      }
   }
   wr(at'this, w'wtr) @inline {
      if at == #nil {
         w.n(0);
      } else {
         w.n(1 + at);
      }
   }
   wr(at'this, w'wtr, header'bool) @inline {
      if at == #nil {
         w.n(0);
      } else {
         if header {
            w.n(1 + .at-in-header-idx-v[at]);
         } else {
            w.n(1 + at'base);
            at.put-to-header();
         }
      }
   }
   write(at-idx'this) {
      at! = at-idx.ptr();
      switch at.type {
         case #module {
            if at.parent != #root { at.parent.write-space() }
            output{"_M" at.name.id.c-name()}
         }
         case #struct-enum {
            if at.def == #struct {
               t-idx! = at.decl.structt;
               t! = t-idx.ptr();
               if t-idx != #nil {
                  if (t.flags & #real-name) != #0 {
                     if t.real-name == #nil {
                        if (t.flags & #union) != #0 {
                           output{"union " at.name.id.c-name()}
                        } else {
                           output{"struct " at.name.id.c-name()}
                        }
                     } else {
                        if (t.flags & #union) != #0 {
                           output{t.real-name}
                        } else {
                           output{t.real-name}
                        }
                     }
                     return;
                  }
               }
               if (t.flags & #union) != #0 {
                  output{"union "}
               } else {
                  output{"struct "}
               }
               if at.parent != #root { at.parent.write-space() }
               output{"_N" at.name.id.c-name()}
            } elif at.def == #enum {
               t-idx! = at.decl.enumm;
               if t-idx != #nil {
                  t! = t-idx.ptr();
                  if (t.flags & #real-name) != #0 {
                     output{t.real-name}
                     return;
                  }
               }
               if at.parent != #root { at.parent.write-space() }
               output{"_N" at.name.id.c-name()}
            }
         }
         case #basic {
            switch at.name.basic {
               case #ref {
                  output{"void*"}
               }
               case #bool {
                  output{"bool"}
               }
               case #char {
                  output{"char"}
               }
               case #intc {
                  output{"int"}
               }
               case #i8 {
                  output{"int8_t"}
               }
               case #u8 {
                  output{"uint8_t"}
               }
               case #i16 {
                  output{"int16_t"}
               }
               case #u16 {
                  output{"uint16_t"}
               }
               case #i32 {
                  output{"int32_t"}
               }
               case #u32 {
                  output{"uint32_t"}
               }
               case #i64 {
                  output{"int64_t"}
               }
               case #u64 {
                  output{"uint64_t"}
               }
               case #isz {
                  output{"ssize_t"}
               }
               case #usz {
                  output{"size_t"}
               }
               case #f32 {
                  output{"float"}
               }
               case #f64 {
                  output{"double"}
               }
            }
         }
      }
   }
   write-space(at-idx'this) {
      at! = at-idx.ptr();
      switch at.type {
         case #module {
            if at.parent != #root { at.parent.write-space() }
            output{"_M" at.name.id.c-name()}
         }
         case #struct-enum {
            // if at.def == #struct {
               if at.parent != #root { at.parent.write-space() }
               output{"_N" at.name.id.c-name()}
            // } elif at.def == #enum {
            //    if at.parent != #root { at.parent.write-space() }
            //    output{"_E" at.name.id.c-name}
            // }
         }
         case #basic {
            switch at.name.basic {
               case #ref {
                  output{"_Tref"}
               }
               case #bool {
                  output{"_Tbool"}
               }
               case #char {
                  output{"_Tchar"}
               }
               case #intc {
                  output{"_Tintc"}
               }
               case #i8 {
                  output{"_Ti8"}
               }
               case #u8 {
                  output{"_Tu8"}
               }
               case #i16 {
                  output{"_Ti16"}
               }
               case #u16 {
                  output{"_Tu16"}
               }
               case #i32 {
                  output{"_Ti32"}
               }
               case #u32 {
                  output{"_Tu32"}
               }
               case #i64 {
                  output{"_Ti64"}
               }
               case #u64 {
                  output{"_Tu64"}
               }
               case #isz {
                  output{"_Tisz"}
               }
               case #usz {
                  output{"_Tusz"}
               }
               case #f32 {
                  output{"_Tf32"}
               }
               case #f64 {
                  output{"_Tf64"}
               }
            }
         }
      }
   }
}

enum 'include-error[#none, #suffix, #absolute, #dot-slash, #slash, #double-slash, #cp1, #space]'u8 {
   print(e'this, path'include) {
      switch e {
         case #suffix {
            'c1.stdout{''\' path "' must end with .cp1\n"}
         }
         case #absolute {
            'c1.stdout{''\' path "' is an absolute path. Please use relative paths.\n"}
         }
         case #dot-slash {
            'c1.stdout{''\' path "' must not contain './' character sequence.\n"}
         }
         case #slash {
            'c1.stdout{''\' path "' must not contain '\\' character.\n"}
         }
         case #double-slash {
            'c1.stdout{''\' path "' must not contain '//' character sequence.\n"}
         }
         case #cp1 {
            'c1.stdout{''\' path "' must not contain '.cp1' character sequence except as a suffix.\n"}
         }
         case #space {
            'c1.stdout{''\' path "' must not contain a space character.\n"}
         }
      }
   }
}
enum 'include[#nil = -1, #0]'i32 {
   validate(path'this, err'include-error&)'bool {
      str! = path.str();
      len! = path.len();
      if (len >= 4) && (str[len - 4] == ''.) && (str[len - 3] == ''c) && (str[len - 2] == ''p) && (str[len - 1] == ''1) {
         // ok
      } else {
         err = #suffix;
         return false;
      }
      if str[0] == ''/ {
         err = #absolute;
         return false;
      }
      loop i = 0; len; i++ {
         if str[i] == ''\\ {
            err = #slash;
            return false;
         }
      }
      loop i = 0; len; i++ {
         if str[i] == ''  {
            err = #space;
            return false;
         }
      }
      loop i = 0; len - 4; i++ {
         if (str[i] == ''.) && (str[i + 1] == ''c) && (str[i + 2] == ''p) && (str[i + 3] == ''1) {
            err = #cp1;
            return false;
         }
      }
      loop i = 0; len - 1; i++ {
         if (str[i] == ''.) && (str[i + 1] == ''/) {
            err = #dot-slash;
            return false;
         }
      }
      loop i = 0; len - 1; i++ {
         if (str[i] == ''/) && (str[i + 1] == ''/) {
            err = #double-slash;
            return false;
         }
      }
      return true;
   }
   str(i'this)'char[] @inline {
      return .include-str-v[i];
   }
   len(i'this)'u8 @inline {
      return .include-len-v[i];
   }
   wr(i'this, w'wtr) @inline {
      w.n(i'base + 1);
   }
   rd(i'this&, r'rdr) @inline {
      idx! = (r.n() - 1)'include;
      if idx == #nil {
         i = #nil;
      } else {
         i = .include-table[idx];
      }
   }
   output(thiss'this) @inline {
      num! = thiss'u32;
      n3! = num >> 3;
      n17! = 1 << (num & 7);
      if (.include-is-outputted[n3] & n17) != 0 { return }
      .include-is-outputted[n3] |= n17;
      .include-outputted-v[.include-outputted-c++] = thiss;
   }
   stdout-reserve(i'this, so'c1'StdOut, p'c1'StdOutStr) {
      p.reserve(.include-str-v[i], .include-len-v[i], so);
   }
   output-reserve(i'this, o'output, p'cp1'output-str) {
      p.reserve(.include-str-v[i], .include-len-v[i], o);
   }
}

var id-c'i32;
var id-cap'i32;
var id-str-v'char[][];
var id-len-v'u8[];
var id-c-name-v'char[][];
var include-c'i32;
var include-cap'i32;
var include-str-v'char[][];
var include-len-v'u8[];
var func-main'func;
enum 'id[#nil = -1, #0]'i32 {
   stdout-reserve(id'this, so'c1'StdOut, p'c1'StdOutStr) @inline {
      p.reserve(id.str(), id.len(), so);
   }
   jscode(id'this, jc'js-code) @inline {
      jscode-bytes(id.str(), id.len());
   }
   output-reserve(id'this, o'output, p'cp1'output-str) @inline {
      p.reserve(id.str(), id.len(), o);
   }
   c-name(id'this)'char[] {
      var c-name'char[] = .id-c-name-v[id];
      if c-name != null { return c-name }
      len! = .id-len-v[id];
      str! = .id-str-v[id];
      c-name = quick-alloc(len + 1);
      .id-c-name-v[id] = c-name;
      loop i = 0; len; i++ {
         if str[i] == ''- {
            c-name[i] = ''_;
         } else {
            c-name[i] = str[i];
         }
      }
      c-name[len] = ''\0;
      return c-name;
   }
   str(id'this)'char[] @inline {
      return .id-str-v[id];
   }
   len(id'this)'u8 @inline {
      return .id-len-v[id];
   }
   wr-header(id'this, w'wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + .id-in-header-idx-v[id]);
      }
   }
   wr(id'this, w'wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + id);
      }
   }
   wr(id'this, w'wtr, header'bool) @inline {
      if id == #nil {
         w.n(0);
      } else {
         if header {
            w.n(1 + .id-in-header-idx-v[id]);
         } else {
            w.n(1 + id'base);
            if (.id-in-header-v[id'base >> 3] & (1 << (id'base & 7))) == 0 {
               .id-in-header-v[id'base >> 3] |= 1 << (id'base & 7);
               .id-in-header-idx-v[id] = .id-in-header-c;
               .id-in-header-id-v[.id-in-header-c++] = id'base;
            }
         }
      }
   }
   rd(id'this&, r'rdr) @inline {
      idx! = (r.n() - 1)'id;
      if idx == #nil {
         id = #nil;
      } else {
         id = .id-table[idx];
      }
   }
}
var template-code-v'template-code-data.[];
var template-code-cap'template-code;
var template-code-c'template-code;
enum 'template-code[]'u32; 
var template-inst-v'template-inst-data.[];
var template-inst-cap'template-inst;
var template-inst-c'template-inst;
enum 'template-inst[]'u32; 

}
