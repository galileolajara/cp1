require "LibCp1/stdout.cp1";
require "LibCp1/sprintf.cp1";
require "LibC/stdio.cp1";
require "LibC/stdlib.cp1";
require "LibC/string.cp1";
require "Posix/fcntl.cp1";
require "Posix/unistd.cp1";
require "Posix/stat.cp1";
using 'c = 'libc;
using 'c1 = 'libcp1;
using 'x = 'posix;
print-commands(bin'char[]) {
   'c1.stdout{
   "Usage: " bin " [file.cp1]\n"
   }
}
validate-cp1-path(bin'char[], cp1-path'char[]) {
   if cp1-path[0] == ''/ {
      print-commands(bin);
      'c1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n"}
      'c.exit(#failure);
   }
   var cp1-path-len = 'c.strlen(cp1-path);
   if (&&, cp1-path[0] == ''., cp1-path[1] == ''/) {
      cp1-path = &cp1-path[2];
      cp1-path-len -= 2;
   }
   loop j = 0; cp1-path-len; j++ {
      if cp1-path[j] == ''\\ {
         print-commands(bin);
         'c1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain backslashes '\\', please use forward slashes '/' instead\n"}
         'c.exit(#failure);
      }
   }
   loop j = 0; cp1-path-len; j++ {
      if cp1-path[j] == ''  {
         print-commands(bin);
         'c1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain a space\n"}
         'c.exit(#failure);
      }
   }
   loop j = 0; cp1-path-len - 1; j++ {
      if (&&, cp1-path[j] == ''., cp1-path[j + 1] == ''/) {
         print-commands(bin);
         'c1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain './'\n"}
         'c.exit(#failure);
      }
   }
   if !(&&, cp1-path-len > 4, cp1-path[cp1-path-len - 4] == ''., cp1-path[cp1-path-len - 3] == ''c, cp1-path[cp1-path-len - 2] == ''p, cp1-path[cp1-path-len - 1] == ''1) {
      print-commands(bin);
      'c1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must be a filename that ends with '.cp1', for example: main.cp1\n"}
      'c.exit(#failure);
   }
}
get-compiler(bin'char[], compiler'char[]) {
   var path = 'c.strdup('c.getenv("PATH"));
   "#ifdef _WIN32";
   loop i = 0; ; i++ {
      if path[i] == ''\0 {
         break;
      } elif path[i] == ''\\ {
         path[i] = ''/;
      }
   }
   "#endif";
   var found;
   "#ifdef _WIN32";
   found = 'c.strtok(path, ";");
   "#else";
   found = 'c.strtok(path, ":");
   "#endif";
   loop found != null {
      // C1.stdout{"- " found ''\n}
      var fd, compile'char[512];
      'c1.sprintf(compile, f?);
      "#ifdef _WIN32";
      f.f{found "/tcc.exe"}
      "#else";
      f.f{found "/tcc"}
      "#endif";
      fd = 'x.open(compile, #rdonly);
      if fd != #nil {
         'c.strcpy(compiler, "tcc");
         return;
      }
      "#ifdef _WIN32";
      f.f{found "/clang.exe"}
      "#else";
      f.f{found "/clang"}
      "#endif";
      fd = 'x.open(compile, #rdonly);
      if fd != #nil {
         'c.strcpy(compiler, "clang");
         return;
      }
      "#ifdef _WIN32";
      f.f{found "/gcc.exe"}
      "#else";
      f.f{found "/gcc"}
      "#endif";
      fd = 'x.open(compile, #rdonly);
      if fd != #nil {
         'c.strcpy(compiler, "gcc");
         return;
      }
      "#ifdef _WIN32";
      found = 'c.strtok(null, ";");
      "#else";
      found = 'c.strtok(null, ":");
      "#endif";
   }
   'c1.stdout{"Cannot execute '" bin " run' because the required compile was not found: tcc clang or gcc\n"}
   'c.exit(#failure);
}
include "system2.h" {
   system2(cmd'char[])'intc @real-name;
}
main(arg-c'intc, arg-v'char[][])'intc {
   "#ifdef _WIN32";
   if true {
      var arg = arg-v[0];
      var len = 'c.strlen(arg);
      if (arg[len - 4] == ''.) && (arg[len - 3] == ''e) && (arg[len - 2] == ''x) && (arg[len - 1] == ''e) {
         arg[len - 4] = ''\0;
      }
   }
   loop i = 0; arg-c; i++ {
      var arg = arg-v[i];
      loop j = 0; ; j++ {
         if arg[j] == ''\0 {
            break;
         } elif arg[j] == ''\\ {
            arg[j] = ''/;
         }
      }
   }
   "#endif";
   var bin = arg-v[0];
   if arg-c != 2 {
      print-commands(bin);
      'c.exit(#failure);
   }
   validate-cp1-path(bin, arg-v[1]);

   var c-path'char[15];
   'c.strcpy(c-path, "cp1-c-XXXXXX");
   var c-fd = 'x.mkstemp(c-path);
   if c-fd == #nil {
      print-commands(bin);
      'c1.stdout{"Error, cannot open file for reading: " c-path ''\n}
      'c.exit(#failure);
   }
   c-fd.close();
   'x.unlink(c-path);
   var exe-path'char[21];
   'c.strcpy(exe-path, "./cp1-exe-XXXXXX");
   var exe-fd = 'x.mkstemp(exe-path);
   if exe-fd == #nil {
      print-commands(bin);
      'c1.stdout{"Error, cannot open file for reading: " exe-path ''\n}
      'c.exit(#failure);
   }
   exe-fd.close();
   'x.unlink(exe-path);
   c-path[12] = ''.;
   c-path[13] = ''c;
   c-path[14] = ''\0;
   var compiler'char[8];
   get-compiler(bin, compiler);
   "#ifdef _WIN32";
   exe-path[16] = ''.;
   exe-path[17] = ''e;
   exe-path[18] = ''x;
   exe-path[19] = ''e;
   exe-path[20] = ''\0;
   if bin[0] != ''/ {
      loop i = 0; bin[i] != ''\0; i++ {
         if bin[i] == ''/ {
            bin[i] = ''\\;
         }
      }
   }
   "#endif";
   var command'char[1024];
   'c1.sprintf(command, f?);
   f.f{''" bin, 'c.strlen(bin) - 4 "-compile\" -c \"" c-path "\" \"" arg-v[1] "\""}
   // C1.stdout{"run command: " command ''\n}
   var c-ret = system2(command);
   if c-ret != 0 {
      'x.unlink(c-path);
      'c.exit(#failure);
   }
   f.f{compiler " -o " exe-path " " c-path}
   // C1.stdout{"run command: " command ''\n}
   var compile-ret = system2(command);
   'x.unlink(c-path);
   if compile-ret != 0 {
      'c.exit(#failure);
   }
   "#ifdef _WIN32";
   loop i = 0; ; i++ {
      if exe-path[i] == ''\0 {
         break;
      } elif exe-path[i] == ''/ {
         exe-path[i] = ''\\;
      }
   }
   "#endif";
   // C1.stdout{"run command: " exe-path ''\n}
   var exe-ret = system2(exe-path);
   'x.unlink(exe-path);
   if exe-ret != 0 {
      'c.exit(#failure);
   }
   return 0;
}
