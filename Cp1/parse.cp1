import "LibCp1/stdout.cp1";
import "LibC/stdio.cp1";
import "LibC/stdlib.cp1";
import "LibC/string.cp1";
import "Posix/fcntl.cp1";
import "Posix/unistd.cp1";
import "Posix/stat.cp1";
using Cp1 = Cp1;
using C = LibC;
using C1 = LibCp1;
using X = Posix;
using Cp1 {
var import-v:Include[];
var import-cap:u32;
var import-c:u32;
decl-import(path:Include, row:u32, col:u32) {
   if !path.validate(err!) {
      C1.stdbuf{.input-path '': row '': col ": Import path "}
      err.print(path);
      C.exit(#failure);
   }
   loop i = 0; .import-c; i++ {
      if .import-v[i] == path {
         // C1.stdout{"already import '" path "' with the same arguments, silently ignoring...\n"}
         return;
      }
   }
   i! = .import-c++;
   if .import-cap <= .import-c {
      old-cap! = .import-cap;
      .import-cap = grow(.import-c);
      realloc(.import-v, .import-cap, old-cap);
   }
   .import-v[i] = path;
}
var template-name-buf:char[] @extern;
var template-name-len:u8 @extern;
var template-code-indention:u32 @extern;
var template-code-line-c:u32 @extern;
decl-template-inst(name:Id, row:u32, col:u32) {
   at! = .decl-at;
   arg-buf! = .string-buf;
   arg-len! = .string-len;
   loop i = 0; .template-inst-c; i++ {
      td! = .template-inst-v[i];
      if (td.at == at) && (td.name == name) && (td.arg-len == arg-len) && (C.memcmp(td.arg, arg-buf, arg-len) == 0) {
         // C1.stdout{"already found instantiation of template " name " with the same arguments, silently ignoring...\n"}
         return;
      }
   }
   i! = .template-inst-c++;
   if .template-inst-cap <= .template-inst-c {
      old-cap! = .template-inst-cap;
      .template-inst-cap = grow(.template-inst-c:base);
      realloc(.template-inst-v, .template-inst-cap:base, old-cap:base);
   }
   td! = .template-inst-v[i];
   td.name = name;
   var arg:char[];
   quick-alloc-arr(arg, arg-len);
   C.memcpy(arg, arg-buf, arg-len);
   td.arg = arg;
   td.arg-len = arg-len;
   td.arg-crc32c = crc32c(0, arg, arg-len);
   td.at = at;
   td.row = row;
   td.col = col;
}
decl-template-code(row:u32) {
   at! = .decl-at;
   name! = id-add(.template-name-len, .template-name-buf);
   loop i = 0; .template-code-c; i++ {
      td! = .template-code-v[i];
      if (td.at == at) && (td.name == name) {
         C1.stdout{.input-path '': .row '': .col ": Template name '" name "' was already used at line " td.row ''\n}
         C.exit(#failure);
         return;
      }
   }
   i! = .template-code-c++;
   if .template-code-cap <= .template-code-c {
      old-cap! = .template-code-cap;
      .template-code-cap = grow(.template-code-c:base);
      realloc(.template-code-v, .template-code-cap:base, old-cap:base);
   }
   td! = .template-code-v[i];
   td.name = name;
   code-len! = .string-len;
   var code:char[];
   quick-alloc-arr(code, code-len);
   C.memcpy(code, .string-buf, code-len);
   td.code = code;
   td.code-len = code-len;
   td.code-crc32c = crc32c(0, code, code-len);
   td.at = at;
   td.row = row;
   td.line-c = .template-code-line-c;
}
include-add(len:u8, str:char[]):Include {
   found! = .include-map.get-or-insert(str, len, .include-c);
   if found == -1 {
      // inserted
      include! = .include-c++;
      if .include-cap <= .include-c {
         old-cap! = .include-cap;
         grow(.include-cap, .include-c);
         realloc(.include-str-v, .include-cap, old-cap);
         realloc(.include-len-v, .include-cap, old-cap);
      }
      var text:char[] = quick-alloc(len + 1);
      C.memcpy(text, str, len);
      text[len] = 0;
      .include-str-v[include] = text;
      .include-len-v[include] = len;
      return include;
   } else {
      // found
      return found;
   }
}
var ctx-func:DeclFunc;
var id-in-header-v:u8[];
var id-in-header-idx-v:u32[];
var id-in-header-id-v:u32[];
var id-in-header-c:i32;

var at-in-header-v:u8[];
var at-in-header-idx-v:u32[];
var at-in-header-at-v:u32[];
var at-in-header-c:i32;

var decl-include:Include;
var decl-include-row:u32;
var decl-include-col:u32;
id-add(len:u8, str:char[]):Id {
   found! = .id-map.get-or-insert(str, len, .id-c);
   if found == -1 {
      // inserted
      id! = .id-c++;
      if .id-cap <= .id-c {
         old-cap! = .id-cap;
         grow(.id-cap, .id-c);
         realloc(.id-str-v, .id-cap, old-cap);
         realloc(.id-len-v, .id-cap, old-cap);
      }
      var text:char[] = quick-alloc(len + 1);
      C.memcpy(text, str, len);
      text[len] = 0;
      .id-str-v[id] = text;
      .id-len-v[id] = len;
      return id;
   } else {
      // found
      return found;
   }
}
type-info-begin() {
   .decl-var.size-c = 0;
   .decl-var.type-info.init();
   .decl-var.flags = #0;
}
type-info-finalize() {
   .decl-var.type-info.finalize();
}
type-info-arr(expr-v:ExprI[], expr-c:u8) {
   var r:Rdr.;
   r.reff = expr-v;
   if expr-v == null {
      ti! = .decl-var.type-info;
      ti.array-c += 1;
      ti.ref-v[ti.array-c] = 0;
      return;
   }
   loop i = expr-c; expr-c; {
      type-info-arr(expr-v[i -= 1]);
   }
}
type-info-arr(expr:ExprI) {
   ti! = .decl-var.type-info;
   ti.array-c += 1;
   ti.ref-v[ti.array-c] = 0;
   if expr != #nil {
      vd! = .decl-var;
      if vd.size-c == 0 {
         quick-alloc-arr(vd.size-expr-v, #decl-var-size-limit);
      }
      vd.size-expr-v[vd.size-c++] = expr;
      // C1.stdout{vd.name ", vd.size-c = " vd.size-c ''\n}
   }
}
type-info-ref(c:i8) {
   ti! = .decl-var.type-info;
   ti.ref-v[ti.array-c] += c;
}
type-info-static() {
   // C1.stdout{"built-in\n"}
   .decl-var.type-info.built-in = true;
}
decl-include-begin(inc:Include, row:u32, col:u32) {
   if .decl-include != #nil {
      C1.stdout{.input-path '': row '': col ": Cannot include inside another include of " .decl-include-row '': .decl-include-col ''\n}
      C.exit(#failure);
      return;
   }
   .decl-include = inc;
   .decl-include-row = row;
   .decl-include-col = col;
}
decl-include-end() {
   .decl-include = #nil;
}
at-basic-type(type:BasicTypeId):At {
   loop i = 0:At; .at-c; i++ {
      at! = .at-v[i];
      if (&&, at.type == #basic, at.name.basic == type) {
         return i;
      }
   }
   build-idx! = .at-c++;
   if .at-cap <= .at-c {
      old-cap! = .at-cap;
      .at-cap = grow(.at-c:base);
      realloc(.at-v, .at-cap:base, old-cap:base);
   }
   at! = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = type;
   return build-idx;
}
at-begin() {
   .build-at = .decl-at;
}
var at-begin-relative-pause:bool;
at-begin-relative-pause() {
   .at-begin-relative-pause = true;
}
at-begin-relative-resume() {
   .at-begin-relative-pause = false;
}
at-begin-relative() {
   if .at-begin-relative-pause {
      .build-at = .decl-at;
   } else {
      .build-at = #relative;
   }
}
enum Alias[#nil = -1, #0]:i32;
var at-alias-c:Alias;
var at-alias-cap:Alias;
var at-alias-name-v:Id[];
var at-alias-at-v:At[];
var at-alias-pos-v:RowCol.[];
struct RowCol[row:u32, col:u32];
at-alias(name:Id, row:u32, col:u32) {
   loop i = 0; .at-alias-c; i++ {
      if .at-alias-name-v[i] == name {
         .build-at = .at-alias-at-v[i];
         return;
      }
   }
   C1.stdout{.input-path '': row '': col ": Cannot recognize the '" name ", did you forgot to put using '" name " = ...?\n"}
   C.exit(#failure);
}
var build-at:At;
at-push(name:Id, type:NameType, row:u32, col:u32) {
   // if .build-at == #root {
   //    'c.printf(".build-at is #root for %s\n", name.str());
   // } elif .build-at == #relative {
   //    'c.printf(".build-at is #relative for %s\n", name.str());
   // } else {
   //    'c.printf(".build-at is %u for %s\n", .build-at, name.str());
   // }
   if .build-at == #relative {
      loop i = 0; .at-alias-c; i++ {
         if .at-alias-name-v[i] == name {
            .build-at = .at-alias-at-v[i];
            return;
         }
      }
   }
   .build-at = at-create(.build-at, type, name);
}
decl-alias(name:Id, at:At, row:u32, col:u32) {
   // if at.ptr().type != #module {
   //    C1.stdout{.input-path '': row '': col ": Alias can only work on namespaces that ends with '%'\n"}
   //    C.exit(#failure);
   //    return;
   // }
   loop i = 0; .at-alias-c; i++ {
      if .at-alias-name-v[i] == name {
         // if .at-alias-at-v[i] == at {
            // Ok, because templates might emit duplicate aliases
         // } else {
            C1.stdout{.input-path '': row '': col ": Alias '" name " was already declared at " .at-alias-pos-v[i].row '': .at-alias-pos-v[i].col ''\n}
            C.exit(#failure);
         // }
         return;
      }
   }
   alias-idx! = .at-alias-c++;
   if .at-alias-cap <= .at-alias-c {
      old-cap! = .at-alias-cap;
      .at-alias-cap = grow(.at-alias-c:base);
      realloc(.at-alias-name-v, .at-alias-cap:base, old-cap:base);
      realloc(.at-alias-at-v, .at-alias-cap:base, old-cap:base);
      realloc(.at-alias-pos-v, .at-alias-cap:base, old-cap:base);
   }
   .at-alias-name-v[alias-idx] = name;
   .at-alias-at-v[alias-idx] = at;
   .at-alias-pos-v[alias-idx].row = row;
   .at-alias-pos-v[alias-idx].col = col;
}
at-root() {
   .build-at = #root;
}
at-graves(graves:i8, row:u32, col:u32) {
   .build-at = .decl-at;
   loop graves > 0 {
      graves--;
      if .build-at == #root {
         C1.stdout{.input-path '': row '': col ": Too many graves in the namespace, going beyond the root namespace\n"}
         C.exit(#failure);
      }
      at! = .build-at.ptr();
      .build-at = at.parent;
   }
}
at-done():At {
   return .build-at;
}
at-create(parent:At, type:NameType, name:Id):At {
   found! = .at-map.get-or-insert(parent, type, name, .at-c:base);
   if found != -1 { return found }
   // loop i = 0:At; .at-c; i++ {
   //    at! = .at-v[i];
   //    if (&&,
   //       at.parent == parent,
   //       at.type == type,
   //       at.name.id == name) {
   //       return i;
   //    }
   // }
   build-idx! = .at-c++;
   if .at-cap <= .at-c {
      old-cap! = .at-cap;
      .at-cap = grow(.at-c:base);
      realloc(.at-v, .at-cap:base, old-cap:base);
   }
   at! = .at-v[build-idx];
   at.parent = parent;
   at.type = type;
   at.name.id = name;
   return build-idx;
}
at-create-basic(basic:BasicTypeId):At {
   loop i = 0:At; .at-c; i++ {
      at! = .at-v[i];
      if (&&,
         at.type == #basic,
         at.name.basic == basic) {
         return i;
      }
   }
   build-idx! = .at-c++;
   if .at-cap <= .at-c {
      old-cap! = .at-cap;
      .at-cap = grow(.at-c:base);
      realloc(.at-v, .at-cap:base, old-cap:base);
   }
   at! = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = basic;
   return build-idx;
}

var decl-at:At;
#decl-at-nest-limit:i32 = 8;
var decl-at-v:At[#decl-at-nest-limit];
var decl-at-c:u8;
err-msg-namespace-limit(row:u32, col:u32) {
   C1.stdout{.input-path '': row '': col ": Max number of ids in namespace reached\n"}
   C.exit(#failure);
}
decl-at-add(name:Id, type:NameType) {
   .build-at = at-create(.build-at, type, name);
}
decl-at-basic(type:BasicTypeId) {
   if .decl-at != #root {
      C1.stdout{.input-path '': .row '': .col ": Error, you cannot use 'using' on primitive types while inside another 'using'\n"}
      C.exit(#failure);
   }
   .build-at = at-create-basic(type);
}
decl-at-begin(row:u32, col:u32) {
   .decl-at-v[.decl-at-c++] = .decl-at;
   .decl-at = .build-at;
}
decl-at-end() {
   .decl-at-c--;
   .decl-at = .decl-at-v[.decl-at-c];
}
struct TokenDataI32[
   row:u32,
   col:u32,
   id:i32,
   id2:i32,
];
struct TokenDataF32[
   row:u32,
   col:u32,
   ff32:f32,
];
struct TokenDataU64[
   row:u32,
   col:u32,
   id:u64,
];
struct TokenDataIndex[
   v:intc[15],
   c:intc,
];
union TokenData[
   ii32:TokenDataI32.,
   ff32:TokenDataF32.,
   uu64:TokenDataU64.,
   index:TokenDataIndex.,
   pointer:ref,
];
struct Lexer[
   content:u8[],
   start:u8[],
   cursor:u8[],
   // limit:u8[],
   marker:u8[],
   // ctx-marker:u8[],
] {
   init(lex:this, data:u8[], size:usz) {
      lex.start = data;
      lex.cursor = data;
      lex.content = data;
      // lex.limit = & data[size];
   }
   scan(lex:this):Token @real-name(cp1_lexer_scan);
   get-oct(lex:this):u32 {
      var r-start:Rdr.;
      r-start.reff = lex.start + 2;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos;
      if length > 11 {
         C1.stdout{.input-path '': .row '': .col ": Integer literal was too long\n"}
         C.exit(#failure);
      }
      val! = 0:u64;
      loop length {
         val = (val * 8:u64) + (r-start.p1[0] - ''0);
         r-start.pos++;
      }
      if val > 4294967295u {
         C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
         C.exit(#failure);
      }
      return val:u32;
   }
   get-hex(lex:this):u32 {
      var r-start:Rdr.;
      r-start.reff = lex.start + 2;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos;
      if length > 8 {
         C1.stdout{.input-path '': .row '': .col ": Integer literal was too long\n"}
         C.exit(#failure);
      }
      val! = 0:u64;
      loop length {
         c! = r-start.p1[0];
         if c >= ''a {
            val = (val * 16:u64) + ((r-start.p1[0] - ''a) + 10);
         } elif c >= ''A {
            val = (val * 16:u64) + ((r-start.p1[0] - ''A) + 10);
         } else {
            val = (val * 16:u64) + (r-start.p1[0] - ''0);
         }
         r-start.pos++;
      }
      if val > 4294967295u {
         C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
         C.exit(#failure);
      }
      return val:u32;
   }
   get-f32(lex:this):f32 {
      var r-start:Rdr.;
      r-start.reff = lex.start;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos - 1;
      var val:f32;
      C.sscanf(r-start.charr, "%f", &val);
      return val;
   }
   get-int(lex:this, len-minus:u8):u32 {
      var r-start:Rdr.;
      r-start.reff = lex.start;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos - len-minus;
      if length > 10 {
         C1.stdout{.input-path '': .row '': .col ": Integer literal was too long\n"}
         C.exit(#failure);
      }
      val! = 0:u32;
      if length == 10 {
         loop 9 {
            val = (val * 10:u32) + (r-start.p1[0] - ''0);
            r-start.pos++;
         }
         old-val! = val;
         val = (val * 10:u32) + (r-start.p1[0] - ''0);
         if (val / 10) < old-val {
            C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
            C.exit(#failure);
         }
      } else {
         loop length {
            old-val! = val;
            val = (val * 10:u32) + (r-start.p1[0] - ''0);
            if (val / 10) < old-val {
               C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
               C.exit(#failure);
            }
            r-start.pos++;
         }
      }
      if len-minus == 0 { // no suffix, meaning its a signed integer
         if val > 2147483647 {
            C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
            C.exit(#failure);
         }
      }
      return val;
   }
   get-u64(lex:this):u64 {
      var r-start:Rdr.;
      r-start.reff = lex.start;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos - 3; // -3 to remove u64 suffix
      if length > 20 { // 18446744073709551615
         C1.stdout{.input-path '': .row '': .col ": Integer literal was too long\n"}
         C.exit(#failure);
      }
      val! = 0:u64;
      if length == 20 {
         loop 19 {
            val = (val * 10:u64) + (r-start.p1[0] - ''0);
            r-start.pos++;
         }
         old-val! = val;
         val = (val * 10:u64) + (r-start.p1[0] - ''0);
         if (val / 10) < old-val {
            C1.stdout{.input-path '': .row '': .col ": Integer literal was out of bounds\n"}
            C.exit(#failure);
         }
      } else {
         loop length {
            val = (val * 10:u64) + (r-start.p1[0] - ''0);
            r-start.pos++;
         }
      }
      return val;
   }
   get-id(lex:this, begin:u8, end:u8):i32 {
      var r-start:Rdr.;
      r-start.reff = lex.start;
      r-start.pos += begin;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos - end;
      if length > 255 {
         C1.stdout{"too long id was detected\n"}
         C.exit(#failure);
      }
      len! = length:u8;
      return id-add(length:u8, r-start.charr);
      // loop i = 0; .id-c; i++ {
      //    if .id-len-v[i] == len {
      //       if C.memcmp(.id-str-v[i], r-start.ref, len) == 0 {
      //          return i;
      //       }
      //    }
      // }
      // id! = .id-c++;
      // if .id-cap <= .id-c {
      //    old-cap! = .id-cap;
      //    grow(.id-cap, .id-c);
      //    realloc(.id-str-v, .id-cap, old-cap);
      //    realloc(.id-len-v, .id-cap, old-cap);
      // }
      // var text:char[] = quick-alloc(len + 1);
      // C.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .id-str-v[id] = text;
      // .id-len-v[id] = len;
      // return id;
   }
   get-include(lex:this):i32 {
      var r-start:Rdr.;
      r-start.reff = lex.start;
      r-start.pos += 8;
      var r-cursor:Rdr.;
      r-cursor.reff = lex.cursor;
      length! = r-cursor.pos - r-start.pos;
      // loop (r-start.charr[length] != '' ) && (r-start.charr[length] != ''\n) {
      //   length++;
      // }
      if length > 255 {
         C1.stdout{"too long include was detected\n"}
         C.exit(#failure);
      }
      return include-add(length, r-start.charr);
      // loop i = 0; .include-c; i++ {
      //    if .include-len-v[i] == len {
      //       if C.memcmp(.include-str-v[i], r-start.ref, len) == 0 {
      //          return i;
      //       }
      //    }
      // }
      // include! = .include-c++;
      // if .include-cap <= .include-c {
      //    old-cap! = .include-cap;
      //    grow(.include-cap, .include-c);
      //    realloc(.include-str-v, .include-cap, old-cap);
      //    realloc(.include-len-v, .include-cap, old-cap);
      // }
      // var text:char[] = quick-alloc(len + 1);
      // C.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .include-str-v[include] = text;
      // .include-len-v[include] = len;
      // return include;
   }
}
var last-token:Token;
struct Parser[] {
   alloc():Parser;
   free(psr:this);
   parse(psr:this, t:Token, tok:TokenData.) @real-name(cp1Parse);
}
var last-row:u32 @extern;
var last-col:u32 @extern;
var row:u32 @extern;
var col:u32 @extern;
write-func(w:Wtr, header:bool) @inline {
   w.n(.func-c:base);
   loop i = 0; .func-c; {
      f! = .func-v[i++];
      w.n1(f.farg-c);
      w.n(f.begin-row);
      w.n(f.begin-col);
      w.n(f.end-row);
      w.n(f.end-col);
      f.include.wr(w);
      f.at.wr(w, header);
      f.decl.wr(w, header);
      loop j = 0; f.farg-c; j++ {
         f.farg-v[j].wr(w, header);
      }
      w.n1(f.this-idx);
      if f.this-idx != -1 {
         w.n1(f.this-group);
      }
      w.n1(f.group-c);
      loop j = 0; f.group-c; j++ {
         w.n1(f.group-v[j]);
      }
      if header {
         if f.flags & #inline {
            // proceed
            f.flags.wr(w);
         } else {
            // remove #has-body flag
            (f.flags & (-1 ^ FuncFlags#has-body)):FuncFlags.wr(w);
         }
      } else {
         f.flags.wr(w);
      }
      if (f.flags & #real-name) != #0 {
         f.real-name.wr(w, header);
      }
      if (f.flags & #meta-method) != #0 {
         f.meta-method-prefix.wr(w, header);
         f.meta-method-end.wr(w, header);
      }
      if (f.flags & #case) != #0 {
         f.cas.wr(w, header);
      }
      if (f.flags & #decl) != #0 {
         w.n(f.decl-len);
         w.copy(f.decl-str, f.decl-len);
      }
   }
   .func-main.wr(w);
   loop i = 0; .func-c; {
      f! = .func-v[i++];
      if (f.flags & #has-body) == #0 { continue }
      if header {
         if f.flags & #inline {
            // proceed
         } else {
            // remove #has-body flag
            continue;
         }
      }
      var pos-4:Wtr.;
      pos-4.p1 = w.p1;
      w.pos += 4;
      pos-4-next! = w.pos;
      f.lvars-wr(w, header);
      f.stmt-space.wr(w, header);
      pos-4.n4(w.pos - pos-4-next);
   }
}
write-import(w:Wtr, header:bool) @inline {
   w.n(.import-c);
   loop i = 0; .import-c {
      .import-v[i++].wr(w);
   }
}
write-template-code(w:Wtr, header:bool) @inline {
   w.n(.template-code-c:base);
   // C1.stdout{"there are " .template-code-c:base " templates in parse stage\n"}
   loop i = 0; .template-code-c {
      td! = .template-code-v[i++];
      td.name.wr(w, header);
      w.n(td.row);
      w.n(td.line-c);
      w.n(td.code-len);
      w.n4(td.code-crc32c);
      w.copy(td.code, td.code-len);
      td.at.wr(w, header);
      // C1.stdout{"template code " td.name " at line " td.row " have " td.line-c " lines\n"}
   }
   w.n(.template-inst-c:base);
   // C1.stdout{"there are " .template-inst-c:base " templates in parse stage\n"}
   loop i = 0; .template-inst-c {
      td! = .template-inst-v[i++];
      td.name.wr(w, header);
      w.n(td.row);
      w.n(td.col);
      w.n(td.arg-len);
      w.n4(td.arg-crc32c);
      w.copy(td.arg, td.arg-len);
      td.at.wr(w, header);
   }
}
write-cvar(w:Wtr, header:bool) {
   w.n(.cvar-c:base);
   loop i = 0; .cvar-c; i++ {
      cvar! = .cvar-v[i];
      cvar.include.wr(w);
      cvar.at.wr(w, header);
      cvar.decl.wr(w, header);
      cvar.flags.wr(w);
      if (cvar.flags & #set-expr) != #0 {
         cvar.expr-set.wr(w, header);
      } else {
         cvar.last-cvar.wr(w);
      }
   }
}
write-gvar(w:Wtr, header:bool) {
   w.n(.gvar-c:base);
   loop i = 0; .gvar-c; i++ {
      gvar! = .gvar-v[i];
      gvar.include.wr(w);
      gvar.at.wr(w, header);
      gvar.decl.wr(w, header);
   }
}
write-enum(w:Wtr, header:bool) {
   w.n(.enum-c:base);
   loop i = 0; .enum-c; {
      e! = .enum-v[i++];
      w.n(e.begin-row);
      w.n(e.begin-col);
      w.n(e.end-row);
      w.n(e.end-col);
      e.include.wr(w);
      e.at.wr(w, header);
      e.base-type.wr(w, header);
      e.flags.wr(w);
      if (e.flags & #real-name) != #0 {
         e.real-name.wr(w, header);
      }
      if (e.flags & #soa-field) != #0 {
         e.soa-field-gvar-at.wr(w, header);
         e.soa-field-gvar-id.wr(w, header);
      }
   }
}
write-struct(w:Wtr, header:bool) {
   w.n(.struct-c:base);
   loop i = 0; .struct-c; {
      s! = .struct-v[i++];
      w.n1(s.fvar-c);
      w.n(s.begin-row);
      w.n(s.begin-col);
      w.n(s.end-row);
      w.n(s.end-col);
      s.include.wr(w);
      s.at.wr(w, header);
      s.flags.wr(w);
      // C1.stdout{"write-struct " s.at.ptr.name.id ''\n}
      // s.name.wr(w, header);
      loop j = 0; s.fvar-c; j++ {
         s.fvar-v[j].wr(w, header);
      }
      if (s.flags & #real-name) != #0 {
         s.real-name.wr(w, header);
      }
   }
}
token-name(tok:Token):char[] {
   return tok.cp1-name();
}
parse-str-init(max-size:i32);
get-row-col(out-row:u32&, out-col:u32&, end:ref, begin:ref) {
   row! = 1;
   col! = 1;
   var r:Rdr.;
   r.reff = begin;
   var r-end:Rdr.;
   r-end.reff = end;
   loop r.pos < r-end.pos {
      if r.p1[0] == ''\n {
         row++;
         col = 1;
      } else {
         col++;
      }
      r.pos++;
   }
   out-row = row;
   if r.p1[0] == ''\n {
      out-col = col - 1;
   } else {
      out-col = col;
   }
}
parse-string(r:Rdr, w:Wtr, ending:char, in-data:ref) {
   w.p1[0] = ''\';
   w.p1[1] = r.p1[1];
   w.pos += 2;
   r.pos += 2;
   loop {
      c! = r.p1[0];
      if c == ''\n {
         get-row-col(row!, col!, r.reff, in-data);
         C1.stdout{.input-path '': row '': col ": Unterminated string\n"}
         C.exit(#failure);
      }
      w.p1[0] = c;
      w.pos++;
      r.pos++;
      if c == ending {
         return;
      }
   }
}
parse-comment(r:Rdr, w:Wtr, ending:char, in-data:ref) {
   var r-begin:Rdr.;
   r-begin.pos = r.pos;
   r.pos += 2;
   loop {
      c! = r.p1[0];
      if c == ''\n {
         get-row-col(row!, col!, r.reff, in-data);
         C1.stdout{.input-path '': row '': col ": Unterminated comment\n"}
         C.exit(#failure);
      }
      r.pos++;
      if c == ending {
         len! = r.pos - r-begin.pos;
         loop len {
            w.p1[0] = '' ;
            w.pos++;
         }
         return;
      }
   }
}
var input-path:char[] @real-name(input_path);
char-escape-value(c:char):i32;
struct IncludePath[len:u32, str:char[256]];
var include-path-v:IncludePath[];
var include-path-cap:u8;
var include-path-c:u8;
// var lock-path:char[];
// parser-at-exit();
write-cp1(input-path-len:u32, text-data:ref, text-size:usz, bin-data:ref, bin-size:usz):bool;
file-mtime(path:char[]):u64;
file-should-parse(path:char[], path-len:u32, mtime:u64):bool;
main(arg-c:intc, arg-v:char[][]):intc @main {
   // C1.stdout{"hello world " arg-c:u32 " " arg-v[0] " " arg-v[1] "\n"}
   if false {
      // preprocess-def("", 0);
      export();
   }
   .include-path-cap = 8;
   C.malloc-arr(.include-path-v, .include-path-cap);
   quick-alloc-init();
   // loop i = 1; i < arg-c {
   //    arg! = arg-v[i++];
   //    if arg[0] == ''- {
   //       if arg[1] == ''I {
   //          arg = arg-v[i++];
   //          if arg == null {
   //             C1.stdout{arg-v[0] ": Error, '-I' must be followed by a path to a directory"}
   //             "goto usage;";
   //          }
   //          arg-len! = C.strlen(arg);
   //          if arg[arg-len - 1] != ''/ {
   //             arg[arg-len++] = ''/;
   //          }
   //          j! = .include-path-c++;
   //          if .include-path-cap < .include-path-c {
   //             .include-path-cap = grow(.include-path-c);
   //             C.realloc-arr(.include-path-v, .include-path-cap);
   //          }
   //          var inc:IncludePath;
   //          quick-alloc-plus(inc, arg-len);
   //          C.memcpy(inc.str, arg, arg-len);
   //          inc.len = arg-len;
   //          .include-path-v[j] = inc;
   //       }
   //    } else {
   //       if .input-path != null {
   //          C1.stdout{arg-v[0] ": Error, there should be only one file path\n"}
   //          "goto usage;";
   //       }
   //       .input-path = arg;
   //    }
   // }
   // if .input-path == null {
   //    "usage:";
   //    C1.stdout{
   //      "Usage: " arg-v[0] " [file.cp1]\n"
   //    '= Options:
   //    '=   -I [directory]     Adds [directory] to the search path
   //    }
   //    return 1;
   // }
   if arg-c != 3 {
      C1.stdout{
         "Usage: " arg-v[0] " input.cp1 output.cp1-b\n"
      }
      return 1;
   }
   .decl-include = #nil;
   .id-map.init();
   .include-map.init();
   .at-map.init();
   .func-main = #nil;
   .input-path = arg-v[1];
   // C1.stdout{"reading " .input-path ''\n}
   var in-data:u8[];
   in-data = read-file(.input-path, 0, 2, 0, in-size!);
   // input-path-len! = C.strlen(.input-path);
   // mtime! = file-mtime(.input-path);
   if in-data == null {
      C1.stdout{"Cannot open file for reading: " .input-path ''\n}
      C.exit(#failure);
   }
   // in-data[0] = ''\n;
   // in-data = &in-data[1];
   lock-path! = arg-v[2];
   // .lock-path = lock-path;
   // if true {
   //    if !C.Fd.open(fd!!, lock-path, #create | #excl) {
   //       // Can:T create output file
   //       Sys.stat(lock-path, out-stat!);
   //       in-fd.stat(in-stat!);
   //       var skip;
   //       "#ifdef __APPLE__";
   //          skip = (||, out-stat.mtimespec.sec > in-stat.mtimespec.sec, (&&, out-stat.mtimespec.sec == in-stat.mtimespec.sec, out-stat.mtimespec.nsec > in-stat.mtimespec.nsec));
   //       "#elif defined(__unix__)";
   //          skip = (||, out-stat.mtim.sec > in-stat.mtim.sec, (&&, out-stat.mtim.sec == in-stat.mtim.sec, out-stat.mtim.nsec > in-stat.mtim.nsec));
   //       "#endif";
   //       if skip {
   //          // Skip parsing
   //          C1.stdout{"Skipping parsing of " .input-path " because the output file is newer than the input file\n"}
   //          return 0;
   //       }
   //    } else {
   //       // We created the output file, make sure to unlink it when
   //       // the parser gets parsing error
   //       parser-at-exit();
   //    }
   //    fd.close();
   // }

   if (&&, in-data[in-size - 2] == ''\r, in-data[in-size - 1] == ''\n) {
      C1.stdout{
      "Error reading file '" .input-path "' because it uses Windows-style line endings\n"
      "Please convert the line endings to Unix-style line endings\n"}
      C.exit(#failure);
   }
   if in-data[in-size - 1] != ''\n {
      C1.stdout{"Error reading file '" .input-path "' because it doesn't end with a new line\n"}
      C.exit(#failure);
   }
   if true { // Process comments
      preprocess! = false;
      // in-data = convert-old-to-new(in-data, in-size);
      var r-end:Rdr.;
      r-end.reff = in-data;
      r-end.pos += in-size;
      var r:Rdr.;
      r.reff = in-data;
      var new-data = C.malloc(in-size + 1);
      var w:Wtr.;
      w.reff = new-data;
      // Ignore texts outside the top-level curly braces
      // indent! = 0:i32;
      loop r.pos < r-end.pos {
         if r.p1[0] == ''\t {
            get-row-col(row!, col!, r.reff, in-data);
            C1.stdout{.input-path '': row '': col ": Error, use of tabs is discouraged, please use spaces instead\n"}
            C.exit(#failure);
         } elif r.p1[0] == ''/ {
            if r.p1[1] == ''/ {
               if (||, r.p1[-1] == '' , r.p1[-1] == ''\n) {
                  // ok
               } elif r.reff == in-data {
                  // ok
               } else {
                  get-row-col(row!, col!, r.reff, in-data);
                  C1.stdout{.input-path '': row '': col ": There must be a space before the // comment\n"}
                  C.exit(#failure);
               }
               // comment
               r.pos += 2;
               loop {
                  if r.p1[0] == ''\n {
                     break;
                  }
                  r.pos++;
               }
               continue;
            }
         } elif r.p1[0] == ''\' {
            if r.p1[1] == ''\' {
               // char
               c! = r.p1[2];
               if c == ''\\ {
                  if r.p1[3] == ''" {
                     get-row-col(row!, col!, r.reff, in-data);
                     C1.stdout{.input-path '': row '': col ": char ''\\\" is invalid, please use ''\" instead\n"}
                     C.exit(#failure);
                  }
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = ''\\;
                  w.p1[3] = r.p1[3];
                  w.pos += 4;
                  r.pos += 4;
                  continue;
               } else {
                  switch c {
                     case ''\' {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''' is invalid, please use ''\\' instead\n"}
                        C.exit(#failure);
                     }
                     case ''\a {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(\\a) is invalid, please use ''\\a instead\n"}
                        C.exit(#failure);
                     }
                     case ''\b {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(\\b) is invalid, please use ''\\b instead\n"}
                        C.exit(#failure);
                     }
                     case ''\f {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(\\f) is invalid, please use ''\\f instead\n"}
                        C.exit(#failure);
                     }
                     case ''\n {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(new line) is invalid, please use ''\\n instead\n"}
                        C.exit(#failure);
                     }
                     case ''\r {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(\\r) is invalid, please use ''\\r instead\n"}
                        C.exit(#failure);
                     }
                     case ''\t {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(tab) is invalid, please use ''\\t instead\n"}
                        C.exit(#failure);
                     }
                     case ''\v {
                        get-row-col(row!, col!, r.reff, in-data);
                        C1.stdout{.input-path '': row '': col ": char ''(\\v) is invalid, please use ''\\v instead\n"}
                        C.exit(#failure);
                     }
                  }
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = c;
                  w.pos += 3;
                  r.pos += 3;
                  continue;
               }
            } elif (&&, r.p1[2] == '' , (||, r.p1[1] == ''-, r.p1[1] == ''=)) {
               // string
               w.p1[0] = ''\';
               w.p1[1] = r.p1[1];
               w.p1[2] = '' ;
               w.pos += 3;
               r.pos += 3;
               r-begin! = r.charr;
               r-pos! = r.pos;
               loop {
                  c! = r.p1[0];
                  w.p1[0] = c;
                  w.pos++;
                  r.pos++;
                  if c == ''\n {
                     break;
                  }
                  if r.pos >= r-end.pos {
                     get-row-col(row!, col!, r.reff, in-data);
                     C1.stdout{.input-path '': row '': col ": Error, string must end with a new line\n"}
                     C.exit(#failure);
                  }
               }
               continue;
               // Codes to check if syntax highlighting for strings are working
               "#if 0";
                  '"hello";
                  '<hello>;
                  '[hello];
                  '{hello};
                  '(hello);
               "#endif";
            } elif r.p1[1] == ''" {
               parse-string(r, w, ''", in-data);
               continue;
            } elif r.p1[1] == ''< {
               parse-string(r, w, ''>, in-data);
               continue;
            } elif r.p1[1] == ''[ {
               parse-string(r, w, ''], in-data);
               continue;
            } elif r.p1[1] == ''{ {
               parse-string(r, w, ''}, in-data);
               continue;
            } elif r.p1[1] == ''( {
               parse-string(r, w, ''), in-data);
               continue;
            }
         } elif r.p1[0] == ''" { // C-string
            w.p1[0] = ''";
            w.pos++;
            r.pos++;
            loop {
               if r.p1[0] == ''\n {
                  get-row-col(row!, col!, r.reff, in-data);
                  C1.stdout{.input-path '': row '': col ": Unterminated string\n"}
                  C.exit(#failure);
               } elif r.p1[0] == ''" {
                  w.p1[0] = ''";
                  w.pos++;
                  r.pos++;
                  break;
               } elif r.p1[0] == ''\\ {
                  switch r.p1[1] {
                     case ''0 { }
                     case ''\\ { }
                     case ''" { }
                     case ''\' { }
                     case ''a { }
                     case ''b { }
                     case ''f { }
                     case ''n { }
                     case ''r { }
                     case ''t { }
                     case ''v { }
                     default {
                        get-row-col(row!, col!, r.reff, in-data);
                        if r.p1[1] == ''\n {
                           C1.stdout{.input-path '': row '': col ": Encountered invalid escape sequence in the string: '\\(newline)'\n"}
                        } else {
                           C1.stdout{.input-path '': row '': col ": Encountered invalid escape sequence in the string: '\\" r.charr[1] "'\n"}
                        }
                        C.exit(#failure);
                     }
                  }
                  w.p1[0] = ''\\;
                  w.p1[1] = r.p1[1];
                  w.pos += 2;
                  r.pos += 2;
               } else {
                  w.p1[0] = r.p1[0];
                  w.pos++;
                  r.pos++;
               }
               if r.pos >= r-end.pos {
                  get-row-col(row!, col!, r.reff, in-data);
                  C1.stdout{.input-path '': row '': col ": Error, unterminated string\n"}
                  C.exit(#failure);
               }
            }
            continue;
         }
         w.p1[0] = r.p1[0];
         w.pos++;
         r.pos++;
      }
      w.p1[0] = ''\0;
      C.free(in-data);
      in-data = new-data;
      var w-begin:Wtr.;
      w-begin.reff = new-data;
      in-size = w.pos - w-begin.pos;

      // C.Fd.open(fd!, "out:parsed.cp1", #write | #truncate | #create, 0o644);
      // fd.write(in-data, in-size);
      // fd.close();
      // C.out.write(in-data, in-size);

      // if preprocess {
      //    preprocess-init();
      //    preprocess(in-data, in-size);
      // }
   }
   var r-end:Rdr.;
   r-end.reff = in-data;
   r-end.pos += in-size;
   parse-str-init(in-size * 2); // multiply by two for the escape sequences

   .id-cap = 64;
   malloc-arr(.id-str-v, .id-cap);
   malloc-arr(.id-len-v, .id-cap);
   .include-cap = 64;
   malloc-arr(.include-str-v, .include-cap);
   malloc-arr(.include-len-v, .include-cap);
   .at-cap = 64:At;
   malloc-arr(.at-v, .at-cap:base);
   .at-c = 2:At;
   .at-v[0].type = #basic;
   .at-v[0].parent = #nil;
   .at-v[0].name.basic = #root;
   .at-v[1].type = #basic;
   .at-v[1].parent = #nil;
   .at-v[1].name.basic = #relative;
   .func-cap = 32:Func;
   malloc-arr(.func-v, .func-cap:base);
   .struct-cap = 32:Struct;
   malloc-arr(.struct-v, .struct-cap:base);
   .decl-fvar-cap = 32;
   malloc-arr(.decl-fvar-v, .decl-fvar-cap);

   psr! = Parser.alloc();
   Lexer.init(lex!, in-data, in-size);
   next-row! = 1;
   next-col! = 1;
   .row = 1;
   .col = 1;
   var tok:TokenData.;
   loop {
      tok.ii32.row = next-row;
      tok.ii32.col = next-col;
      t! = lex.scan();
      if true { // t != #space)
         // when reporting the row and column of tokens, skip the spaces
         pos! = lex.start;
         loop pos < r-end.p1 {
            if pos[0] == ''  {
               tok.ii32.col++;
            } elif pos[0] == ''\n {
               tok.ii32.row++;
               tok.ii32.col = 1;
            } else {
               break;
            }
            pos++;
         }
      }
      .last-row = .row;
      .last-col = .col;
      .row = tok.ii32.row;
      .col = tok.ii32.col;
      // C1.stdout{.input-path '': tok.row '': tok.col ": token " t.cp1-name() ''\n}
      // 'c.out.flush();
      // if (&&, t >= #id-quote, t < #id) {
      //    tok.id = lex.get-id(1, 0);
      //    .last-token = t;
      //    psr.parse(t, tok);
      // } else {
         switch t {
            // case #id-lparen {
            //    tok.id = lex.get-id(0, 1);
            //    psr.parse(t, tok);
            // }
            case #char1 {
               var r:Rdr.;
               r.reff = lex.start;
               tok.ii32.id = r.p1[2];
               .last-token = t;
               psr.parse(t, tok);
            }
            case #char2 {
               var r:Rdr.;
               r.reff = lex.start;
               tok.ii32.id = char-escape-value(r.p1[3]);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #space-at-no-decl-str {
               // find the '@' character and start counting from there
               var r-start:Rdr.;
               r-start.reff = lex.start;
               start! = 9;
               loop {
                  start++;
                  r-start.pos++;
                  if r-start.p1[0] == ''@ {
                     break;
                  }
               }
               tok.ii32.id = lex.get-id(start, 1);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #space-at-real-name-str {
               // find the '@' character and start counting from there
               var r-start:Rdr.;
               r-start.reff = lex.start;
               start! = 11;
               loop {
                  start++;
                  r-start.pos++;
                  if r-start.p1[0] == ''@ {
                     break;
                  }
               }
               tok.ii32.id = lex.get-id(start, 1);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #space-at-meta-method-str {
               // find the '@' character and start counting from there
               var r-start:Rdr.;
               r-start.reff = lex.start;
               start! = 13;
               loop {
                  start++;
                  r-start.pos++;
                  if r-start.p1[0] == ''@ {
                     break;
                  }
               }
               var r-end:Rdr.;
               r-end.reff = lex.cursor;
               r-end.pos -= 2;
               len! = r-end.pos - r-start.pos - 10;
               end! = 2;
               loop r-end.p1[0] != ''  {
                  r-end.pos--;
                  end++;
               }
               tok.ii32.id = lex.get-id(start, end);
               tok.ii32.id2 = lex.get-id(start + (len - end), 1);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-f32 {
               tok.ff32.ff32 = lex.get-f32();
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-u32 {
               tok.ii32.id = lex.get-int(1);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-u64 {
               tok.uu64.id = lex.get-u64();
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-i32 {
               tok.ii32.id = lex.get-int(0);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-oct {
               tok.ii32.id = lex.get-oct();
               .last-token = t;
               psr.parse(t, tok);
            }
            case #num-hex {
               tok.ii32.id = lex.get-hex();
               .last-token = t;
               psr.parse(t, tok);
            }
            case #import {
               loop i = 0; {
                  if lex.start[i++] == ''" {
                     var r-begin:Rdr.;
                     r-begin.reff = &lex.start[i];
                     var r-end:Rdr.;
                     r-end.reff = lex.cursor;
                     r-end.pos--;
                     len! = r-end.pos - r-begin.pos;
                     if len > 255 {
                        C1.stdout{.input-path '': .row '': .col ": Error, import path exceeded 255 bytes\n"}
                        C.exit(#failure);
                     }
                     tok.ii32.id = include-add(len, r-begin.charr);
                     // C1.stdout{"import '" r-begin.charr, len "'\n"}
                     break;
                  }
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #include {
               tok.ii32.id = lex.get-include();
               .last-token = t;
               psr.parse(t, tok);
            }
            case #using {
               found-semicolon! = false;
               loop i = 0; {
                  c! = lex.cursor[i];
                  if c == ''{ {
                     break;
                  } elif c == ''; {
                     found-semicolon = true;
                     break;
                  }
                  i++;
               }
               if found-semicolon {
                  t = #using-with-semicolon;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #loop {
               found-semicolon! = false;
               if (&&, lex.cursor[0] != '' , lex.cursor[0] != ''\n)  {
                  C1.stdout{.input-path '': .row '': .col ": There must be a space or new line after the keyword 'loop'\n"}
                  C.exit(#failure);
               }
               loop i = 0; {
                  // var str:char[];
                  // str = &lex.cursor[i];
                  // var start = i;
                  c! = lex.cursor[i];
                  if c == ''\0 {
                     C1.stdout{.input-path '': .row '': .col ": Keyword 'loop' was found but was not followed by '{'\n"}
                     C.exit(#failure);
                  } elif c == ''\' {
                     c = lex.cursor[i + 1];
                     if c == ''\' {
                        if lex.cursor[i + 2] == ''\\ {
                           // C1.stdout{str, 4 ''\n}
                           i += 4;
                           continue;
                        } else {
                           // C1.stdout{str, 3 ''\n}
                           i += 3;
                           continue;
                        }
                     } elif c == ''" {
                        i += 2;
                        loop {
                           if lex.cursor[i++] == ''" {
                              // C1.stdout{str, i - start ''\n}
                              break;
                           }
                        }
                        continue;
                     } elif c == ''< {
                        i += 2;
                        loop {
                           if lex.cursor[i++] == ''> {
                              // C1.stdout{str, i - start ''\n}
                              break;
                           }
                        }
                        continue;
                     } elif c == ''[ {
                        i += 2;
                        loop {
                           if lex.cursor[i++] == ''] {
                              // C1.stdout{str, i - start ''\n}
                              break;
                           }
                        }
                        continue;
                     } elif c == ''{ {
                        i += 2;
                        loop {
                           if lex.cursor[i++] == ''} {
                              // C1.stdout{str, i - start ''\n}
                              break;
                           }
                        }
                        continue;
                     } elif c == ''( {
                        i += 2;
                        loop {
                           if lex.cursor[i++] == '') {
                              // C1.stdout{str, i - start ''\n}
                              break;
                           }
                        }
                        continue;
                     } elif (&&, lex.cursor[i + 2] == '' , (||, c == ''-, c == ''=)) {
                        i += 3;
                        loop {
                           if lex.cursor[i++] == ''\n {
                              // C1.stdout{str, (i - 1) - start ''\n}
                              break;
                           }
                        }
                        continue;
                     }
                  } elif c == ''" {
                     i += 1;
                     loop {
                        c = lex.cursor[i++];
                        if c == ''" {
                           // C1.stdout{str, i - start ''\n}
                           break;
                        } elif c == ''\\ {
                           i++;
                        }
                     }
                     continue;
                  } elif c == ''{ {
                     break;
                  } elif c == ''; {
                     found-semicolon = true;
                     break;
                  }
                  i++;
               }
               if found-semicolon {
                  t = #loop-with-semicolon;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #id {
               tok.ii32.id = lex.get-id(0, 0);
               if lex.cursor[0] == ''( {
                  t = #id-then-open-parenthesis;
               } elif lex.cursor[0] == ''{ {
                  t = #id-then-open-curly-brace;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #soa-field {
               // tok.ii32.id = 
               // lex.get-id(2, 0);
               rbracket! = 1;
               loop lex.start[rbracket] != ''] {
                  rbracket++;
               }
               if true {
                  var r-start:Rdr.;
                  r-start.reff = lex.start;
                  r-start.pos += 1;
                  var r-cursor:Rdr.;
                  r-cursor.reff = lex.cursor;
                  length! = rbracket - 1;
                  end! = r-cursor.pos - r-start.pos - length;
                  if length == 0 {
                     tok.ii32.id = -1;
                  } else {
                     tok.ii32.id = lex.get-id(1, end);
                  }
               }
               if true {
                  rbracket++;
                  var r-start:Rdr.;
                  r-start.reff = lex.start;
                  r-start.pos += rbracket;
                  var r-cursor:Rdr.;
                  r-cursor.reff = lex.cursor;
                  length! = r-cursor.pos - r-start.pos;
                  tok.ii32.id2 = lex.get-id(rbracket, 0);
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #hash-id {
               tok.ii32.id = lex.get-id(1, 0);
               .last-token = t;
               psr.parse(t, tok);
            }
            case #dot-id-upper {
               tok.ii32.id = lex.get-id(1, 0);
               if lex.cursor[0] == ''( {
                  t = #dot-id-upper-then-open-parenthesis;
               } elif lex.cursor[0] == ''{ {
                  t = #dot-id-upper-then-open-curly-brace;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #id-upper {
               tok.ii32.id = lex.get-id(0, 0);
               if lex.cursor[0] == ''( {
                  t = #id-then-open-parenthesis;
               } elif lex.cursor[0] == ''{ {
                  t = #id-then-open-curly-brace;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            case #space {
               ch! = lex.cursor[0];
               if ch == ''{ {
                  t = #space-then-open-curly-brace;
               } elif .last-token == #string {
                  if ch == ''" {
                     t = #space-then-string;
                  } elif ch == ''\' {
                     ch = lex.cursor[1];
                     if (||,
                        ch == ''",
                        ch == ''<,
                        ch == ''[,
                        ch == ''{,
                        ch == ''(,
                        (&&, lex.cursor[2] == '' ,
                           (||, ch == ''-, ch == ''=)
                        )) {
                        t = #space-then-string;
                     }
                  }
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            default {
               .last-token = t;
               psr.parse(t, tok);
            }
         }
      // }
      if t == #end { break }
      pos! = lex.start;
      loop pos < lex.cursor {
         if (pos[0] & 128) == 0 {
            if pos[0] == ''\n {
               next-row++;
               next-col = 1;
            } else {
               next-col++;
            }
         }
         pos++;
      }
   }
   .last-token = #nil;
   psr.parse(#nil, tok);
   psr.free();
   // C1.stdout{"parsing finished\n"}
   var w-begin:Wtr.;
   w-begin.reff = quick-alloc((in-size << 2) + 1024);
   var w:Wtr.;
   w.reff = w-begin.reff;
   w.n(.id-c);
   loop i = 0; .id-c; i++ {
      w.n1(.id-len-v[i]);
      w.copy(.id-str-v[i], .id-len-v[i]);
      w.n1(0);
   }
   id-bit8-c! = (.id-c + 7) >> 3;
   malloc-arr(.id-in-header-v, id-bit8-c);
   malloc-arr(.id-in-header-idx-v, .id-c);
   malloc-arr(.id-in-header-id-v, .id-c);

   w.n(.include-c);
   // C1.stdout{"There are " .include-c " includes\n"}
   loop i = 0; .include-c; i++ {
      w.n1(.include-len-v[i]);
      w.copy(.include-str-v[i], .include-len-v[i]);
      w.n1(0);
   }

   at-bit8-c! = (.at-c + 7) >> 3;
   malloc-arr(.at-in-header-v, at-bit8-c:base);
   malloc-arr(.at-in-header-idx-v, .at-c:base);
   malloc-arr(.at-in-header-at-v, .at-c:base);

   w.n(.at-c:base);
   loop i = 0; .at-c; i++ {
      at! = .at-v[i];
      at.type.wr(w);
      if at.type == #basic {
         at.name.basic.wr(w);
      } else {
         at.parent.wr(w, false);
         at.name.id.wr(w, false);
      }
   }

   write-cvar(w, false);
   write-gvar(w, false);
   write-enum(w, false);
   write-struct(w, false);
   write-func(w, false);
   write-import(w, false);
   write-template-code(w, false);

   // if write-cp1(input-path-len, in-data, in-size, w-begin.reff, w.pos - w-begin.pos) { return 0 }
   // else { return 1 }
   
   // var out-path:char[] = C.malloc(C.strlen(lock-path) + 4 + 1);
   // C.sprintf(out-path, "%s.tmp", lock-path);
   // out-path-len! = C.strlen(out-path);
   lock-path-len! = C.strlen(lock-path);
   var tmp-path:char[256 + 16 + 10];
   C.sprintf(tmp-path, "%s-%u", lock-path, X.getpid());
   // C.memcpy(tmp-path, lock-path, lock-path-len - 1);
   // tmp-path[lock-path-len - 1] = ''t;
   // tmp-path[lock-path-len] = ''\0;
   // C1.stdout{"write " tmp-path ''\n}
   if !write-file(tmp-path, w-begin.reff, w.pos - w-begin.pos) {
      C1.stdout{"Cannot open file for writing: " tmp-path ''\n}
      C.exit(#failure);
   }
   // C1.stdout{"rename " tmp-path " -> " lock-path ''\n}
   "#ifdef _WIN32";
   X.unlink(lock-path);
   "#endif";
   C.rename(tmp-path, lock-path);

   .id-c = 0;
   .id-in-header-c = 0;
   .include-c = 0;
   .at-c = 0;
   .at-in-header-c = 0;
   .at-alias-c = 0;
   .cvar-c = 0;
   .gvar-c = 0;
   .enum-c = 0;
   .str-c = 0;
   .expr-c = 0;
   .struct-c = 0;
   .func-c = 0;
   .import-c = 0;
   .template-inst-c = 0;
   .template-code-c = 0;
   // w.reff = w-begin.reff;
   // w.n(.id-in-header-c);
   // loop j = 0; .id-in-header-c; j++ {
   //    i! = .id-in-header-id-v[j];
   //    w.n1(.id-len-v[i]);
   //    w.copy(.id-str-v[i], .id-len-v[i]);
   //    w.n1(0);
   // }
   // w.n(.include-c);
   // loop i = 0; .include-c; i++ {
   //    w.n1(.include-len-v[i]);
   //    w.copy(.include-str-v[i], .include-len-v[i]);
   //    w.n1(0);
   // }
   // w.n(.at-in-header-c);
   // loop j = 0; .at-in-header-c; j++ {
   //    i! = .at-in-header-at-v[j];
   //    at! = .at-v[i];
   //    at.type.wr(w);
   //    if at.type == #basic {
   //       at.name.basic.wr(w);
   //    } else {
   //       at.parent.wr-header(w);
   //       at.name.id.wr-header(w);
   //    }
   // }
   // write-cvar(w, true);
   // write-gvar(w, true);
   // write-enum(w, true);
   // write-struct(w, true);
   // write-func(w, true);
   // write-import(w, true);
   // write-template-code(w, true);

   // out-path[out-path-len - 5] = ''h;
   // if !write-file(out-path, w-begin.reff, w.pos - w-begin.pos) {
   //    C1.stdout{"Cannot open file for writing: " out-path ''\n}
   //    C.exit(#failure);
   // }
   // var final-path:char[512];
   // out-path[out-path-len - 5] = ''b;
   // C.memcpy(final-path, out-path, out-path-len - 4);
   // final-path[out-path-len - 4] = 0;
   // "#ifdef _WIN32";
   // X.unlink(final-path);
   // "#endif";
   // C.rename(out-path, final-path);
   // // .lock-path = null; // Do not unlink lock-path at exit
   // out-path[out-path-len - 5] = ''h;
   // C.memcpy(final-path, out-path, out-path-len - 4);
   // final-path[out-path-len - 4] = 0;
   // "#ifdef _WIN32";
   // X.unlink(final-path);
   // "#endif";
   // C.rename(out-path, final-path);
   // return 0;
}
 

}
