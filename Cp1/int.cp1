using 'c = 'libc;
using 'c1 = 'libcp1;
using 'cp1 {
enum 'expr-int[#i32, #u32, #f32, #oct, #hex, #u64, #f64]'u8;
expr-int(value'i32, type'expr-int)'expr-i {
   var e'expr-int-data;
   quick-alloc-one(e);
   e-idx! = expr-push(e.base, #int);
   e.value.ii32 = value;
   e.type = type;
   return e-idx;
}
expr-int64(value'i64, type'expr-int)'expr-i {
   var e'expr-int-data;
   quick-alloc-one(e);
   e-idx! = expr-push(e.base, #int);
   e.value.uu64 = value;
   e.type = type;
   return e-idx;
}
expr-f32(value'f32)'expr-i {
   var e'expr-int-data;
   quick-alloc-one(e);
   e-idx! = expr-push(e.base, #int);
   e.value.ff32 = value;
   e.type = #f32;
   return e-idx;
}
expr-f64(value'f64)'expr-i {
   var e'expr-int-data;
   quick-alloc-one(e);
   e-idx! = expr-push(e.base, #int);
   e.value.ff64 = value;
   e.type = #f64;
   return e-idx;
}
using 'expr-i {
   wr-int(expr'expr, w'wtr, header'bool) @case.wr() @inline {
      var e'expr-int-data = expr;
      w.n1(e.type'base);
      switch e.type {
         case #i32 {
            w.i(e.value.ii32);
         }
         case #f32 {
            w.f4(e.value.ff32);
         }
         case #f64 {
            w.f8(e.value.ff64);
         }
         case #u64 {
            w.N(e.value.uu64);
         }
         default {
            w.n(e.value.uu32);
         }
      }
   }
   rd-int(e-idx'expr-i, r'rdr) @case.rd() @inline {
      var e'expr-int-data;
      quick-alloc-one(e);
      e-idx.set(e.base, #int);
      e.type = r.n1()'expr-int;
      switch e.type {
         case #i32 {
            e.value.ii32 = r.i();
         }
         case #f32 {
            e.value.ff32 = r.f4();
         }
         case #f64 {
            e.value.ff64 = r.f8();
         }
         case #u64 {
            // .include-stdint = true;
            e.value.uu64 = r.N();
         }
         default {
            e.value.uu32 = r.n();
         }
      }
   }
   write-int(expr'expr) @case.write() @inline {
      var e'expr-int-data = expr;
      switch e.type {
         case #i32 {
            output{e.value.ii32}
         }
         case #u32 {
            output{e.value.uu32 ''u}
         }
         case #f32 {
            output{e.value.ff32 ''f}
         }
         case #f64 {
            output{e.value.ff64}
         }
         case #oct {
            output{''0 e.value.uu32, #oct}
         }
         case #hex {
            output{"0x" e.value.uu32, #hex}
         }
         case #u64 {
            output{"UINT64_C(" e.value.uu64 ")"}
         }
      }
   }
   process-int(expr'expr, ok'bool&) @case.process() @inline {
      ok = true;
   }
   type-int(expr'expr, at'at&) @case.type() @inline {
      var e'expr-int-data = expr;
      switch e.type {
         case #i32 {
            at = basic-type(#i32);
         }
         case #f32 {
            at = basic-type(#f32);
         }
         case #f64 {
            at = basic-type(#f64);
         }
         case #u64 {
            at = basic-type(#u64);
         }
         default {
            at = basic-type(#u32);
         }
      }
   }
   value-int(le'this, reff'i32, paren'bool, v'value, ok'bool&) @case.value() @inline {
      var e'expr-int-data = le.ptr();
      switch e.type {
         case #i32 {
            v.type = basic-type(#i32);
         }
         case #f32 {
            v.type = basic-type(#f32);
         }
         case #f64 {
            v.type = basic-type(#f64);
         }
         case #u64 {
            v.type = basic-type(#u64);
         }
         default {
            v.type = basic-type(#u32);
         }
      }
      v.info.init();
      v.info.array-c = 0;
      v.info.ref-v[0] = ''\0;
      v.info.star-c = 0;
      v.reff = 1;
      v.paren = false;
      ok = true;
   }
}
 

}
