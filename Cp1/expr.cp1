using 'c = 'libc;
using 'c1 = 'libcp1;
using 'cp1 {
using 'stmt-space {
   wr-expr(stmt'stmt, w'wtr, header'bool) @case.wr() @inline {
      var s'stmt-expr = stmt;
      s.expr.wr(w, header);
   }
   rd-expr(space'stmt-space, r'rdr) @case.rd() @inline {
      var s'stmt-expr;
      quick-alloc-one(s);
      s.expr.rd(r);
      var e = s.expr.ptr();
      if e.type == #assign {
         var assign'expr-assign = e;
         assign.is-stmt = true;
      }
      space.stmt-push(s.base, .ctx-begin-row, .ctx-begin-col, .ctx-end-row, .ctx-end-col, #expr);
   }
}
using 'stmt {
   write-expr(stmt'stmt) @case.write() @inline {
      var s'stmt-expr = stmt;
      expr! = s.expr.ptr();
      if expr.type == #str {
         var e'expr-str = expr;
         n! = e.first;
         loop {
            output-bytes(n.buf, n.len);
            n = n.next;
            if n == null { break }
         }
         output{''\n}
         return;
      }
      s.expr.write();
      output{";\n"}
   }
   process-expr(stmt'stmt, ok'bool&) @case.process() @inline {
      var s'stmt-expr = stmt;
      s-expr! = s.expr;
      if !s-expr.process() {
         return;
      }
      type! = s-expr.ptr().type;
      if (type == #method) || (type == #func) {
         left-type! = s-expr.type();
         if left-type != #nil {
            left-type-ptr! = left-type.ptr();
            if left-type-ptr.def == #enum {
               en! = left-type-ptr.decl.enumm.ptr();
               f-idx! = en.overload-statement;
               if f-idx != #nil {
                  f! = f-idx.ptr();
                  e-method! = 'expr-i.alloc();
                  var group-v'u8[1];
                  group-v[0] = 0;
                  'expr-i.set-method(e-method, s.expr, f.decl.name, 1, group-v, 0, null);
                  s.expr = e-method;
                  if !s.expr.process() {
                     return;
                  }
                  // C1.stdout{.ctx-func.file '': s.base.begin-row '': s.base.begin-col ": overload-statement used\n"}
                  ok = true;
                  return;
               }
            }
         }
      }
      ok = true;
   }
}
enum 'expr-type[
   #nil, #call-method, #lvar, #gvar, #math, #assign, #bools,
   #func, #metafunc, #method, #metamethod, #fvar, #soa-field, #int, #cvar, #str, #index, #unary,
   #compare, #bool, #null, #cast-fast, #ref, #char, #size-of-type,
   ]'u8 {
   wr(e'this, w'wtr) @inline {
      w.n1(e'base);
   }
   rd(e'this&, r'rdr) @inline {
      e = r.n1()'expr-type;
   }
   cp1-name(e'this)'char[] @cp1-name;
}
#debug-rd-wr'bool = true;
enum 'expr-i[#nil = -1, #0, #1]'i32 {
   set(e'this, expr'expr, type'expr-type) @inline {
      .expr-v[e] = expr;
      expr.type = type;
   }
   ptr(e'this)'expr @inline {
      return .expr-v[e];
   }
   write-value(e'this, v'value)'bool {
      expr! = e.ptr();
      reff! = v.reff;
      // C1.stdout{"write-value v.ref = " ref ''\n}
      if v.paren {
         if reff <= 0 {
            output-bytes("(&", 2);
         } else {
            output-bytes("(*******************************", reff);
         }
      } else {
         if reff <= 0 {
            output-bytes("&", 1);
         } elif reff > 1 {
            output-bytes("*******************************", reff - 1);
         }
      }

      if expr.type == #cast-fast {
         var e'expr-cast-fast = expr;
         e.write-value(v);
      } else {
         e.write();
      }

      if v.paren {
         output-bytes(")", 1);
      }
      return true;
   }
   value(e'this, reff'i32, paren'bool, v'value)'bool {
      if !e.process() { return false }
      expr! = e.ptr();
      ok! = false;
      switch.value(e, reff, paren, v, ok) expr.type {
         default {
            'c1.stdout{.ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": value() not implemented for #" expr.type.cp1-name() ''\n}
         }
      }
      return ok;
   }
   type(e'this)'at {
      if !e.process() { return #nil }
      expr! = e.ptr();
      at! = 'at#nil;
      switch.type(expr, at) expr.type {
         default {
            'c1.stdout{.ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": type() not implemented for #" expr.type.cp1-name() ''\n}
         }
      }
      return at;
   }
   try-deduce(e-idx'this, at'at) {
      expr! = e-idx.ptr();
      switch.try-deduce(expr, at) expr.type {
      }
   }
   wr(e'this, w'wtr, header'bool) {
      if #debug-rd-wr {
         w.n1(255);
      }
      if e == #nil {
         'expr-type#nil.wr(w);
      } else {
         expr! = e.ptr();
         expr.type.wr(w);
         switch.wr(expr, w, header) expr.type {
            default {
               'c1.stdout{"wr() was not implemented in expression #" expr.type.cp1-name() ''\n}
               'c.exit(#failure);
            }
         }
      }
      if #debug-rd-wr {
         w.n1(255);
      }
   }
   alloc()'expr-i {
      e-idx! = (.expr-c++)'expr-i;
      if .expr-cap <= .expr-c {
         old-cap! = .expr-cap;
         grow(.expr-cap, .expr-c);
         realloc(.expr-v, .expr-cap, old-cap);
         realloc(.expr-is-processed, (.expr-cap + 7) >> 3, (old-cap + 7) >> 3);
      }
      return e-idx;
   }
   rd(e'this&, r'rdr) {
      if #debug-rd-wr {
         if r.n1() != 255 {
            'c1.stdout{"Error reading expr\n"}
            'c.out.flush();
            'c.exit(#failure);
         }
      }
      'expr-type.rd(type!, r);
      if type == #nil {
         e = #nil;
      } else {
         e-idx! = alloc();
         e = e-idx;
         switch.rd(e-idx, r) type {
            default {
               'c1.stdout{"rd() was not implemented in expression #" type.cp1-name() ''\n}
               'c.exit(#failure);
            }
         }
      }
      if #debug-rd-wr {
         if r.n1() != 255 {
            'c1.stdout{"Error reading expr\n"}
            'c.out.flush();
            'c.exit(#failure);
         }
      }
   }
   process(e'this)'bool {
      if e == #nil {
         'c1.stdout{.ctx-func.file '': .ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": Processed a nil expression\n"}
         return false;
      }
      num! = e'u32;
      n3! = num >> 3;
      n17! = 1 << (num & 7);
      if (.expr-is-processed[n3] & n17) != 0 { return true }
      .expr-is-processed[n3] |= n17;
      expr! = e.ptr();
      // if expr.flags & #processed { return true }
      // expr.flags |= #processed;
      ok! = false;
      switch.process(expr, ok) expr.type {
         default {
            'c1.stdout{.ctx-func.file '': .ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": process() not implemented for expression #" expr.type.cp1-name() ''\n}
            return false;
         }
      }
      if !ok {
         'c1.stdout{.ctx-func.file '': .ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": Processing of expression #" expr.type.cp1-name() " failed\n"}
      }
      return ok;
   }
   write(e'this) {
      expr! = e.ptr();
      switch.write(expr) expr.type {
         default {
            'c1.stdout{.ctx-func.file '': .ctx-begin-row '': .ctx-begin-col " - " .ctx-end-row '': .ctx-end-col ": write() not implemented in expression #" expr.type.cp1-name() ''\n}
         }
      }
   }
}
enum 'expr-flags[#0, #processed = 1]'u8;
struct 'expr[
   type'expr-type,
   flags'expr-flags,
   ] {
   write(e'this, out'c'file) {
      switch e.type {
         case #call {
            var e2'expr-call = e;
            e2.write(out);
         }
      }
   }
}
enum 'basic-type-id[
   #root, #relative,
   #ref, #bool, #char, #intc,
   #i8, #u8,
   #i16, #u16,
   #i32, #u32,
   #i64, #u64,
   #isz, #usz,
   #f32, #f64,
   #count]'u8 {
   wr(e'this, w'wtr) @inline {
      w.n1(e'base);
   }
   rd(e'this&, r'rdr) @inline {
      e = r.n1()'basic-type-id;
   }
// write(e:this, out:C.File) {
//    switch e {
//       case #ref {
//         output{"void*"}
//       }
//       case #i32 {
//         output{"int"}
//       }
//       case #u32 {
//         output{"unsigned int"}
//       }
//       case #float {
//         output{"float"}
//       }
//       case #bool {
//         output{"bool"}
//       }
//    }
// }
   cp1-name(e'this)'char[] @cp1-name;
}
struct 'expr-char[
   base'expr.,
   value'char,
];
struct 'expr-bool[
   base'expr.,
   value'bool,
];
struct 'expr-null[
   base'expr.,
];
struct 'expr-str-node[
   next'expr-str-node,
   macro'bool,
   len'u32,
   buf'char[0],
];
struct 'expr-str[
   base'expr.,
   node-c'i32,
   first'expr-str-node,
   last'expr-str-node,
] {
   len(s'this)'u32 {
      len! = 0'u32;
      n! = s.first;
      loop {
         len += n.len;
         n = n.next;
         if n == null {
            break;
         }
      }
      return len;
   }
}
var expr-c'i32;
var expr-cap'i32;
var expr-v'expr[];
expr-push(e'expr, type'expr-type)'expr-i {
   e.type = type;
   e-idx! = .expr-c++;
   if .expr-cap <= .expr-c {
      old-cap! = .expr-cap;
      grow(.expr-cap, .expr-c);
      realloc(.expr-v, .expr-cap, old-cap);
   }
   .expr-v[e-idx] = e;
   return e-idx;
}
union 'expr-int-value[
   ii32'i32,
   uu32'u32,
   ff32'f32,
   ff64'f64,
   uu64'u64,
];
struct 'expr-int-data[
   base'expr.,
   value'expr-int-value.,
   type'expr-int,
];
struct 'expr-size-of-type[
   base'expr.,
   type'at,
];
 

}
