using 'c = 'libc;
using 'c1 = 'libcp1;
using 'x = 'posix;
using 'w = 'windows;
include "file.cp1.h" {
   using 'windows {
      enum 'handle[#null, #invalid @no-decl(INVALID_HANDLE_VALUE)]'usz @no-decl(HANDLE);
      CreateFileA(path'char[], access'w'create-file-access, share-mode'w'create-file-share-mode, security-attributes'ref, creation-disposition'w'create-file-creation-disposition, flags'w'create-file-flags, template-file'handle)'handle @no-decl @real-name;
      enum 'create-file-access[#read @no-decl(GENERIC_READ), #write @no-decl(GENERIC_WRITE)]'u32;
      enum 'create-file-share-mode[#0, #read @no-decl(FILE_SHARE_READ)]'u32;
      enum 'create-file-creation-disposition[#open-existing @no-decl(OPEN_EXISTING), #create-always @no-decl(CREATE_ALWAYS)]'u32;
      enum 'create-file-flags[#normal @no-decl(FILE_ATTRIBUTE_NORMAL)]'u32;
      GetFileSizeEx(h'handle, i'w'large-integer)'bool @no-decl @real-name;
      union 'large-integer[
         quadPart'u64 @real-name('quad-part),
      ] @no-decl(LARGE_INTEGER);
      CloseHandle(h'handle)'bool @no-decl @real-name;
      ReadFile(h'handle, buf'ref, size'u32, bytes-read'u32&, overlapped'ref)'bool @no-decl @real-name;
      WriteFile(h'handle, buf'ref, size'u32, bytes-read'u32&, overlapped'ref)'bool @no-decl @real-name;
   }
}
using 'cp1 {
   read-file(path'char[], out-size'usz&)'ref @inline {
      return read-file(path, 0, 0, -1, out-size);
   }
   read-file(path'char[], add-before'i32, add-after'i32, max-size'usz, out-size'usz&)'ref {
      "#ifdef _WIN32";
      if true {
         h! = 'w.CreateFileA(path, #read, #read, null, #open-existing, #normal, #null);
         if h == #invalid {
            return null;
         }
         var f-size;
         if !'w.GetFileSizeEx(h, f-size) {
            'w.CloseHandle(h);
            return null;
         }
         size! = f-size.quadPart;
         if max-size != 0 {
            if size'usz > max-size {
               size =  max-size;
            }
         }
         var buf'u8[];
         'c.malloc-arr(buf, add-before + size + add-after);
         var bytes-read;
         if !'w.ReadFile(h, &buf[add-before], size, bytes-read, null) || (bytes-read != size) {
            'c.free(buf);
            'w.CloseHandle(h);
            return null;
         }
         'w.CloseHandle(h);
         out-size = size;
         return buf;
      }
      "#else";
      if true {
         var fd;
         if !'x'fd.open(fd, path, #rdonly) {
            return null;
         }
         size! = fd.seek(0, #end);
         if size == -1 {
            fd.close();
            return null;
         }
         if max-size != 0 {
            if size'usz > max-size {
               size =  max-size;
            }
         }
         if fd.seek(0, #set) == -1 {
            fd.close();
            return null;
         }
         var buf'u8[];
         // C1.stdout{"malloc " (add-before + size + add-after):u32 "\n"}
         'c.malloc-arr(buf, add-before + size + add-after);
         if fd.read(&buf[add-before], size) != size {
            'c.free(buf);
            fd.close();
            return null;
         }
         fd.close();
         out-size = size;
         return buf;
      }
      "#endif";
   }
   write-file(path'char[], data'ref, size'usz)'bool {
      "#ifdef _WIN32";
      if true {
         h! = 'w.CreateFileA(path, #write, #0, null, #create-always, #normal, #null);
         if h == #invalid {
            return false;
         }
         var bytes-written;
         if !'w.WriteFile(h, data, size, bytes-written, null) || (bytes-written != size) {
            'w.CloseHandle(h);
            return false;
         }
         'w.CloseHandle(h);
         return true;
      }
      "#else";
      if true {
         var fd;
         if !'x'fd.open(fd, path, #create | #truncate | #wronly, 0o644) {
            return false;
         }
         if fd.write(data, size) != size {
            fd.close();
            return false;
         }
         fd.close();
         return true;
      }
      "#endif";
   }
   var output-data'char[] @real-name(output_data);
   var output-cap'u32;
   var output-len'u32 @real-name(output_len);
   struct 'output[reserve'u32] {
      output-reserve-cstr(o'this, str'char[], len'u32, p'output-str) {
         p.reserve(str, len, o);
      }
      output-reserve-end(o'this) {
         output-reserve(o.reserve);
      }
      output-end(o'this) {
      }
   }
   enum 'output-int-type[#oct, #hex]'u8;
   output(o'output) @meta(output-reserve output end) @inline {
      o.reserve = 0;
   }
   output-reserve(len'u32) {
      space! = .output-cap - .output-len;
      if space < len {
         .output-cap += .output-cap;
         space = .output-cap - .output-len;
         loop space < len {
            .output-cap += .output-cap;
            space = .output-cap - .output-len;
         }
         .output-cap += .output-cap;
         'c.realloc-arr(.output-data, .output-cap);
      }
   }
   output-u32(val'u32) {
      output-reserve(10);
      output-u32-nr(val);
   }
   output-u32-nr(val'u32) {
      if val == 0 {
         .output-data[.output-len++] = ''0;
      } else {
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            data[digits++] = (val % 10) + ''0;
            val /= 10;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      }
   }
   output-o32(val'u32) {
      output-reserve(11);
      output-o32-nr(val'u32);
   }
   output-o32-nr(val'u32) {
      if val == 0 {
         .output-data[.output-len++] = ''0;
      } else {
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            data[digits++] = (val % 8) + ''0;
            val /= 8;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      }
   }
   output-x32(val'u32) {
      output-reserve(8);
      output-x32-nr(val);
   }
   output-x32-nr(val'u32) {
      if val == 0 {
         .output-data[.output-len++] = ''0;
      } else {
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            n! = val % 16;
            if n < 10 {
               data[digits++] = n + ''0;
            } else {
               data[digits++] = (n - 10) + ''a;
            }
            val /= 16;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      }
   }
   output-f32(val'f32) {
      output-reserve(47);
      output-f32-nr(val);
   }
   output-f32-nr(val'f32) {
      .output-len += 'c.sprintf(&.output-data[.output-len], "%f", val);
   }
   output-i32(val'i32) {
      output-reserve(11);
      output-i32-nr(val);
   }
   output-i32-nr(val'i32) {
      if val == 0 {
         .output-data[.output-len++] = ''0;
      } elif val < 0 {
         val = -val;
         .output-data[.output-len++] = ''-;
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            data[digits++] = (val % 10) + ''0;
            val /= 10;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      } else {
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            data[digits++] = (val % 10) + ''0;
            val /= 10;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      }
   }
   output-u64(val'i64) {
      output-reserve(20);
      output-u64-nr(val);
   }
   output-u64-nr(val'i64) {
      if val == 0 {
         .output-data[.output-len++] = ''0;
      } else {
         // integer to string, count the digits
         var data'char[];
         data = &.output-data[.output-len];
         digits! = 0;
         loop {
            data[digits++] = (val % 10) + ''0;
            val /= 10;
            if val == 0 { break }
         }
         // reverse the string
         start! = 0;
         end! = digits - 1;
         loop start < end {
            tmp! = data[start];
            data[start] = data[end];
            data[end] = tmp;
            start++;
            end--;
         }
         .output-len += digits;
      }
   }
   output-bytes(str'char[], len'u32) {
      output-reserve(len);
      output-bytes-nr(str, len);
   }
   output-bytes-nr(str'char[], len'u32) {
      'c.memcpy(&.output-data[.output-len], str, len);
      .output-len += len;
   }
   struct 'output-u32[val'u32] {
      reserve(s'this, val'u32, so'output) {
         s.val = val;
         so.reserve += 10;
      }
      output(s'this, so'output) @inline {
         output-u32-nr(s.val);
      }
   }
   struct 'output-u32-radix[val'u32, type'output-int-type] {
      reserve(s'this, val'u32, type'output-int-type, so'output) {
         s.val = val;
         s.type = type;
         switch type {
            case #oct {
               so.reserve += 11;
            }
            case #hex {
               so.reserve += 8;
            }
         }
      }
      output(s'this, so'output) @inline {
         switch s.type {
            case #oct {
               output-o32-nr(s.val);
            }
            case #hex {
               output-x32-nr(s.val);
            }
         }
      }
   }
   struct 'output-u64[val'u64] {
      reserve(s'this, val'u64, so'output) {
         s.val = val;
         so.reserve += 20;
      }
      output(s'this, so'output) @inline {
         output-u64-nr(s.val);
      }
   }
   struct 'output-i32[val'i32] {
      reserve(s'this, val'i32, so'output) {
         s.val = val;
         so.reserve += 11;
      }
      output(s'this, so'output) @inline {
         output-i32-nr(s.val);
      }
   }
   struct 'output-str[str'char @const[], len'u32] {
      reserve(s'this, str'char @const[], len'u32, so'output) {
         s.str = str;
         s.len = len;
         so.reserve += len;
      }
      output(s'this, so'output) @inline {
         output-bytes-nr(s.str, s.len);
      }
   }
   struct 'output-bool[val'bool] {
      reserve(s'this, val'bool, so'output) {
         s.val = val;
         if val {
            so.reserve += 4;
         } else {
            so.reserve += 5;
         }
      }
      output(val'this, so'output) @inline {
         'c1.output-bool-nr(val);
      }
   }
   struct 'output-char[val'char] {
      reserve(s'this, val'char, so'output) {
         s.val = val;
         so.reserve++;
      }
      output(s'this, so'output) @inline {
         .output-data[.output-len++] = s.val;
      }
   }
   struct 'output-float[val'f32] {
      reserve(s'this, val'f32, so'output) @inline {
         s.val = val;
         so.reserve += 64;
      }
      output(s'this, so'output) @inline {
         .output-len += 'c.sprintf(&.output-data[.output-len], "%.9f", s.val);
      }
   }
   struct 'output-float64[val'f64] {
      reserve(s'this, val'f64, so'output) @inline {
         s.val = val;
         so.reserve += 128;
      }
      output(s'this, so'output) @inline {
         .output-len += 'c.sprintf(&.output-data[.output-len], "%.17f", s.val);
      }
   }
}
using 'bool {
   output-reserve(val'this, so'cp1'output, p'output-bool) @inline {
      p.reserve(val, so);
   }
}
using 'f32 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-float) @inline {
      p.reserve(val, so);
   }
}
using 'f64 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-float64) @inline {
      p.reserve(val, so);
   }
}
using 'i32 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-i32) @inline {
      p.reserve(val, so);
   }
}
using 'i16 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-i32) @inline {
      p.reserve(val, so);
   }
}
using 'i8 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-i32) @inline {
      p.reserve(val, so);
   }
}
using 'usz {
   output-reserve(val'this, so'cp1'output, p'cp1'output-u64) @inline {
      p.reserve(val, so);
   }
}
using 'u64 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-u64) @inline {
      p.reserve(val, so);
   }
}
using 'u32 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-u32) @inline {
      p.reserve(val, so);
   }
   output-reserve(val'this, type'cp1'output-int-type, so'cp1'output, p'cp1'output-u32-radix) @inline {
      p.reserve(val, type, so);
   }
}
using 'u16 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-u32) @inline {
      p.reserve(val, so);
   }
}
using 'u8 {
   output-reserve(val'this, so'cp1'output, p'cp1'output-u32) @inline {
      p.reserve(val, so);
   }
}
using 'char {
   output-reserve(val'this, so'cp1'output, p'cp1'output-char) @inline {
      p.reserve(val, so);
   }
   output-reserve-arr(str'this @const[], so'cp1'output, p'cp1'output-str) @inline {
      p.reserve(str, 'c.strlen(str), so);
   }
   output-reserve-arr(str'this @const[], len'u32, so'cp1'output, p'cp1'output-str) @inline {
      p.reserve(str, len, so);
   }
}
