using 'c = 'libc;
using 'c1 = 'libcp1;
using 'cp1 {
enum 'lvar[#nil = -1, #0]'i32 {
   rd(l'this&, r'rdr) @inline {
      l = (r.n() - 1)'lvar;
   }
   wr(l'this, w'wtr) @inline {
      w.n(l'base + 1);
   }
   process(l'this)'bool @inline {
      var lvar = l.ptr();
      if (lvar.flags & #processed) != #0 { return true }
      lvar.flags |= #processed;
      var at-i = lvar.decl.type;
      if at-i == #nil {
         if lvar.decl.name == .id-blank {
            // let it be, it is a compile-time generated variable that wasn't used
            return true;
         }
         // if (lvar.flags & #set-expr) != #0 {
            // if !lvar.set-expr.value(1, false, v!!) { return false }
            // lvar.decl.type = v.type;
            // lvar.decl.type-info.init();
            // lvar.decl.type-info.copy-from(v.info);
         // } else {
            'c1.stdout{.ctx-func.file '': lvar.row '': lvar.col ": local variable '" lvar.decl.name "' doesn't have a type or a value\n"}
            return false;
         // }
         // return true;
      }
      return lvar.decl.process(.ctx-func.file, lvar.row, lvar.col, .ctx-func.at);
   }
}
enum 'lvar-flags[
   #0,
   #set-expr = 1,
   #processed = 2,
   #all = 0xff,
]'u8 {
   rd(f'this&, r'rdr) @inline {
      f = r.n1()'lvar-flags;
   }
   wr(f'this, w'wtr) @inline {
      w.n1(f'base);
   }
}
struct 'lvar-data[
   row'u32,
   col'u32,
   decl'decl-var-data.,
   flags'lvar-flags,
   // set-expr:ExprI,
];
expr-lvar(name'id, decl'u8, row'u32, col'u32)'expr-i {
   if .decl-func-ctx-space == null {
      'c1.stdout{.input-path '': row '': row ": Use of local variables are now allowed here\n"}
      'c.exit(#failure);
   }
   if decl == 0 {
      var space = .decl-func-ctx-space;
      loop {
         var v = space.lvar-v;
         var found = 'lvar#nil;
         loop i = 0; space.lvar-c; i++ {
            var lvar = v[i];
            if lvar.name() == name {
               found = lvar;
               break;
            }
         }
         if found != #nil {
            var e'expr-lvar;
            quick-alloc-one(e);
            var e-idx = expr-push(e.base, #lvar);
            e.lvar = found;
            return e-idx;
         }
         space = space.parent;
         if space == null { break }
      }
      'c1.stdout{.input-path '': row '': col ": local variable '" name "' was not found\n"}
      'c.exit(#failure);
      return #nil;
   } else {
      var space = .decl-func-ctx-space;
      var e'expr-lvar;
      quick-alloc-one(e);
      var e-idx = expr-push(e.base, #lvar);
      e.lvar = space.lvar-new(name, row, col);
      var lvar = e.lvar.ptr();
      .decl-var.name = name;
      if decl == 1 {
         lvar.flags |= #set-expr;
         e.decl = true;
      }
      lvar.decl.copy-from(.decl-var);
      return e-idx;
   }
}
using 'expr-i {
   write-lvar(expr'expr) @case.write() @inline {
      var e'expr-lvar = expr;
      e.lvar.ptr().decl.write-lvar(e.lvar);
   }
   type-lvar(expr'expr, at'at&) @case.type() @inline {
      var e'expr-lvar = expr;
      var lvar = e.lvar.ptr();
      at = lvar.decl.type;
   }
   value-lvar(e'this, ref'i8, paren'bool, v'value, ok'bool&) @case.value() @inline {
      var expr'expr-lvar = e.ptr();
      var lvar = expr.lvar.ptr();
      v.set(ref, paren, lvar.decl.type, lvar.decl.type-info);
      if v.ref == 1 {
         v.paren = false;
      }
      ok = true;
   }
   wr-lvar(expr'expr, w'wtr, header'bool) @case.wr() @inline {
      var e'expr-lvar = expr;
      e.lvar.wr(w);
      w.b(e.decl);
   }
   rd-lvar(e-idx'expr-i, r'rdr) @case.rd() @inline {
      var e'expr-lvar;
      quick-alloc-one(e);
      e-idx.set(e.base, #lvar);
      e.lvar.rd(r);
      e.decl = r.b();
   }
   process-lvar(expr'expr, ok'bool&) @case.process() @inline {
      var e'expr-lvar = expr;
      if !e.lvar.process() { return }
      ok = true;
   }
}
 

}
