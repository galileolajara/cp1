import "LibCp1/stdout.cp1";
import "LibC/stdio.cp1";
import "LibC/stdlib.cp1";
import "LibC/string.cp1";
import "Posix/fcntl.cp1";
import "Posix/unistd.cp1";
import "Posix/stat.cp1";
using C = LibC;
using C1 = LibCp1;
using X = Posix;
using Cp1 = Cp1;
var atexit-rm-v:char[][];
var atexit-rm-cap:u32;
var atexit-rm-c:u32;
var include-dir:char[512 + 8];
var include-dir-len:u16;
// include-dir! = "/opt/cp1/include";
// include-dir-len! = C.strlen(include-dir);
print-commands(bin:char[]) {
   C1.stdout{
   "Usage: " bin " [command] [options]\n"
   "Commands:\n"
   "  c     Build a C file.\n"
   "  run      Compile and run the cp1 codes.\n"}
}
print-c-usage(bin:char[]) {
   C1.stdout{"Usage: " bin " c [output.c] [cp1 file/s...]\n"}
}
print-run-usage(bin:char[]) {
   C1.stdout{"Usage: " bin " run [cp1 file/s...]\n"}
}
get-compile(bin:char[]) {
   path! = C.strdup(C.getenv("PATH"));
   "#ifdef _WIN32";
   loop i = 0; ; i++ {
      if path[i] == ''\0 {
         break;
      } elif path[i] == ''\\ {
         path[i] = ''/;
      }
   }
   "#endif";
   var found;
   "#ifdef _WIN32";
   found = C.strtok(path, ";");
   "#else";
   found = C.strtok(path, ":");
   "#endif";
   loop found != null {
      // C1.stdout{"- " found ''\n}
      var fd, compile:char[512];
      "#ifdef _WIN32";
      C.sprintf(compile, "%s/tcc.exe", found);
      "#else";
      C.sprintf(compile, "%s/tcc", found);
      "#endif";
      fd = X.open(compile, #rdonly);
      if fd != #nil {
         Cp1.output{"rule c\n"}
         Cp1.output{" command = tcc -I. $in -o $out\n"}
         fd.close();
         C.free(path);
         return;
      }
      "#ifdef _WIN32";
      C.sprintf(compile, "%s/clang.exe", found);
      "#else";
      C.sprintf(compile, "%s/clang", found);
      "#endif";
      fd = X.open(compile, #rdonly);
      if fd != #nil {
         Cp1.output{"rule c\n"}
         Cp1.output{" command = clang -I. $in -o $out\n"}
         fd.close();
         C.free(path);
         return;
      }
      "#ifdef _WIN32";
      C.sprintf(compile, "%s/gcc.exe", found);
      "#else";
      C.sprintf(compile, "%s/gcc", found);
      "#endif";
      fd = X.open(compile, #rdonly);
      if fd != #nil {
         Cp1.output{"rule c\n"}
         Cp1.output{" command = gcc -I. $in -o $out\n"}
         fd.close();
         C.free(path);
         return;
      }
      "#ifdef _WIN32";
      found = C.strtok(null, ";");
      "#else";
      found = C.strtok(null, ":");
      "#endif";
   }
   C1.stdout{"Cannot execute '" bin " run' because the required compile was not found: tcc clang or gcc\n"}
   C.exit(#failure);
}
enum Cmd[#c, #run]:u8;
print-usage(bin:char[], cmd:Cmd) {
   switch cmd {
      case #c {
         print-c-usage(bin);
      }
      case #run {
         print-run-usage(bin);
      }
   }
}
var included-v:char[][];
var included-len-v:u32[];
var included-cap:i32;
var included-c:i32;
var cp1-path-v:char[][];
var cp1-path-len-v:u32[];
var cp1-path-real-v:char[][];
var cp1-path-real-len-v:u32[];
var cp1-path-cap:i32;
var cp1-path-c:i32;
cp1-path-add(cp1-path-real:char[], cp1-path-real-len:i32, cp1-path:char[], cp1-path-len:i32) {
   // C1.stdout{"adding " cp1-path-real " as " cp1-path ''\n}
   i! = .cp1-path-c++;
   if .cp1-path-cap < .cp1-path-c {
      .cp1-path-cap = (.cp1-path-cap << 1) + 8;
      .cp1-path-v = C.realloc(.cp1-path-v, .cp1-path-cap * usz[usz]);
      .cp1-path-len-v = C.realloc(.cp1-path-len-v, .cp1-path-cap * u32[usz]);
      .cp1-path-real-v = C.realloc(.cp1-path-real-v, .cp1-path-cap * usz[usz]);
      .cp1-path-real-len-v = C.realloc(.cp1-path-real-len-v, .cp1-path-cap * u32[usz]);
   }
   .cp1-path-v[i] = cp1-path;
   .cp1-path-len-v[i] = cp1-path-len;
   .cp1-path-real-v[i] = cp1-path-real;
   .cp1-path-real-len-v[i] = cp1-path-real-len;
}
var cmd-preprocess:char[512];
cp1-path-input(cp1-path:char[], cp1-path-len:i32, bin:char[], cmd:Cmd):bool {
   loop i = 0; .cp1-path-c; i++ {
      if C.memcmp(.cp1-path-v[i], cp1-path, cp1-path-len) == 0 {
         return true;
      }
   }
   var data:char[];
   data = Cp1.read-file(cp1-path, len!);
   if data == null {
      C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') cannot be opened for reading\n"}
      return false;
   }
   if !(&&, len > 0, data[len - 1] == ''\n) {
      C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must end a new line\n"}
      return false;
   }
   if data[len - 2] == ''\r {
      C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must have Unix line endings '\\n' instead of Windows line endings '\\r\\n'\n"}
      return false;
   }
   // Detect if we need to preprocess the file
   pos! = 0:u32;
   line! = 0:u32;
   preprocess! = false;
   loop pos < len {
      line++;
      start! = pos;
      loop {
         if data[pos] == ''\n {
            break;
         }
         if data[pos] == ''\t {
            C1.stdout{cp1-path '': line '': (pos - start) + 1 ": Error, use of tabs is discouraged, please use spaces instead\n"}
            C.exit(#failure);
         }
         pos++;
      }
      first-char! = start;
      loop {
         if data[first-char] == ''  {
            first-char++;
            continue;
         } else {
            break;
         }
      }
      if (&&, data[first-char] == ''#, data[first-char + 1] == ''i, data[first-char + 2] == ''f, (||, data[first-char + 3] == ''(, (&&, data[first-char + 3] == ''!, data[first-char + 4] == ''())) {
         preprocess = true;
         break;
      }
      pos++;
   }
   // Process consecutive lines that begins with '#'
   if preprocess {
      C.free(data);

      var tmp-path:char[17];
      C.memcpy(tmp-path, "cp1-tmp-XXXXXXXX", 17);
      tmp-fd! = X.mkstemp(tmp-path);
      if tmp-fd == #nil {
         C1.stdout{"Error, cannot create a temporary file at the current folder\n"}
         return false;
      }
      tmp-fd.close();

      C.sprintf(.cmd-preprocess, "%s-preprocess %.*s %s\n", bin, cp1-path-len, cp1-path, tmp-path);
      // C1.stdout{"Running preprocessor: " .cmd-preprocess ''\n}
      C.out.flush();
      if C.system(.cmd-preprocess) != 0 {
         return false;
      }
      tmp-path-dup! = C.malloc(17);
      C.memcpy(tmp-path-dup, tmp-path, 17);
      atexit-rm(tmp-path-dup);
      cp1-path-add(tmp-path-dup, 16, cp1-path, cp1-path-len);

      data = Cp1.read-file(tmp-path-dup, len);
      if data == null {
         C1.stdout{"Error, cannot open file for reading: " tmp-path ''\n}
         return false;
      }
   } else {
      cp1-path-add(cp1-path, cp1-path-len, cp1-path, cp1-path-len);
   }
   pos = 0;
   line = 0;
   loop pos < len {
      line++;
      start! = pos;
      loop {
         if data[pos] == ''\n {
            break;
         }
         pos++;
      }
      first-char! = start;
      loop {
         if data[first-char] == ''  {
            first-char++;
            continue;
         } else {
            break;
         }
      }
      if (&&,
         data[first-char] == ''#,
         data[first-char + 1] == ''i,
         data[first-char + 2] == ''m,
         data[first-char + 3] == ''p,
         data[first-char + 4] == ''o,
         data[first-char + 5] == ''r,
         data[first-char + 6] == ''t,
         data[first-char + 7] == '' ,
         ) {
         start += 8;
         begin! = -1;
         loop j = start; pos - start; j++ {
            if data[j] == ''" {
               begin = j;
               break;
            } elif data[j] == ''  {
               // Ok
            } else {
               C1.stdout{cp1-path '': line ": Invalid character '" data[j] "' found in #include <...>\n"}
               return false;
            }
         }
         if begin != -1 {
            start = begin + 1;
            end! = -1;
            loop j = start; pos - start; j++ {
               if data[j] == ''" {
                  end = j;
                  break;
               }
            }
            if end == -1 {
               C1.stdout{cp1-path '': line ": #import \"...\" must end with '\"'\n"}
               return false;
            }
            var import:char[] = &data[start];
            import-path-len! = end - start;
            if (&&, import-path-len >= 4, import[import-path-len - 4] == ''., import[import-path-len - 3] == ''c, import[import-path-len - 2] == ''p, import[import-path-len - 1] == ''1) {
               C1.stdout{cp1-path '': line ": #import \"" import, import-path-len "\" doesn't need a '.cp1' suffix\n"}
               return false;
            }
            if import[0] == ''/ {
               C1.stdout{cp1-path '': line ": #import \"" import, import-path-len "\" must be a relative path, '/' was detected at the beginning of file path\n"}
               return false;
            }
            loop j = 0; import-path-len; j++ {
               if import[j] == ''\\ {
                  C1.stdout{cp1-path '': line ": #import \"" import, import-path-len "\" must not contain backslashes '\\', please use forward slashes '/' instead\n"}
                  return false;
               }
            }
            loop j = 0; import-path-len - 1; j++ {
               if (&&, import[j] == ''., import[j + 1] == ''/) {
                  C1.stdout{cp1-path '': line ": #import \"" import, import-path-len "\" must not contain './'\n"}
                  return false;
               }
            }
            var import-path:char[] = C.malloc(import-path-len + 5);
            C.memcpy(import-path, import, import-path-len);
            import-path[import-path-len++] = ''.;
            import-path[import-path-len++] = ''c;
            import-path[import-path-len++] = ''p;
            import-path[import-path-len++] = ''1;
            import-path[import-path-len] = ''\0;
            // C1.stdout{"importing " import-path ''\n}
            if !cp1-path-input(import-path, import-path-len, bin, cmd) {
               C1.stdout{"Error from #import \"" import, import-path-len - 4 "\" at file '" cp1-path "' line " line ''\n}
               return false;
            }
         }
         pos++;
         continue;
      } elif (&&,
         data[first-char] == ''#,
         data[first-char + 1] == ''i,
         data[first-char + 2] == ''n,
         data[first-char + 3] == ''c,
         data[first-char + 4] == ''l,
         data[first-char + 5] == ''u,
         data[first-char + 6] == ''d,
         data[first-char + 7] == ''e,
         data[first-char + 8] == '' ,
         ) {
         start += 9;
         begin! = -1;
         loop j = start; pos - start; j++ {
            if data[j] == ''< {
               begin = j;
               break;
            } elif data[j] == ''  {
               // Ok
            } else {
               C1.stdout{cp1-path '': line ": Invalid character '" data[j] "' found in #include <...>\n"}
               return false;
            }
         }
         if begin != -1 {
            start = begin + 1;
            end! = -1;
            loop j = start; pos - start; j++ {
               if data[j] == ''> {
                  end = j;
                  break;
               }
            }
            if end == -1 {
               C1.stdout{cp1-path '': line ": #include <...> must end with '>'\n"}
               return false;
            }
            var include-path:char[] = &data[start];
            include-path-len! = end - start;
            found! = false;
            loop j = 0; .included-c; j++ {
               if (&&, include-path-len == .included-len-v[j], C.memcmp(.included-v[j], include-path, include-path-len) == 0) {
                  found = true;
                  break;
               }
            }
            if !found {
               i! = .included-c++;
               if .included-cap < .included-c {
                  .included-cap = (.included-c << 1) + 8;
                  .included-v = C.realloc(.included-v, .included-cap * usz[usz]);
                  .included-len-v = C.realloc(.included-len-v, .included-cap * u32[usz]);
               }
               var path:char[] = C.malloc(include-path-len + 1);
               C.memcpy(path, include-path, include-path-len);
               path[include-path-len] = ''\0;
               .included-v[i] = path;
               .included-len-v[i] = include-path-len;
               // C1.stdout{"including " include-path, include-path-len ''\n}
               var spec-path:char[1024];
               C.sprintf(spec-path, "%s/%s", .include-dir, path);
               loop i = .include-dir-len + 1; C.strlen(spec-path) - (.include-dir-len + 1); i++ {
                  if spec-path[i] == ''/ {
                     spec-path[i] = ''-;
                  }
               }
               var spec-data:char[];
               spec-data = Cp1.read-file(spec-path, spec-len!);
               if spec-data == null {
                  C1.stdout{cp1-path '': line ": #include <" path "> failed because '" spec-path "' does not exists\n"}
                  return false;
               }
               // C1.stdout{"reading " spec-path ''\n}
               spec-pos! = 0;
               spec-line! = 0;
               loop spec-pos < spec-len {
                  spec-line++;
                  start! = spec-pos;
                  loop {
                     if spec-data[spec-pos] == ''\n {
                        if spec-data[start] == ''< {
                           start++;
                           rangle! = -1;
                           loop j = start; spec-pos - start; j++ {
                              if spec-data[j] == ''> {
                                 rangle = j;
                                 break;
                              }
                           }
                           if rangle != -1 {
                              var file-path:char[] = &spec-data[start];
                              file-path-len! = rangle - start;
                              var file-path-dup:char[] = C.malloc(file-path-len + 1);
                              C.memcpy(file-path-dup, file-path, file-path-len);
                              file-path-dup[file-path-len] = ''\0;
                              var real-path:char[] = C.malloc(.include-dir-len + 1 + file-path-len + 1);
                              C.sprintf(real-path, "%s/%.*s", .include-dir, file-path-len, file-path);
                              // C1.stdout<''[ file-path, file-path-len "] -> "; real-path; ''\n>;
                              real-path-len! = C.strlen(real-path);
                              cp1-path-add(real-path, real-path-len, file-path-dup, file-path-len);
                           }
                        }
                        spec-pos++;
                        break;
                     }
                     spec-pos++;
                  }
               }
               C.free(spec-data);
            }
         }
         pos++;
         continue;
      }
      i! = first-char;
      loop {
         if data[i] == ''\n {
            break;
         }
         if (&&, data[i] == ''/, data[i + 1] == ''/) {
            // C1.stdout{"comment detected\n"}
            break;
         } else {
            // C1.stdout{"character detected, stop\n"}
            "goto stop;";
         }
         i++;
      }
      pos++;
   }
   "stop:";
   C.free(data);
   return true;
}
validate-cp1-paths(start:i32, arg-c:i32, arg-v:char[][], bin:char[], cmd:Cmd):bool {
   loop i = start; arg-c - start; i++ {
      cp1-path! = arg-v[i];
      if cp1-path[0] == ''/ {
         print-usage(bin, cmd);
         C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n"}
         C.exit(#failure);
      }
      cp1-path-len! = C.strlen(cp1-path);
      if (&&, cp1-path[0] == ''., cp1-path[1] == ''/) {
         cp1-path = &cp1-path[2];
         cp1-path-len -= 2;
      }
      loop j = 0; cp1-path-len; j++ {
         if cp1-path[j] == ''\\ {
            print-usage(bin, cmd);
            C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain backslashes '\\', please use forward slashes '/' instead\n"}
            C.exit(#failure);
         }
      }
      loop j = 0; cp1-path-len - 1; j++ {
         if (&&, cp1-path[j] == ''., cp1-path[j + 1] == ''/) {
            print-usage(bin, cmd);
            C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain './'\n"}
            C.exit(#failure);
         }
      }
      // loop j = 0; cp1-path-len - 1; j++ {
      //    if (&&, cp1-path[j] == ''., cp1-path[j + 1] == ''/) {
      //       print-usage(bin, cmd);
      //       C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must not contain './'\n"}
      //       C.exit(#failure);
      //    }
      // }
      if !(&&, cp1-path-len > 4, cp1-path[cp1-path-len - 4] == ''., cp1-path[cp1-path-len - 3] == ''c, cp1-path[cp1-path-len - 2] == ''p, cp1-path[cp1-path-len - 1] == ''1) {
         print-usage(bin, cmd);
         C1.stdout{"Error, [cp1 file] (which is '" cp1-path "') must be a filename that ends with '.cp1', for example: main.cp1\n"}
         C.exit(#failure);
      }
      if !cp1-path-input(cp1-path, cp1-path-len, bin, cmd) {
         print-usage(bin, cmd);
         return false;
      }
   }
   return true;
}
print-command(arg-c:i32, arg-v:char[][]) {
   C1.stdout{"Command was:"}
   loop i = 0; arg-c; i++ {
      C1.stdout{''  arg-v[i] ""}
   }
   C1.stdout{''\n}
}
atexit-rm(path:char[]) {
   i! = .atexit-rm-c++;
   if .atexit-rm-cap < .atexit-rm-c {
      .atexit-rm-cap = (.atexit-rm-c << 1) + 8;
      .atexit-rm-v = C.realloc(.atexit-rm-v, .atexit-rm-cap * usz[usz]);
   }
   .atexit-rm-v[i] = path;
}
on-exit() {
   loop i = 0; .atexit-rm-c; i++ {
      // C1.stdout{"Removing " .atexit-rm-v[i] ''\n}
      X.unlink(.atexit-rm-v[i]);
   }
}
main(arg-c:intc, arg-v:char[][]):intc {
   if false {
      on-exit();
   }
   "#ifdef _WIN32";
   if true {
      arg! = arg-v[0];
      len! = C.strlen(arg);
      if (arg[len - 4] == ''.) && (arg[len - 3] == ''e) && (arg[len - 2] == ''x) && (arg[len - 1] == ''e) {
         arg[len - 4] = ''\0;
      }
   }
   loop i = 0; arg-c; i++ {
      arg! = arg-v[i];
      loop j = 0; ; j++ {
         if arg[j] == ''\0 {
            break;
         } elif arg[j] == ''\\ {
            arg[j] = ''/;
         }
      }
   }
   "#endif";
   "atexit(_Pon_exit_0);";
   bin! = arg-v[0];
   var abs-path:char[512];
   var abs-path-len:u16 = 0;
   if bin[0] == ''/ {
      abs-path-len = C.strlen(bin);
      C.memcpy(abs-path, bin, abs-path-len);
      abs-path[abs-path-len] = ''\0;
   } else {
      has-slash! = false;
      loop i = 0; ; i++ {
         if bin[i] == ''\0 { break; }
         if bin[i] == ''/ {
            has-slash = true;
            break;
         }
      }
      if has-slash {
         "#ifdef _WIN32";
         var cwd:char[512];
         X.getcwd(cwd, 512);
         C.strcpy(abs-path, &cwd[2]);
         var i = 0;
         loop ; ; i++ {
            if abs-path[i] == ''\0 {
               break;
            } elif abs-path[i] == ''\\ {
               abs-path[i] = ''/;
            }
         }
         abs-path[i++] = ''/;
         C.strcpy(&abs-path[i], bin);
         "#else";
         C.realpath(bin, abs-path);
         "#endif";
      } else {
         path! = C.strdup(C.getenv("PATH"));
         found! = C.strtok(path, ":");
         fd! = X.Fd#nil;
         loop found != null {
            C.sprintf(abs-path, "%s/%s", found, bin);
            fd = X.open(abs-path, #rdonly);
            if fd != #nil {
               break;
            }
            found = C.strtok(null, ":");
         }
         if fd == #nil {
            C1.stdout{"Cannot run " bin " because we can't detect its absolute path\n"}
            C.exit(#failure);
         }
         C.free(path);
      }
   }
   slash1! = C.strrchr(abs-path, ''/);
   slash1[0] = ''\0;
   slash2! = C.strrchr(abs-path, ''/);
   slash2[0] = ''\0;
   // C1.stdout{"absolute path of the " bin " binary is " abs-path ''\n}
   C.sprintf(.include-dir, "%s/include", abs-path);
   slash1[0] = ''/;
   slash2[0] = ''/;
   .include-dir-len = C.strlen(.include-dir);
   if arg-c < 2 {
      print-commands(bin);
      C.exit(#failure);
   }
   cmd! = arg-v[1];
   Cp1.output-cap = 4096;
   C.malloc-arr(Cp1.output-data, Cp1.output-cap);
   if C.strcmp(cmd, "c") == 0 {
      if arg-c < 4 {
         print-c-usage(bin);
         C.exit(#failure);
      }
      c-path! = arg-v[2];
      c-path-len! = C.strlen(c-path);
      if !(&&, c-path-len > 2, c-path[c-path-len - 2] == ''., c-path[c-path-len - 1] == ''c) {
         print-c-usage(bin);
         C1.stdout{"Error, [output.c] (which is '" c-path "') must be a filename that ends with '.c', for example: main.c\n"}
         C.exit(#failure);
      }
      if !validate-cp1-paths(3, arg-c, arg-v, bin, #c) {
         print-command(arg-c, arg-v);
         C.exit(#failure);
      }
      "#ifdef _WIN32";
      "mkdir(\"cp1-tmp\");";
      "#else";
      X.mkdir("cp1-tmp", 0o755);
      "#endif";
      var ninja-path:char[24];
      C.strcpy(ninja-path, "cp1-tmp/ninja-XXXXXXXXX");
      ninja-fd! = X.mkstemp(ninja-path);
      atexit-rm(C.strdup(ninja-path));
      if ninja-fd == #nil {
         print-c-usage(bin);
         C1.stdout{"Error, cannot open file for reading: " ninja-path ''\n}
         C.exit(#failure);
      }
      // ninja-f! = ninja-fd.fopen("wb");
      Cp1.output{"rule parse\n"}
      "#ifdef _WIN32";
      Cp1.output{" command = " bin "-parse.exe $in $out\n"}
      "#else";
      Cp1.output{" command = " bin "-parse $in $out\n"}
      "#endif";
      Cp1.output{"rule compile\n"}
      "#ifdef _WIN32";
      Cp1.output{" command = " bin "-compile.exe $in $out\n"}
      "#else";
      Cp1.output{" command = " bin "-compile $in $out\n"}
      "#endif";
      loop i = 0; .cp1-path-c; i++ {
         "#ifdef _WIN32";
         Cp1.output{"build cp1-tmp/" .cp1-path-v[i] "-b: parse " .cp1-path-real-v[i] " | " abs-path "-parse.exe\n"}
         "#else";
         Cp1.output{"build cp1-tmp/" .cp1-path-v[i] "-b: parse " .cp1-path-real-v[i] " | " abs-path "-parse\n"}
         "#endif";
      }
      Cp1.output{"build " c-path ": compile"}
      loop i = 0; .cp1-path-c; i++ {
         Cp1.output{" cp1-tmp/" .cp1-path-v[i] "-b"}
      }
      "#ifdef _WIN32";
      Cp1.output{" | " abs-path "-compile.exe\n"}
      "#else";
      Cp1.output{" | " abs-path "-compile\n"}
      "#endif";
      // ninja-f.close();
      ninja-fd.write(Cp1.output-data, Cp1.output-len);
      ninja-fd.close();
      var command:char[24 + 9];
      C.sprintf(command, "ninja -f %s", ninja-path);
      ret! = C.system(command);
      if ret != 0 {
         C.exit(#failure);
      }
   } elif C.strcmp(cmd, "run") == 0 {
      if arg-c < 3 {
         print-run-usage(bin);
         C.exit(#failure);
      }
      if !validate-cp1-paths(2, arg-c, arg-v, bin, #run) {
         print-command(arg-c, arg-v);
         C.exit(#failure);
      }
      "#ifdef _WIN32";
      "mkdir(\"cp1-tmp\");";
      "#else";
      X.mkdir("cp1-tmp", 0o755);
      "#endif";
      var c-path:char[22];
      C.strcpy(c-path, "cp1-tmp/c-XXXXXXXXX");
      c-fd! = X.mkstemp(c-path);
      if c-fd == #nil {
         print-run-usage(bin);
         C1.stdout{"Error, cannot open file for reading: " c-path ''\n}
         C.exit(#failure);
      }
      c-fd.close();
      X.unlink(c-path);
      var exe-path:char[24];
      C.strcpy(exe-path, "cp1-tmp/exe-XXXXXXXXX");
      exe-fd! = X.mkstemp(exe-path);
      if exe-fd == #nil {
         print-run-usage(bin);
         C1.stdout{"Error, cannot open file for reading: " exe-path ''\n}
         C.exit(#failure);
      }
      exe-fd.close();
      X.unlink(exe-path);
      c-path[19] = ''.;
      c-path[20] = ''c;
      c-path[21] = ''\0;
      atexit-rm(C.strdup(c-path));
      var ninja-path:char[24];
      C.strcpy(ninja-path, "cp1-tmp/ninja-XXXXXXXXX");
      ninja-fd! = X.mkstemp(ninja-path);
      atexit-rm(C.strdup(ninja-path));
      if ninja-fd == #nil {
         print-run-usage(bin);
         C1.stdout{"Error, cannot open file for reading: " ninja-path ''\n}
         C.exit(#failure);
      }
      // ninja-f! = ninja-fd.fopen("wb");
      Cp1.output{"rule parse\n"}
      "#ifdef _WIN32";
      Cp1.output{" command = " bin "-parse.exe $in $out\n"}
      "#else";
      Cp1.output{" command = " bin "-parse $in $out\n"}
      "#endif";
      Cp1.output{"rule compile\n"}
      "#ifdef _WIN32";
      Cp1.output{" command = " bin "-compile.exe $in $out\n"}
      "#else";
      Cp1.output{" command = " bin "-compile $in $out\n"}
      "#endif";
      get-compile(bin);
      loop i = 0; .cp1-path-c; i++ {
         "#ifdef _WIN32";
         Cp1.output{"build cp1-tmp/" .cp1-path-v[i] "-b: parse " .cp1-path-real-v[i] " | " abs-path "-parse.exe\n"}
         "#else";
         Cp1.output{"build cp1-tmp/" .cp1-path-v[i] "-b: parse " .cp1-path-real-v[i] " | " abs-path "-parse\n"}
         "#endif";
      }
      Cp1.output{"build " c-path ": compile"}
      loop i = 0; .cp1-path-c; i++ {
         Cp1.output{" cp1-tmp/" .cp1-path-v[i] "-b"}
      }
      "#ifdef _WIN32";
      Cp1.output{" | " abs-path "-compile.exe\n"}
      "#else";
      Cp1.output{" | " abs-path "-compile\n"}
      "#endif";
      Cp1.output{"build " exe-path ": c " c-path ''\n}
      // ninja-f.close();
      ninja-fd.write(Cp1.output-data, Cp1.output-len);
      ninja-fd.close();
      var command:char[32 + 9];
      C.sprintf(command, "ninja --quiet -f %s", ninja-path);
      ninja-ret! = C.system(command);
      if ninja-ret != 0 {
         C.exit(#failure);
      }
      "#ifdef _WIN32";
      loop i = 0; ; i++ {
         if exe-path[i] == ''\0 {
            break;
         } elif exe-path[i] == ''/ {
            exe-path[i] = ''\\;
         }
      }
      "#endif";
      exe-ret! = C.system(exe-path);
      X.unlink(exe-path);
      if exe-ret != 0 {
         C.exit(#failure);
      }
   } else {
      print-commands(bin);
      C.exit(#failure);
   }
   return 0;
}
