using 'c = 'libc;
using 'c1 = 'libcp1;
using 'cp1 {
enum 'enum[#nil = -1, #0, #1]'i32 {
   wr(f'this, w'wtr) @inline {
      w.n(f + #1);
   }
   rd(f'this&, r'rdr) @inline {
      f = (r.n() - #1)'func;
   }
   ptr(f'this)'enum-data @inline {
      return .enum-v[f];
   }
   output(e-i'this) {
      var num = e-i'u32;
      var n3 = num >> 3;
      var n17 = 1 << (num & 7);
      if (.enum-is-outputted[n3] & n17) != 0 { return }
      .enum-is-outputted[n3] |= n17;
      var e = e-i.ptr();

      e.base-type.output(e.file, e.begin-row, e.begin-col);

      if e.include != #nil {
         e.include.output();
      }

      // if (e.flags & #no-decl) == #0 {
         .enum-outputted-v[.enum-outputted-c++] = e-i;
      // }
   }
}
enum 'enum-flags[
   #0,
   #real-name = 1,
   #no-decl = 2,
   #soa-field = 4,
   // #overload-get = 8,
   // #overload-set = 16,
   // #overload-math = 32,
   // #overload-compare = 64,
   ]'u8 {
   wr(e'this, w'wtr) @inline {
      w.n1(e'base);
   }
   rd(e'this&, r'rdr) @inline {
      e = r.n1()'enum-flags;
   }
}
var enum-c'enum;
var enum-cap'enum;
var enum-v'enum-data[];
var decl-enum-row'u32;
var decl-enum-col'u32;
var decl-enum-at'at;
var decl-enum-real-name'id;
var decl-enum-flags'enum-flags;
var decl-enum-last-cvar'cvar;
var decl-enum-soa-field-gvar-at'at;
var decl-enum-soa-field-gvar-id'id;
decl-var-as-evar() {
   var evar = .decl-evar-c++;
   if .decl-evar-cap <= .decl-evar-c {
      grow(.decl-evar-cap, .decl-evar-c);
      realloc(.decl-evar-v, .decl-evar-cap);
   }
   .decl-evar-v[evar].copy-from(.decl-var);
}
decl-at-begin-enum(name'id, row'u32, col'u32) {
   .decl-enum-row = row;
   .decl-enum-col = col;
   .build-at = .decl-at;
   decl-at-add(name, #struct-enum, row, col);
   .decl-at-v[.decl-at-c++] = .decl-at;
   .decl-at = .build-at;
   .decl-enum-at = .build-at;
   .decl-enum-flags = #0;
   .decl-enum-last-cvar = #nil;
   // C1.stdout{"began enum at:\n"}
   // at-i! = .build-at;
   // loop {
   //    at! = at-i.ptr();
   //    C1.stdout{"- " at.name.id ''\n}
   //    at-i = at.parent;
   //    if at-i == #root { break }
   // }
}
enum-base-begin() {
   .decl-at = .decl-at.ptr().parent;
}
// enum-base-end() {
//    .decl-at = .decl-enum-at;
// }
enum-attr-soa-field(at'at, id'id) {
   .decl-enum-flags |= #soa-field;
   .decl-enum-soa-field-gvar-at = at;
   .decl-enum-soa-field-gvar-id = id;
}
enum-attr-no-decl() {
   .decl-enum-flags |= #no-decl;
}
enum-attr-real-name(id'id) {
   .decl-enum-flags |= #real-name;
   .decl-enum-real-name = id;
}
decl-enum-end(base-type'at, row'u32, col'u32) {
   var s-idx = .enum-c++;
   if .enum-cap <= .enum-c {
      var old-cap = .enum-cap;
      .enum-cap = grow(.enum-c'base)'enum;
      realloc(.enum-v, .enum-cap'base, old-cap'base);
   }
   var s'enum-data;
   quick-alloc-one(s);
   .enum-v[s-idx] = s;
   s.begin-row = .decl-enum-row;
   s.begin-col = .decl-enum-col;
   s.end-row = row;
   s.end-col = col;
   s.include = .decl-include;
   s.at = .decl-enum-at;
   s.base-type = base-type;
   .decl-at = .decl-enum-at;
   s.flags = .decl-enum-flags;
   s.soa-field-gvar-at = .decl-enum-soa-field-gvar-at;
   s.soa-field-gvar-id = .decl-enum-soa-field-gvar-id;
   s.real-name = .decl-enum-real-name;
   .decl-enum-last-cvar = #nil;
   // s.name = .decl-enum-name;
   // s.evar-c = .decl-evar-c;
   // C1.stdout{"There are " s.evar-c " evars\n"}
   // loop i = 0; .decl-evar-c; i ++ {
   //    a! = s.evar-v[i];
   //    a.decl.copy-from(.decl-evar-v[i]);
   //    // C1.stdout{"- " a.name ''\n}
   // }
}
var last-cvar'cvar;
enum-add-cvar(name'id, row'u32, col'u32) {
   var c-idx = .cvar-c++;
   .last-cvar = c-idx;
   if .cvar-cap <= .cvar-c {
      var old-cap = .cvar-cap;
      .cvar-cap = grow(.cvar-c'base)'cvar;
      realloc(.cvar-v, .cvar-cap'base, old-cap'base);
   }
   var c = c-idx.ptr();
   c.row = row;
   c.col = col;
   c.include = .decl-include;
   c.at = .decl-at;
   c.decl.name = name;
   c.decl.type = .decl-enum-at;
   c.decl.type-info.init();
   c.flags = #as-enum;
   c.last-cvar = .decl-enum-last-cvar;
   .decl-enum-last-cvar = c-idx;
}
decl-add-cvar(name'id, row'u32, col'u32) {
   var c-idx = .cvar-c++;
   .last-cvar = c-idx;
   if .cvar-cap <= .cvar-c {
      var old-cap = .cvar-cap;
      .cvar-cap = grow(.cvar-c'base)'cvar;
      realloc(.cvar-v, .cvar-cap'base, old-cap'base);
   }
   var c = c-idx.ptr();
   c.row = row;
   c.col = col;
   c.include = .decl-include;
   c.at = .decl-at;
   .decl-var.name = name;
   c.decl.copy-from(.decl-var);
   if (c.decl.flags & #real-name) != #0 {
      if (c.decl.name.len() == 7) && ('c.memcmp(c.decl.name.str(), "failure", 7) == 0) {
         'c1.stdout{"failure has a real-name at decl-add-cvar\n"}
      }
   }
   c.flags = #0;
}
enum-set-cvar-expr(set'expr-i) {
   var c = .last-cvar.ptr();
   c.flags |= #set-expr;
   c.expr-set = set;
}
cvar-attr-real-name(name'id) {
   var c = .last-cvar.ptr();
   c.decl.flags |= #real-name;
   c.decl.real-name = name;
}
cvar-attr-no-decl() {
   var c = .last-cvar.ptr();
   c.decl.flags |= #no-decl;
}
cvar-attr-no-name() {
   var c = .last-cvar.ptr();
   c.flags |= #no-name;
}
cvar-attr-dont-count() {
   var c = .last-cvar.ptr();
   c.flags |= #dont-count;
}
 

}
