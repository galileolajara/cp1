{using 'c = :stdc}
{using 'sys = :sys}
{print-commands(bin:char[])
   'c.printf("Usage: %s [command] [options]\n", bin);
   'c.printf("Commands:\n");
   'c.printf("  c     Build a C file.\n");
   'c.printf("  run      Compile and run the cp1 codes.\n");
}
{print-c-usage(bin:char[])
   'c.printf("Usage: %s c [output.c] [cp1 file/s...]\n", bin);
}
{print-run-usage(bin:char[])
   'c.printf("Usage: %s run [cp1 file/s...]\n", bin);
}
{get-compiler(bin:char[], ninja-f'c:file)
   +PATH = 'c.strdup('c.getenv("PATH"));
   // 'c.printf("PATH = %s\n", PATH);
   +found = 'c.strtok(PATH, ":");
   {while(found != null)
      // 'c.printf("- %s\n", found);
      {+fd, compiler:char[512]}
      'c.sprintf(compiler, "%s/tcc", found);
      fd = 'c.open(compiler, #read);
      {if(fd != #nil)
         ninja-f.printf("rule c\n");
         ninja-f.printf(" command = tcc $in -o $out\n");
         fd.close();
         return;
      }
      'c.sprintf(compiler, "%s/clang", found);
      fd = 'c.open(compiler, #read);
      {if(fd != #nil)
         ninja-f.printf("rule c\n");
         ninja-f.printf(" command = clang $in -o $out\n");
         fd.close();
         return;
      }
      'c.sprintf(compiler, "%s/gcc", found);
      fd = 'c.open(compiler, #read);
      {if(fd != #nil)
         ninja-f.printf("rule c\n");
         ninja-f.printf(" command = gcc $in -o $out\n");
         fd.close();
         return;
      }
      found = 'c.strtok(null, ":");
   }
   'c.printf("Cannot execute '%s run' because the required compiler was not found: tcc clang or gcc\n", bin);
   'c.exit(#failure);
}
{:cmd[#c, #run]:u8}
{print-usage(bin:char[], cmd:cmd)
   {switch(cmd)
      {case(#c)
         print-c-usage(bin);
      }
      {case(#run)
         print-run-usage(bin);
      }
   }
}
{gvar included-v:char[][]}
{gvar included-len-v:u32[]}
{gvar included-cap:i32}
{gvar included-c:i32}
{gvar cp1-path-v:char[][]}
{gvar cp1-path-len-v:u32[]}
{gvar cp1-path-real-v:char[][]}
{gvar cp1-path-real-len-v:u32[]}
{gvar cp1-path-cap:i32}
{gvar cp1-path-c:i32}
{cp1-path-add(cp1-path-real:char[], cp1-path-real-len:i32, cp1-path:char[], cp1-path-len:i32)
   // 'c.printf("adding %s as %s\n", cp1-path-real, cp1-path);
   +i = .cp1-path-c++;
   {if(.cp1-path-cap < .cp1-path-c)
      .cp1-path-cap = (.cp1-path-cap << 1) + 8;
      .cp1-path-v = 'c.realloc(.cp1-path-v, .cp1-path-cap * :usz[:usz]);
      .cp1-path-len-v = 'c.realloc(.cp1-path-len-v, .cp1-path-cap * :u32[:usz]);
      .cp1-path-real-v = 'c.realloc(.cp1-path-real-v, .cp1-path-cap * :usz[:usz]);
      .cp1-path-real-len-v = 'c.realloc(.cp1-path-real-len-v, .cp1-path-cap * :u32[:usz]);
   }
   .cp1-path-v[i] = cp1-path;
   .cp1-path-len-v[i] = cp1-path-len;
   .cp1-path-real-v[i] = cp1-path-real;
   .cp1-path-real-len-v[i] = cp1-path-real-len;
}
{cp1-path-input(cp1-path:char[], cp1-path-len:i32, bin:char[], cmd:cmd):bool
	{do{+i = 0}{(.cp1-path-c) i++}
		{if('c.memcmp(.cp1-path-v[i], cp1-path, cp1-path-len) == 0)
			return true;
		}
	}
   cp1-path-add(cp1-path, cp1-path-len, cp1-path, cp1-path-len);
   {if!('c:fd.open(++fd, cp1-path, #read))
      'c.printf("Error, [cp1 file] (which is '%s') cannot be opened for reading\n", cp1-path);
		return false;
   }
   +len = fd.seek(0, #end);
   fd.seek(0, #set);
   {+data:char[] = 'c.malloc(len + 1)}
   fd.read(data, len);
   fd.close();
   data[len] = ''\0;
   {if!(&&, len > 0, data[len - 1] == ''\n)
      'c.printf("Error, [cp1 file] (which is '%s') must end a new line\n", cp1-path);
		return false;
   }
   {if(data[len - 2] == ''\r)
      'c.printf("Error, [cp1 file] (which is '%s') must have Unix line endings '\\n' instead of Windows line endings '\\r\\n'\n", cp1-path);
		return false;
   }
   +pos = 0;
   // Process consecutive lines that begins with '#'
   +line = 0;
   {while(data[pos] == ''#)
      line++;
      +start = pos;
      {do()
         pos++;
         {if(data[pos] == ''\n)
            {if('c.memcmp("#import \"", & data[start], 9) == 0)
					start += 9;
               +end = -1;
               {do{+j = start}{(pos - start) j++}
                  {if(data[j] == ''")
                     end = j;
                     break;
                  }
               }
               {if(end == -1)
                  'c.printf("%s:%u: #import \"...\" must end with '\"'\n", cp1-path, line);
						return false;
               }
					{+import:char[] = & data[start]}
               +import-path-len = end - start;
					{if(&&, import-path-len >= 4, import[import-path-len - 4] == ''., import[import-path-len - 3] == ''c, import[import-path-len - 2] == ''g, import[import-path-len - 1] == ''l)
                  'c.printf("%s:%u: #import \"%.*s\" doesn't need a '.cp1' suffix\n", cp1-path, line, import-path-len, import);
						return false;
					}
					{if(import[0] == ''/)
						'c.printf("%s:%u: #import \"%.*s\" must be a relative path, '/' was detected at the beginning of file path\n", cp1-path, line, import-path-len, import);
						return false;
					}
				   {do{+j = 0}{(import-path-len) j++}
				   	{if(import[j] == ''\\)
							'c.printf("%s:%u: #import \"%.*s\" must not contain backslashes '\\', please use forward slashes '/' instead\n", cp1-path, line, import-path-len, import);
							return false;
				   	}
				   }
				   {do{+j = 0}{(import-path-len - 1) j++}
				   	{if(&&, import[j] == ''., import[j + 1] == ''/)
							'c.printf("%s:%u: #import \"%.*s\" must not contain './'\n", cp1-path, line, import-path-len, import);
							return false;
				   	}
				   }
					{+import-path:char[] = 'c.malloc(import-path-len + 5)}
					'c.memcpy(import-path, import, import-path-len);
					import-path[import-path-len++] = ''.;
					import-path[import-path-len++] = ''c;
					import-path[import-path-len++] = ''g;
					import-path[import-path-len++] = ''l;
					import-path[import-path-len] = ''\0;
					{if!(cp1-path-input(import-path, import-path-len, bin, cmd))
						'c.printf("Error from #import \"%.*s\" at file '%s' line %u\n", import-path-len - 4, import, cp1-path, line);
						return false;
					}
				}{elif('c.memcmp("#include <", & data[start], 10) == 0)
					start += 10;
               +end = -1;
               {do{+j = start}{(pos - start) j++}
                  {if(data[j] == ''>)
                     end = j;
                     break;
                  }
               }
               {if(end == -1)
                  'c.printf("%s:%u: #include <...> must end with '>'\n", cp1-path, line);
						return false;
               }
               {+include-path:char[] = & data[start]}
               +include-path-len = end - start;
               +found = false;
               {do{+j = 0}{(.included-c) j++}
                  {if(&&, include-path-len == .included-len-v[j], 'c.memcmp(.included-v[j], include-path, include-path-len) == 0)
                     found = true;
                     break;
                  }
               }
               {if!(found)
                  +i = .included-c++;
                  {if(.included-cap < .included-c)
                     .included-cap = (.included-c << 1) + 8;
                     .included-v = 'c.realloc(.included-v, .included-cap * :usz[:usz]);
                     .included-len-v = 'c.realloc(.included-len-v, .included-cap * :u32[:usz]);
                  }
                  {+path:char[] = 'c.malloc(include-path-len + 1)}
                  'c.memcpy(path, include-path, include-path-len);
                  path[include-path-len] = ''\0;
                  .included-v[i] = path;
                  .included-len-v[i] = include-path-len;
                  // 'c.printf("including %.*s\n", include-path-len, include-path);
                  {+spec-path:char[128]}
                  +include-dir = "/opt/cp1/include";
                  +include-dir-len = 'c.strlen(include-dir);
                  'c.sprintf(spec-path, "%s/%s", include-dir, path);
                  {do{+i = include-dir-len + 1}{('c.strlen(spec-path) - (include-dir-len + 1)) i++}
                     {if(spec-path[i] == ''/)
                        spec-path[i] = ''-;
                     }
                  }
                  {if!('c:fd.open(++spec-fd, spec-path, #read))
                     'c.printf("%s:%u: #include <%s> failed because '%s' does not exists\n", cp1-path, line, path, spec-path);
							return false;
                  }
                  +spec-len = spec-fd.seek(0, #end);
                  spec-fd.seek(0, #set);
                  {+spec-data:char[] = 'c.malloc(spec-len + 1)}
                  spec-fd.read(spec-data, spec-len);
                  // 'c.printf("reading %s\n", spec-path);
                  +spec-pos = 0;
                  +spec-line = 0;
                  {while(spec-pos < spec-len)
                     spec-line++;
                     +start = spec-pos;
                     {do()
                        {if(spec-data[spec-pos] == ''\n)
                           {if(spec-data[start] == ''<)
                              start++;
                              +rangle = -1;
                              {do{+j = start}{(spec-pos - start) j++}
                                 {if(spec-data[j] == ''>)
                                    rangle = j;
                                    break;
                                 }
                              }
                              {if(rangle != -1)
                                 {+file-path:char[] = & spec-data[start]}
                                 +file-path-len = rangle - start;
                                 {+file-path-dup:char[] = 'c.malloc(file-path-len + 1)}
                                 'c.memcpy(file-path-dup, file-path, file-path-len);
                                 file-path-dup[file-path-len] = ''\0;
                                 {+real-path:char[] = 'c.malloc(include-dir-len + 1 + file-path-len + 1)}
                                 'c.sprintf(real-path, "%s/%.*s", include-dir, file-path-len, file-path);
                                 // 'c.printf("[%.*s] -> %s\n", file-path-len, file-path, real-path);
                                 +real-path-len = 'c.strlen(real-path);
                                 cp1-path-add(real-path, real-path-len, file-path-dup, file-path-len);
                              }
                           }
                           spec-pos++;
                           break;
                        }
                        spec-pos++;
                     }
                  }
                  'c.free(spec-data);
               }
            }
            pos++;
            break;
         }
      }
   }
   'c.free(data);
	return true;
}
{validate-cp1-paths(start:i32, arg-c:i32, arg-v:char[][], bin:char[], cmd:cmd):bool
   {do{+i = start}{(arg-c - start) i++}
      +cp1-path = arg-v[i];
      {if(cp1-path[0] == ''/)
         print-usage(bin, cmd);
         'c.printf("Error, [cp1 file] (which is '%s') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n", cp1-path);
         'c.exit(#failure);
      }
      +cp1-path-len = 'c.strlen(cp1-path);
		{if(&&, cp1-path[0] == ''., cp1-path[1] == ''/)
			cp1-path = & cp1-path[2];
			cp1-path-len -= 2;
		}
      {do{+j = 0}{(cp1-path-len) j++}
         {if(cp1-path[j] == ''\\)
            print-usage(bin, cmd);
            'c.printf("Error, [cp1 file] (which is '%s') must not contain backslashes '\\', please use forward slashes '/' instead\n", cp1-path);
            'c.exit(#failure);
         }
      }
      {do{+j = 0}{(cp1-path-len - 1) j++}
         {if(&&, cp1-path[j] == ''., cp1-path[j + 1] == ''/)
            print-usage(bin, cmd);
            'c.printf("Error, [cp1 file] (which is '%s') must not contain './'\n", cp1-path);
            'c.exit(#failure);
         }
      }
      // {do{+j = 0}{(cp1-path-len - 1) j++}
      //    {if(&&, cp1-path[j] == ''., cp1-path[j + 1] == ''/)
      //       print-usage(bin, cmd);
      //       'c.printf("Error, [cp1 file] (which is '%s') must not contain './'\n", cp1-path);
      //       'c.exit(#failure);
      //    }
      // }
      {if!(&&, cp1-path-len > 4, cp1-path[cp1-path-len - 4] == ''., cp1-path[cp1-path-len - 3] == ''c, cp1-path[cp1-path-len - 2] == ''p, cp1-path[cp1-path-len - 1] == ''1)
         print-usage(bin, cmd);
         'c.printf("Error, [cp1 file] (which is '%s') must be a filename that ends with '.cp1', for example: main.cp1\n", cp1-path);
         'c.exit(#failure);
      }
      {if!(cp1-path-input(cp1-path, cp1-path-len, bin, cmd))
         print-usage(bin, cmd);
			return false;
		}
   }
	return true;
}
{print-command(arg-c:i32, arg-v:char[][])
	'c.printf("Command was:");
	{do{+i = 0}{(arg-c) i++}
		'c.printf(" %s", arg-v[i]);
	}
	'c.printf("\n");
}
{main(arg-c:i32, arg-v:char[][]):i32
   +bin = arg-v[0];
   {if(arg-c < 2)
      print-commands(bin);
      'c.exit(#failure);
   }
   +cmd = arg-v[1];
   {if('c.strcmp(cmd, "c") == 0)
      {if(arg-c < 4)
         print-c-usage(bin);
         'c.exit(#failure);
      }
      +c-path = arg-v[2];
      +c-path-len = 'c.strlen(c-path);
      {if!(&&, c-path-len > 2, c-path[c-path-len - 2] == ''., c-path[c-path-len - 1] == ''c)
         print-c-usage(bin);
         'c.printf("Error, [output.c] (which is '%s') must be a filename that ends with '.c', for example: main.c\n", c-path);
         'c.exit(#failure);
      }
      {if!(validate-cp1-paths(3, arg-c, arg-v, bin, #c))
			print-command(arg-c, arg-v);
         'c.exit(#failure);
		}
      'sys.mkdir("cp1-tmp", 0o755);
      {+ninja-path:char[24]}
      'c.strcpy(ninja-path, "cp1-tmp/ninja-XXXXXXXXX");
      +ninja-fd = 'c.mkstemp(ninja-path);
      {if(ninja-fd == #nil)
         print-c-usage(bin);
         'c.printf("Error, cannot open file for reading: %s\n", ninja-path);
         'c.exit(#failure);
      }
      +ninja-f = ninja-fd.fopen("w");
      ninja-f.printf("rule parser\n");
      ninja-f.printf(" command = %s-parser $in $out\n", bin);
      ninja-f.printf("rule compiler\n");
      ninja-f.printf(" command = %s-compiler $in $out\n", bin);
      {do{+i = 0}{(.cp1-path-c) i++}
         ninja-f.printf("build cp1-tmp/%s-b: parser %s\n", .cp1-path-v[i], .cp1-path-real-v[i]);
      }
      ninja-f.printf("build %s: compiler", c-path);
      {do{+i = 0}{(.cp1-path-c) i++}
         ninja-f.printf(" cp1-tmp/%s-b", .cp1-path-v[i]);
      }
      ninja-f.printf("\n");
      ninja-f.close();
      {+command:char[24 + 9]}
      'c.sprintf(command, "ninja -f %s", ninja-path);
      +ret = 'c.system(command);
      'c.unlink(ninja-path);
      {if(ret != 0)
         'c.exit(#failure);
      }
   }{elif('c.strcmp(cmd, "run") == 0)
      {if(arg-c < 3)
         print-run-usage(bin);
         'c.exit(#failure);
      }
      {if!(validate-cp1-paths(2, arg-c, arg-v, bin, #run))
			print-command(arg-c, arg-v);
         'c.exit(#failure);
		}
      'sys.mkdir("cp1-tmp", 0o755);
      {+c-path:char[22]}
      'c.strcpy(c-path, "cp1-tmp/c-XXXXXXXXX");
      +c-fd = 'c.mkstemp(c-path);
      {if(c-fd == #nil)
         print-run-usage(bin);
         'c.printf("Error, cannot open file for reading: %s\n", c-path);
         'c.exit(#failure);
      }
      c-fd.close();
      'c.unlink(c-path);
      {+exe-path:char[24]}
      'c.strcpy(exe-path, "cp1-tmp/exe-XXXXXXXXX");
      +exe-fd = 'c.mkstemp(exe-path);
      {if(exe-fd == #nil)
         print-run-usage(bin);
         'c.printf("Error, cannot open file for reading: %s\n", exe-path);
         'c.exit(#failure);
      }
      exe-fd.close();
      'c.unlink(exe-path);
      c-path[19] = ''.;
      c-path[20] = ''c;
      c-path[21] = ''\0;
      {+ninja-path:char[24]}
      'c.strcpy(ninja-path, "cp1-tmp/ninja-XXXXXXXXX");
      +ninja-fd = 'c.mkstemp(ninja-path);
      {if(ninja-fd == #nil)
         print-run-usage(bin);
         'c.printf("Error, cannot open file for reading: %s\n", ninja-path);
         'c.exit(#failure);
      }
      +ninja-f = ninja-fd.fopen("w");
      ninja-f.printf("rule parser\n");
      ninja-f.printf(" command = %s-parser $in $out\n", bin);
      ninja-f.printf("rule compiler\n");
      ninja-f.printf(" command = %s-compiler $in $out\n", bin);
      get-compiler(bin, ninja-f);
      {do{+i = 0}{(.cp1-path-c) i++}
         ninja-f.printf("build cp1-tmp/%s-b: parser %s\n", .cp1-path-v[i], .cp1-path-real-v[i]);
      }
      ninja-f.printf("build %s: compiler", c-path);
      {do{+i = 0}{(.cp1-path-c) i++}
         ninja-f.printf(" cp1-tmp/%s-b", .cp1-path-v[i]);
      }
      ninja-f.printf("\n");
      ninja-f.printf("build %s: c %s\n", exe-path, c-path);
      ninja-f.close();
      {+command:char[24 + 9]}
      'c.sprintf(command, "ninja -f %s", ninja-path);
      +ninja-ret = 'c.system(command);
      'c.unlink(ninja-path);
      'c.unlink(c-path);
      {if(ninja-ret != 0)
         'c.exit(#failure);
      }
      +exe-ret = 'c.system(exe-path);
      'c.unlink(exe-path);
      {if(exe-ret != 0)
         'c.exit(#failure);
      }
   }{else
      print-commands(bin);
      'c.exit(#failure);
   }
   return 0;
}
