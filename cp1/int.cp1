using 'cp1 = :cp1;
using (:cp1) {
:expr-int[#dec, #hex, #oct]:u8;
expr-int(value:i32, type:expr-int):expr-i {
   quick-alloc-one(+(e:expr-int-data));
   +e-idx = expr-push(e.base, #i32);
   e.value = value;
   e.type = type;
   return e-idx;
}
using (:expr-i) {
   wr-i32(expr:expr, w:wtr, header:bool) @case.wr() @inline {
      var e:expr-int-data = expr;
      w.n1(e.type);
      w.n(e.value);
   }
   rd-i32(e-idx:expr-i, r:rdr) @case.rd() @inline {
      quick-alloc-one(+(e:expr-int-data));
      e-idx.set(e.base, #i32);
      e.type = r.n1():expr-int;
      e.value = r.n();
   }
   write-i32(expr:expr) @case.write() @inline {
      var e:expr-int-data = expr;
      .out.printf("%d", e.value);
   }
   process-i32(expr:expr, ok:bool&) @case.process() @inline {
      ok = true;
   }
   type-i32(expr:expr, at:at&) @case.type() @inline {
      at = basic-type(#i32);
   }
   value-i32(le:this, ref:i32, paren:bool, v:value, ok:bool&) @case.value() @inline {
      v.type = basic-type(#i32);
      v.info.init();
      v.info.array-c = 0;
      v.info.ref-v[0] = ''\0;
      v.info.star-c = 0;
      v.ref = 1;
      v.paren = false;
      ok = true;
   }
}
 

}
