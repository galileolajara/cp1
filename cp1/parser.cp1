using 'cp1 = :cp1;
using 'c = :stdc;
using 'sys = :sys;
{at(:cp1)
{gvar ctx-func:decl-func}
{gvar id-in-header-v:u8[]}
{gvar id-in-header-idx-v:u32[]}
{gvar id-in-header-id-v:u32[]}
{gvar id-in-header-c:i32}

{gvar at-in-header-v:u8[]}
{gvar at-in-header-idx-v:u32[]}
{gvar at-in-header-at-v:u32[]}
{gvar at-in-header-c:i32}

{gvar decl-include:include}
{gvar decl-include-row:i32}
{gvar decl-include-col:i32}
type-info-begin() {
   .decl-var.size-c = 0;
   .decl-var.type-info.init();
   .decl-var.flags = #0;
}
type-info-finalize() {
   .decl-var.type-info.finalize();
}
type-info-arr(expr-v:expr-i[], expr-c:u8) {
   var r:rdr+;
   r.ref = expr-v;
   if (expr-v == null) {
      +ti = .decl-var.type-info;
      ti.array-c += 1;
      ti.ref-v[ti.array-c] = 0;
      return;
   }
   loop var i = expr-c; (expr-c) {
      type-info-arr(expr-v[i -= 1]);
   }
}
type-info-arr(expr:expr-i) {
   +ti = .decl-var.type-info;
	ti.array-c += 1;
	ti.ref-v[ti.array-c] = 0;
	if (expr != #nil) {
      +vd = .decl-var;
      if (vd.size-c == 0) {
         quick-alloc-arr(vd.size-expr-v, #decl-var-size-limit);
      }
      vd.size-expr-v[vd.size-c++] = expr;
      // 'c.out.printf("%s, vd.size-c = %d\n", vd.name.str(), vd.size-c);
	}
}
type-info-ref(c:i8) {
   +ti = .decl-var.type-info;
	ti.ref-v[ti.array-c] += c;
}
type-info-static() {
   // 'c.out.printf("built-in\n");
   .decl-var.type-info.built-in = true;
}
decl-include-begin(inc:include, row:i32, col:i32) {
   if (.decl-include != #nil) {
      'c.out.printf("%s:%u:%u: Cannot {include inside another {include of %u:%u\n", .input-path, row, col, .decl-include-row, .decl-include-col);
      'c.exit(#failure);
      return}
   .decl-include = inc;
   .decl-include-row = row;
   .decl-include-col = col;
}
decl-include-end() {
   .decl-include = #nil;
}
{gvar build-at:at}
at-push(name:id, type:name-type, row:i32, col:i32) {
   .build-at = at-create(.build-at, type, name);
}
at-basic-type(type:basic-type-id):at {
   loop var i = 0:at; {(.at-c) i++} {
      +at = .at-v[i];
      if (&&, at.type == #basic, at.name.basic == type) {
         return i;
      }
   }
   +build-idx = .at-c++;
   if (.at-cap <= .at-c) {
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = type;
   return build-idx;
}
at-begin() {
   .build-at = .decl-at;
}
{gvar at-begin-relative-pause:bool}
at-begin-relative-pause() {
   .at-begin-relative-pause = true;
}
at-begin-relative-resume() {
   .at-begin-relative-pause = false;
}
at-begin-relative() {
   if (.at-begin-relative-pause) {
      .build-at = .decl-at;
   } else {
      .build-at = #relative;
   }
}
:alias[#nil = -1, #0]:i32;
{gvar at-alias-c:alias}
{gvar at-alias-cap:alias}
{gvar at-alias-name-v:id[]}
{gvar at-alias-at-v:at[]}
{gvar at-alias-pos-v:row-col+[]}
:row-col(row:i32, col:i32);
at-alias(name:id, row:i32, col:i32) {
   loop var i = 0; {(.at-alias-c) i++} {
      if (.at-alias-name-v[i] == name) {
         .build-at = .at-alias-at-v[i];
         return;
      }
   }
   'c.out.printf("%s:%u:%u: Cannot recognize the '%s, did you forgot to put using '%s = ...;?\n", .input-path, row, col, name.str(), name.str());
   'c.exit(#failure);
}
decl-alias(name:id, at:at, row:i32, col:i32) {
   // if (at.ptr().type != #module) {
   //    'c.out.printf("%s:%u:%u: Alias can only work on namespaces that ends with '%%'\n", .input-path, row, col);
   //    'c.exit(#failure);
   //    return;
   // }
   loop var i = 0; {(.at-alias-c) i++} {
      if (.at-alias-name-v[i] == name) {
         'c.out.printf("%s:%u:%u: Alias '%s was already declared at %u:%u\n", .input-path, row, col, name.str(), .at-alias-pos-v[i].row, .at-alias-pos-v[i].col);
         'c.exit(#failure);
         return;
      }
   }
   +alias-idx = .at-alias-c++;
   if (.at-alias-cap <= .at-alias-c) {
      +old-cap = .at-alias-cap;
      grow(.at-alias-cap, .at-alias-c);
      realloc(.at-alias-name-v, .at-alias-cap, old-cap);
      realloc(.at-alias-at-v, .at-alias-cap, old-cap);
      realloc(.at-alias-pos-v, .at-alias-cap, old-cap);
   }
   .at-alias-name-v[alias-idx] = name;
   .at-alias-at-v[alias-idx] = at;
   .at-alias-pos-v[alias-idx].row = row;
   .at-alias-pos-v[alias-idx].col = col;
}
at-root() {
   .build-at = #root;
}
at-graves(graves:i8, row:i32, col:i32) {
   .build-at = .decl-at;
   while (graves > 0) {
      graves--;
      if (.build-at == #root) {
         'c.out.printf("%s:%u:%u: Too many graves in the namespace, going beyond the root namespace\n", .input-path, row, col);
         'c.exit(#failure);
      }
      +at = .build-at.ptr();
      .build-at = at.parent;
   }
}
at-done():at {
   return .build-at;
}
at-create(parent:at, type:name-type, name:id):at {
   +found = .at-map.get-or-insert(parent, type, name, .at-c);
   if (found != -1) { return found}
   // loop var i = 0:at; {(.at-c) i++} {
   //    +at = .at-v[i];
   //    if (&&,
   //       at.parent == parent,
   //       at.type == type,
   //       at.name.id == name) {
   //       return i;
   //    }
   // }
   +build-idx = .at-c++;
   if (.at-cap <= .at-c) {
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = parent;
   at.type = type;
   at.name.id = name;
   return build-idx;
}
at-create-basic(basic:basic-type-id):at {
   loop var i = 0:at; {(.at-c) i++} {
      +at = .at-v[i];
      if (&&,
         at.type == #basic,
         at.name.basic == basic) {
         return i;
      }
   }
   +build-idx = .at-c++;
   if (.at-cap <= .at-c) {
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = basic;
   return build-idx;
}

{gvar decl-at:at}
{cvar #decl-at-nest-limit:i32 = 8}
{gvar decl-at-v:at[#decl-at-nest-limit]}
{gvar decl-at-c:u8}
err-msg-namespace-limit(row:i32, col:i32) {
   'c.out.printf("%s:%u:%u: Max number of ids in namespace reached\n", .input-path, row, col);
   'c.exit(#failure);
}
decl-at-add(name:id, type:name-type) {
   .build-at = at-create(.build-at, type, name);
}
decl-at-basic(type:basic-type-id) {
   .build-at = at-create-basic(type);
}
decl-at-begin(row:i32, col:i32) {
   .decl-at-v[.decl-at-c++] = .decl-at;
   .decl-at = .build-at;
}
decl-at-end() {
   .decl-at-c--;
   .decl-at = .decl-at-v[.decl-at-c];
}
:token-data(
   row:i32,
   col:i32,
   id:i32,
   id2:i32,
   val:i32[12],
);
:lexer(
   content:u8[],
   start:u8[],
   cursor:u8[],
   // limit:u8[],
   marker:u8[],
   // ctx-marker:u8[],
) {
   init(lex:this, data:u8[], size:usz) {
      lex.start = data;
      lex.cursor = data;
      lex.content = data;
      // lex.limit = & data[size];
   }
   scan(lex:this):token @real-name(cp1_lexer_scan);
   get-u32-oct(lex:this):u32 {
      var r-start:rdr+;
      r-start.ref = lex.start;
      var r-cursor:rdr+;
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos;
      if (length > 12) {
         'c.out.printf("%s:%u:%u: Integer literal was too long\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      +val = 0:u64;
      loop (length) {
         val = (val * 8:u64) + (r-start.p1[0] - ''0);
         r-start.pos++;
      }
      if (val > 4294967295) {
         'c.out.printf("%s:%u:%u: Integer literal was out of bounds\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      return val:u32;
   }
   get-u32-dec(lex:this):u32 {
      var r-start:rdr+;
      r-start.ref = lex.start;
      var r-cursor:rdr+;
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos;
      if (length > 10) {
         'c.out.printf("%s:%u:%u: Integer literal was too long\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      +val = 0:u64;
      loop (length) {
         val = (val * 10:u64) + (r-start.p1[0] - ''0);
         r-start.pos++;
      }
      if (val > 4294967295) {
         'c.out.printf("%s:%u:%u: Integer literal was out of bounds\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      return val:u32;
   }
   get-id(lex:this, begin:u8, end:u8):i32 {
      var r-start:rdr+;
      r-start.ref = lex.start;
      r-start.pos += begin;
      var r-cursor:rdr+;
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos - end;
      if (length > 255) {
         'c.out.printf("too long id was detected\n");
         'c.exit(#failure);
      }
      +len = length:u8;
      +found = .id-map.get-or-insert(r-start.ref, len, .id-c);
      if (found == -1) {
         // inserted
         +id = .id-c++;
         if (.id-cap <= .id-c) {
            +old-cap = .id-cap;
            grow(.id-cap, .id-c);
            realloc(.id-str-v, .id-cap, old-cap);
            realloc(.id-len-v, .id-cap, old-cap);
         }
         var text:char[] = quick-alloc(len + 1);
         'c.memcpy(text, r-start.ref, len);
         text[len] = 0;
         .id-str-v[id] = text;
         .id-len-v[id] = len;
         return id;
      } else {
         // found
         return found;
      }
      // loop var i = 0; {(.id-c) i++} {
      //    if (.id-len-v[i] == len) {
      //       if ('c.memcmp(.id-str-v[i], r-start.ref, len) == 0) {
      //          return i;
      //       }
      //    }
      // }
      // +id = .id-c++;
      // if (.id-cap <= .id-c) {
      //    +old-cap = .id-cap;
      //    grow(.id-cap, .id-c);
      //    realloc(.id-str-v, .id-cap, old-cap);
      //    realloc(.id-len-v, .id-cap, old-cap);
      // }
      // var text:char[] = quick-alloc(len + 1);
      // 'c.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .id-str-v[id] = text;
      // .id-len-v[id] = len;
      // return id;
   }
   get-include(lex:this):i32 {
      var r-start:rdr+;
      r-start.ref = lex.start;
      r-start.pos += 9;
      var r-cursor:rdr+;
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos - 1;
      if (length > 255) {
         'c.out.printf("too long include was detected\n");
         'c.exit(#failure);
      }
      +len = length:u8;
      +found = .include-map.get-or-insert(r-start.ref, len, .include-c);
      if (found == -1) {
         // inserted
         +include = .include-c++;
         if (.include-cap <= .include-c) {
            +old-cap = .include-cap;
            grow(.include-cap, .include-c);
            realloc(.include-str-v, .include-cap, old-cap);
            realloc(.include-len-v, .include-cap, old-cap);
         }
         var text:char[] = quick-alloc(len + 1);
         'c.memcpy(text, r-start.ref, len);
         text[len] = 0;
         .include-str-v[include] = text;
         .include-len-v[include] = len;
         return include;
      } else {
         // found
         return found;
      }
      // loop var i = 0; {(.include-c) i++} {
      //    if (.include-len-v[i] == len) {
      //       if ('c.memcmp(.include-str-v[i], r-start.ref, len) == 0) {
      //          return i;
      //       }
      //    }
      // }
      // +include = .include-c++;
      // if (.include-cap <= .include-c) {
      //    +old-cap = .include-cap;
      //    grow(.include-cap, .include-c);
      //    realloc(.include-str-v, .include-cap, old-cap);
      //    realloc(.include-len-v, .include-cap, old-cap);
      // }
      // var text:char[] = quick-alloc(len + 1);
      // 'c.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .include-str-v[include] = text;
      // .include-len-v[include] = len;
      // return include;
   }
}
{gvar last-token:token}
:parser() {
   alloc():parser;
   free(psr:this);
   parse(psr:this, t:token, tok:token-data+) @real-name(cp1Parse);
}
{gvar last-row:i32 @extern}
{gvar last-col:i32 @extern}
{gvar row:i32 @extern}
{gvar col:i32 @extern}
write-func(w:wtr, header:bool) @inline {
   w.n(.func-c);
   loop var i = 0; (.func-c) {
      +f = .func-v[i++];
      w.n1(f.farg-c);
      w.n(f.begin-row);
      w.n(f.begin-col);
      w.n(f.end-row);
      w.n(f.end-col);
      f.include.wr(w);
      f.at.wr(w, header);
      f.decl.wr(w, header);
      loop var j = 0; {(f.farg-c) j++} {
         f.farg-v[j].wr(w, header);
      }
      w.n1(f.this-idx);
      if (f.this-idx != -1) {
         w.n1(f.this-group);
      }
      w.n1(f.group-c);
      loop var j = 0; {(f.group-c) j++} {
         w.n1(f.group-v[j]);
      }
      if (header) {
         if (f.flags & #inline) {
            // proceed
            f.flags.wr(w);
         } else {
            // remove #has-body flag
            (f.flags & (-1 ^ :func-flags#has-body)):func-flags.wr(w);
         }
      } else {
         f.flags.wr(w);
      }
      if ((f.flags & #real-name) != #0) {
         f.real-name.wr(w, header);
      }
      if ((f.flags & #case) != #0) {
         f.cas.wr(w, header);
      }
      if ((f.flags & #decl) != #0) {
         w.n(f.decl-len);
         w.copy(f.decl-str, f.decl-len);
      }
   }
   .func-main.wr(w);
   loop var i = 0; (.func-c) {
      +f = .func-v[i++];
      if ((f.flags & #has-body) == #0) { continue}
      if (header) {
         if (f.flags & #inline) {
            // proceed
         } else {
            // remove #has-body flag
            continue;
         }
      }
      var pos-4:wtr+;
      pos-4.p1 = w.p1;
      w.pos += 4;
      +pos-4-next = w.pos;
      f.lvars-wr(w, header);
      f.stmt-space.wr(w, header);
      pos-4.n4(w.pos - pos-4-next);
   }
}
write-cvar(w:wtr, header:bool) {
   w.n(.cvar-c);
   loop var i = 0; {(.cvar-c) i++} {
      +cvar = .cvar-v[i];
      cvar.include.wr(w);
      cvar.at.wr(w, header);
      cvar.decl.wr(w, header);
      cvar.flags.wr(w);
      if ((cvar.flags & #set-expr) != #0) {
         cvar.expr-set.wr(w, header);
      } else {
         cvar.last-cvar.wr(w);
      }
   }
}
write-gvar(w:wtr, header:bool) {
   w.n(.gvar-c);
   loop var i = 0; {(.gvar-c) i++} {
      +gvar = .gvar-v[i];
      gvar.include.wr(w);
      gvar.at.wr(w, header);
      gvar.decl.wr(w, header);
   }
}
write-enum(w:wtr, header:bool) {
   w.n(.enum-c);
   loop var i = 0; (.enum-c) {
      +e = .enum-v[i++];
      w.n(e.begin-row);
      w.n(e.begin-col);
      w.n(e.end-row);
      w.n(e.end-col);
      e.include.wr(w);
      e.at.wr(w, header);
      e.base-type.wr(w, header);
      e.flags.wr(w);
      if ((e.flags & #real-name) != #0) {
         e.real-name.wr(w, header);
      }
   }
}
write-struct(w:wtr, header:bool) {
   w.n(.struct-c);
   loop var i = 0; (.struct-c) {
      +s = .struct-v[i++];
      w.n1(s.fvar-c);
      w.n(s.begin-row);
      w.n(s.begin-col);
      w.n(s.end-row);
      w.n(s.end-col);
      s.include.wr(w);
      s.at.wr(w, header);
      s.flags.wr(w);
      // 'c.out.printf("write-struct %s\n", s.at.ptr().name.id.str());
      // s.name.wr(w, header);
      loop var j = 0; {(s.fvar-c) j++} {
         s.fvar-v[j].wr(w, header);
      }
      if ((s.flags & #real-name) != #0) {
         s.real-name.wr(w, header);
      }
   }
}
token-name(tok:token):char[] {
   return tok.cp1-name();
}
parse-str-init(max-size:i32);
get-row-col(out-row:i32&, out-col:i32&, end:ref, begin:ref) {
   +row = 1;
   +col = 1;
   var r:rdr+;
   r.ref = begin;
   var r-end:rdr+;
   r-end.ref = end;
   while (r.pos < r-end.pos) {
      if (r.p1[0] == ''\n) {
         row++;
         col = 1;
      } else {
         col++;
      }
      r.pos++;
   }
   out-row = row;
   if (r.p1[0] == ''\n) {
      out-col = col - 1;
   } else {
      out-col = col;
   }
}
parse-string(r:rdr, w:wtr, ending:char, in-data:ref) {
   w.p1[0] = ''\';
   w.p1[1] = r.p1[1];
   w.pos += 2;
   r.pos += 2;
   loop {
      +c = r.p1[0];
      if (c == ''\n) {
         get-row-col(+row, +col, r.ref, in-data);
         'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
         'c.exit(#failure);
      }
      w.p1[0] = c;
      w.pos++;
      r.pos++;
      if (c == ending) {
         return;
      }
   }
}
parse-comment(r:rdr, w:wtr, ending:char, in-data:ref) {
   var r-begin:rdr+;
   r-begin.pos = r.pos;
   r.pos += 2;
   loop {
      +c = r.p1[0];
      if (c == ''\n) {
         get-row-col(+row, +col, r.ref, in-data);
         'c.out.printf("%s:%u:%u: Unterminated comment\n", .input-path, row, col);
         'c.exit(#failure);
      }
      r.pos++;
      if (c == ending) {
         +len = r.pos - r-begin.pos;
         loop (len) {
            w.p1[0] = '' ;
            w.pos++;
         }
         return;
      }
   }
}
{gvar input-path:char[] @real-name(input_path)}
convert-old-to-new(in-data:ref, in-out-size:i32&):ref {
   +in-size = in-out-size;
   var r:rdr+;
   r.ref = in-data;
   if (&&, r.p1[0] == ''{, r.p1[1] == ''g, r.p1[2] == ''l, r.p1[3] == ''c, r.p1[4] == ''\n, r.p1[in-size - 2] == ''}, r.p1[in-size - 1] == ''\n) {
      // remove the {glc and } from head and tail of the file
      r.p1[0] = '' ;
      r.p1[1] = '' ;
      r.p1[2] = '' ;
      r.p1[3] = '' ;
      r.p1[in-size - 2] = '' ;
   }
   var r-end:rdr+;
   r-end.ref = in-data;
   r-end.pos += in-size;
   var w-begin:wtr+;
   w-begin.ref = 'c.malloc(in-size << 1);
   var w:wtr+;
   w.ref = w-begin.ref;
   while (r.pos < r-end.pos) {
      if (&&, r.p1[0] == ''@, r.p1[1] == ''r, r.p1[2] == ''e, r.p1[3] == ''a, r.p1[4] == ''l, r.p1[5] == ''N, r.p1[6] == ''a, r.p1[7] == ''m, r.p1[8] == ''e) {
         // realName -> real-name
         w.p1[0] = ''@;
         w.p1[1] = ''r;
         w.p1[2] = ''e;
         w.p1[3] = ''a;
         w.p1[4] = ''l;
         w.p1[5] = ''-;
         w.p1[6] = ''n;
         w.p1[7] = ''a;
         w.p1[8] = ''m;
         w.p1[9] = ''e;
         w.pos += 10;
         r.pos += 9;
      } elif (&&, r.p1[0] == ''@, r.p1[1] == ''n, r.p1[2] == ''o, r.p1[3] == ''D, r.p1[4] == ''e, r.p1[5] == ''c, r.p1[6] == ''l) {
         // noDecl -> no-decl
         w.p1[0] = ''@;
         w.p1[1] = ''n;
         w.p1[2] = ''o;
         w.p1[3] = ''-;
         w.p1[4] = ''d;
         w.p1[5] = ''e;
         w.p1[6] = ''c;
         w.p1[7] = ''l;
         w.pos += 8;
         r.pos += 7;
      } elif (&&, r.p1[0] == ''@, r.p1[1] == ''n, r.p1[2] == ''o, r.p1[3] == ''B, r.p1[4] == ''o, r.p1[5] == ''d, r.p1[6] == ''y) {
         // noBody -> no-body
         w.p1[0] = ''@;
         w.p1[1] = ''n;
         w.p1[2] = ''o;
         w.p1[3] = ''-;
         w.p1[4] = ''b;
         w.p1[5] = ''o;
         w.p1[6] = ''d;
         w.p1[7] = ''y;
         w.pos += 8;
         r.pos += 7;
      } elif (&&, r.p1[0] == ''`, r.p1[1] == ''s, r.p1[2] == ''i, r.p1[3] == ''z, r.p1[4] == ''e, r.p1[5] == ''O, r.p1[6] == ''f, r.p1[7] == ''[) {
         // :uszOf[:type] -> :type[:usz]
         r.pos += 8;
         var r-type:rdr+;
         r-type.ref = r.ref;
         loop {
            +c = r.p1[0];
            if (c == '']) {
               while (r-type.pos < r.pos) {
                  w.p1[0] = r-type.p1[0];
                  w.pos++;
                  r-type.pos++;
               }
               w.p1[0] = ''[;
               w.p1[1] = ''`;
               w.p1[2] = ''s;
               w.p1[3] = ''i;
               w.p1[4] = ''z;
               w.p1[5] = ''e;
               w.pos += 6;
               break;
            }
            r.pos++;
         }
      } elif (&&, r.p1[0] == ''`, r.p1[1] == ''-, r.p1[2] == '' ) {
         // comment that's only for the older glc
         // but a code for the newer glc
         w.p1[0] = '' ;
         w.p1[1] = '' ;
         w.p1[2] = '' ;
         w.pos += 3;
         r.pos += 3;
      } elif (&&, r.p1[0] == ''\', r.p1[1] == ''\', r.p1[2] == ''`, r.p1[3] == ''~) {
         w.p1[0] = ''\';
         w.p1[1] = ''\';
         w.p1[2] = ''`;
         w.pos += 3;
         r.pos += 4;
      } elif (&&, r.p1[0] == '' , r.p1[1] == ''+, r.p1[2] == ''+) {
         // remove space from increment operator
         w.p1[0] = ''+;
         w.p1[1] = ''+;
         w.pos += 2;
         r.pos += 3;
      } elif (&&, r.p1[0] == '' , r.p1[1] == ''-, r.p1[2] == ''-) {
         // remove space from decrement operator
         w.p1[0] = ''-;
         w.p1[1] = ''-;
         w.pos += 2;
         r.pos += 3;
      } else {
         w.p1[0] = r.p1[0];
         w.pos++;
         r.pos++;
      }
   }
   w.p1[0] = 0;
   var path:char[256];
   'c.sprintf(path, "glc-edit/%s", .input-path);
   if !('c:file.create(++out-fd, path, #write | #truncate, 0o644)) {
      'c.out.printf("Cannot open file for writing: %s\n", path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();
   in-out-size = w.pos - w-begin.pos;
   return w-begin.ref;
}
char-escape-value(c:char):i32;
{gvar lock-path:char[]}
parser-at-exit();
main(arg-c:intc, arg-v:char[][]):intc @main {
   if (false) {
      // preprocess-def("", 0);
      export();
   }
   .id-map.init();
   .include-map.init();
   .at-map.init();
   quick-alloc-init();
   .func-main = #nil;
   .decl-include = #nil;
   if (arg-c != 3) {
      'c.out.printf("Usage: %s [file.cgl] [output.cgl-b]\n", arg-v[0]);
      return 0;
   }
   .input-path = arg-v[1];
   // 'c.out.printf("reading %s\n", .input-path);
   if !('c:fd.open(++in-fd, .input-path, #read)) {
      'c.out.printf("Cannot open file for reading: %s\n", .input-path);
      'c.exit(#failure);
   }
   +lock-path = arg-v[2];
   // .lock-path = lock-path;
   // if (true) {
   //    if !('c:fd.open(++fd, lock-path, #create | #excl)) {
   //       // Can't create output file
   //       'sys.stat(lock-path, +out-stat);
   //       in-fd.stat(+in-stat);
   //       var skip;
   //       "#ifdef __APPLE__";
   //          skip = (||, out-stat.mtimespec.sec > in-stat.mtimespec.sec, (&&, out-stat.mtimespec.sec == in-stat.mtimespec.sec, out-stat.mtimespec.nsec > in-stat.mtimespec.nsec));
   //       "#elif defined(__unix__)";
   //          skip = (||, out-stat.mtim.sec > in-stat.mtim.sec, (&&, out-stat.mtim.sec == in-stat.mtim.sec, out-stat.mtim.nsec > in-stat.mtim.nsec));
   //       "#endif";
   //       if (skip) {
   //          // Skip parsing
   //          'c.out.printf("Skipping parsing of %s because the output file is newer than the input file\n", .input-path);
   //          return 0;
   //       }
   //    } else {
   //       // We created the output file, make sure to unlink it when
   //       // the parser gets parsing error
   //       parser-at-exit();
   //    }
   //    fd.close();
   // }
   +in-size = in-fd.seek(0, #end);
   var in-data:u8[] = 'c.malloc(in-size + 2);
   in-fd.seek(0, #set);
   in-fd.read(in-data, in-size);
   in-data[in-size] = 0;
   in-data[in-size + 1] = 0;
   in-fd.close();

   if (&&, in-data[in-size - 2] == ''\r, in-data[in-size - 1] == ''\n) {
      'c.out.printf("Error reading file '%s' because it uses Windows-style line endings\n", .input-path);
      'c.out.printf("Please convert the line endings to Unix-style line endings\n");
      'c.exit(#failure);
   }
   if (in-data[in-size - 1] != ''\n) {
      'c.out.printf("Error reading file '%s' because it doesn't end with a new line\n", .input-path);
      'c.exit(#failure);
   }
   if (true) { // Process comments
      +preprocess = false;
      // in-data = convert-old-to-new(in-data, in-size);
      var r-end:rdr+;
      r-end.ref = in-data;
      r-end.pos += in-size;
      var r:rdr+;
      r.ref = in-data;
      var new-data = 'c.malloc(in-size + 1);
      var w:wtr+;
      w.ref = new-data;
      // Ignore texts outside the top-level curly braces
      // +indent = 0:i32;
      while (r.pos < r-end.pos) {
         if (r.p1[0] == ''/) {
            if (r.p1[1] == ''/) { // , (||, r.p1[2] == '' , r.p1[2] == ''\t))
               if (r.ref == in-data) {
                  // ok
               } elif (||, r.p1[-1] == '' , r.p1[-1] == ''\t, r.p1[-1] == ''\n) {
                  // ok
               } else {
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: There must be a space or tab before the // comment\n", .input-path, row, col);
                  'c.exit(#failure);
               }
               // comment
               r.pos += 3;
               loop {
                  if (r.p1[0] == ''\n) {
                     break;
                  }
                  r.pos++;
                  if (r.pos >= r-end.pos) {
                     get-row-col(+row, +col, r.ref, in-data);
                     'c.out.printf("%s:%u:%u: Comment did not end with a new line\n", .input-path, row, col);
                     'c.exit(#failure);
                  }
               }
               continue;
            }
         // } elif (r.p1[0] == ''{) {
         //    indent++;
         // } elif (r.p1[0] == ''}) {
         //    if (indent == 0) {
         //       get-row-col(+row, +col, r.ref, in-data);
         //       'c.out.printf("%s:%u:%u: Too much '}' detected\n", .input-path, row, col);
         //       'c.exit(#failure);
         //    }
         //    indent--;
         // } elif (indent == 0) {
         //    if (r.p1[0] == ''\n) {
         //       w.p1[0] = ''\n;
         //       w.pos++;
         //    }
         //    r.pos++;
         //    continue;
         } elif (r.p1[0] == ''\') {
            if (r.p1[1] == ''\') {
               // char
               if (r.p1[2] == ''\\) {
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = ''\\;
                  w.p1[3] = r.p1[3];
                  w.pos += 4;
                  r.pos += 4;
                  continue;
               } else {
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = r.p1[2];
                  w.pos += 3;
                  r.pos += 3;
                  continue;
               }
            } elif (&&, (||, r.p1[2] == '' , r.p1[2] == ''\t), (||, r.p1[1] == ''-, r.p1[1] == ''=)) {
               // string
               w.p1[0] = ''\';
               w.p1[1] = r.p1[1];
               w.p1[2] = r.p1[2];
               w.pos += 3;
               r.pos += 3;
               loop {
                  +c = r.p1[0];
                  w.p1[0] = c;
                  w.pos++;
                  r.pos++;
                  if (c == ''\n) {
                     break;
                  }
                  if (r.pos >= r-end.pos) {
                     get-row-col(+row, +col, r.ref, in-data);
                     'c.out.printf("%s:%u:%u: String did not end with a new line\n", .input-path, row, col);
                     'c.exit(#failure);
                  }
               }
               continue;
               // Codes to check if syntax highlighting for strings are working
               "#if 0";
                  '"hello";
                  '|hello|;
                  ';hello;;
                  '_hello_;
                  '+hello+;
                  '<hello>;
                  '[hello];
                  '{hello};
                  '(hello);
               "#endif";
            } elif (r.p1[1] == ''\") {
               parse-string(r, w, ''\", in-data);
               continue;
            } elif (r.p1[1] == ''|) {
               parse-string(r, w, ''|, in-data);
               continue;
            } elif (r.p1[1] == '';) {
               parse-string(r, w, '';, in-data);
               continue;
            } elif (r.p1[1] == ''_) {
               parse-string(r, w, ''_, in-data);
               continue;
            } elif (r.p1[1] == ''+) {
               parse-string(r, w, ''+, in-data);
               continue;
            } elif (r.p1[1] == ''<) {
               parse-string(r, w, ''>, in-data);
               continue;
            } elif (r.p1[1] == ''[) {
               parse-string(r, w, ''], in-data);
               continue;
            } elif (r.p1[1] == ''{) {
               parse-string(r, w, ''}, in-data);
               continue;
            } elif (r.p1[1] == ''() {
               parse-string(r, w, ''), in-data);
               continue;
            }
         } elif (r.p1[0] == ''\") { // C-string
            w.p1[0] = ''\";
            w.pos++;
            r.pos++;
            loop {
               if (r.p1[0] == ''\n) {
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
                  'c.exit(#failure);
               } elif (r.p1[0] == ''\") {
                  w.p1[0] = ''\";
                  w.pos++;
                  r.pos++;
                  break;
               } elif (r.p1[0] == ''\\) {
                  switch (r.p1[1]) {
                     case (''0) { }
                     case (''\\) { }
                     case (''\") { }
                     case (''\') { }
                     case (''a) { }
                     case (''b) { }
                     case (''f) { }
                     case (''n) { }
                     case (''r) { }
                     case (''t) { }
                     case (''v) { }
                     default {
                        get-row-col(+row, +col, r.ref, in-data);
                        'c.out.printf("%s:%u:%u: Encountered invalid escape sequence in the string: '\\%c'\n", .input-path, row, col, r.p1[1]);
                        'c.exit(#failure);
                     }
                  }
                  w.p1[0] = ''\\;
                  w.p1[1] = r.p1[1];
                  w.pos += 2;
                  r.pos += 2;
               } else {
                  w.p1[0] = r.p1[0];
                  w.pos++;
                  r.pos++;
               }
               if (r.pos >= r-end.pos) {
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
                  'c.exit(#failure);
               }
            }
            continue;
         }
         w.p1[0] = r.p1[0];
         w.pos++;
         r.pos++;
      }
      w.p1[0] = ''\0;
      'c.free(in-data);
      in-data = new-data;
      var w-begin:wtr+;
      w-begin.ref = new-data;
      in-size = w.pos - w-begin.pos;

      // 'c:fd.open(+fd, "out:parsed.glc", #write | #truncate | #create, 0o644);
      // fd.write(in-data, in-size);
      // fd.close();
      // 'c.out.write(in-data, in-size);

      // if (preprocess) {
      //    preprocess-init();
      //    preprocess(in-data, in-size);
      // }
   }
   var r-end:rdr+;
   r-end.ref = in-data;
   r-end.pos += in-size;
   parse-str-init(in-size);

   .id-cap = 64;
   malloc-arr(.id-str-v, .id-cap);
   malloc-arr(.id-len-v, .id-cap);
   .include-cap = 64;
   malloc-arr(.include-str-v, .include-cap);
   malloc-arr(.include-len-v, .include-cap);
   .at-cap = 64:at;
   malloc-arr(.at-v, .at-cap);
   .at-c = 2:at;
   .at-v[0].type = #basic;
   .at-v[0].parent = #nil;
   .at-v[0].name.basic = #root;
   .at-v[1].type = #basic;
   .at-v[1].parent = #nil;
   .at-v[1].name.basic = #relative;
   .func-cap = 32:func;
   malloc-arr(.func-v, .func-cap);
   .struct-cap = 32:struct;
   malloc-arr(.struct-v, .struct-cap);
   .decl-fvar-cap = 32;
   malloc-arr(.decl-fvar-v, .decl-fvar-cap);

   +psr = :parser.alloc();
   :lexer.init(+lex, in-data, in-size);
   +next-row = 1;
   +next-col = 1;
   .row = 1;
   .col = 1;
   var tok:token-data+;
   loop {
      tok.row = next-row;
      tok.col = next-col;
      +t = lex.scan();
      if (true) { // t != #space)
         // when reporting the row and column of tokens, skip the spaces
         +pos = lex.start;
         while (pos < r-end.p1) {
            if (||, pos[0] == '' , pos[0] == ''\t) {
               tok.col++;
            } elif (pos[0] == ''\n) {
               tok.row++;
               tok.col = 1;
            } else {
               break;
            }
            pos++;
         }
      }
      .last-row = .row;
      .last-col = .col;
      .row = tok.row;
      .col = tok.col;
      // 'c.out.printf("%s:%u:%u: token %s\n", .input-path, tok.row, tok.col, t.cgl-name());
      // 'c.out.flush();
      if (&&, t >= #id-colon, t < #id) {
         tok.id = lex.get-id(1, 0);
         .last-token = t;
         psr.parse(t, tok);
      } else {
         switch (t) {
            case (#char1) {
               var r:rdr+;
               r.ref = lex.start;
               tok.id = r.p1[2];
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#char2) {
               var r:rdr+;
               r.ref = lex.start;
               tok.id = char-escape-value(r.p1[3]);
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#space-at-real-name-str) {
               // find the '@' character and start counting from there
               var r-start:rdr+;
               r-start.ref = lex.start;
               +start = 11;
               loop {
                  start++;
                  r-start.pos++;
                  if (r-start.p1[0] == ''@) {
                     break;
                  }
               }
               tok.id = lex.get-id(start, 1);
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#num-dec) {
               tok.id = lex.get-u32-dec();
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#num-oct) {
               tok.id = lex.get-u32-oct();
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#include) {
               tok.id = lex.get-include();
               .last-token = t;
               psr.parse(t, tok);
            }
            case (#id) {
               tok.id = lex.get-id(0, 0);
               if (lex.cursor[0] == ''() {
                  t = #id-lparen;
               }
               .last-token = t;
               psr.parse(t, tok);
            }
            default {
               .last-token = t;
               psr.parse(t, tok);
            }
         }
      }
      if (t == #end) { break}
      +pos = lex.start;
      while (pos < lex.cursor) {
         if ((pos[0] & 128) == 0) {
            if (pos[0] == ''\n) {
               next-row++;
               next-col = 1;
            } else {
               next-col++;
            }
         }
         pos++;
      }
   }
   .last-token = #nil;
   psr.parse(#nil, tok);
   psr.free();
   // 'c.out.printf("parsing finished\n");
   var w-begin:wtr+;
   w-begin.ref = quick-alloc((in-size << 2) + 1024);
   var w:wtr+;
   w.ref = w-begin.ref;
   w.n(.id-c);
   loop var i = 0; {(.id-c) i++} {
      w.n1(.id-len-v[i]);
      w.copy(.id-str-v[i], .id-len-v[i]);
      w.n1(0);
   }
   +id-bit8-c = (.id-c + 7) >> 3;
   malloc-arr(.id-in-header-v, id-bit8-c);
   malloc-arr(.id-in-header-idx-v, .id-c);
   malloc-arr(.id-in-header-id-v, .id-c);

   w.n(.include-c);
   // 'c.out.printf("There are %u includes\n", .include-c);
   loop var i = 0; {(.include-c) i++} {
      w.n1(.include-len-v[i]);
      w.copy(.include-str-v[i], .include-len-v[i]);
      w.n1(0);
   }

   +at-bit8-c = (.at-c + 7) >> 3;
   malloc-arr(.at-in-header-v, at-bit8-c);
   malloc-arr(.at-in-header-idx-v, .at-c);
   malloc-arr(.at-in-header-at-v, .at-c);

   w.n(.at-c);
   loop var i = 0; {(.at-c) i++} {
      +at = .at-v[i];
      at.type.wr(w);
      if (at.type == #basic) {
         at.name.basic.wr(w);
      } else {
         at.parent.wr(w, false);
         at.name.id.wr(w, false);
      }
   }

   write-cvar(w, false);
   write-gvar(w, false);
   write-enum(w, false);
   write-struct(w, false);
   write-func(w, false);
   
   var out-path:char[] = 'c.malloc('c.strlen(lock-path) + 4 + 1);
   'c.sprintf(out-path, "%s.tmp", lock-path);
   +out-path-len = 'c.strlen(out-path);
   if !('c:fd.open(++out-fd, out-path, #create | #truncate | #write, 0o644)) {
      'c.out.printf("Cannot open file for writing: %s\n", out-path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();

   w.ref = w-begin.ref;
   w.n(.id-in-header-c);
   loop var j = 0; {(.id-in-header-c) j++} {
      +i = .id-in-header-id-v[j];
      w.n1(.id-len-v[i]);
      w.copy(.id-str-v[i], .id-len-v[i]);
      w.n1(0);
   }
   w.n(.include-c);
   loop var i = 0; {(.include-c) i++} {
      w.n1(.include-len-v[i]);
      w.copy(.include-str-v[i], .include-len-v[i]);
      w.n1(0);
   }
   w.n(.at-in-header-c);
   loop var j = 0; {(.at-in-header-c) j++} {
      +i = .at-in-header-at-v[j];
      +at = .at-v[i];
      at.type.wr(w);
      if (at.type == #basic) {
         at.name.basic.wr(w);
      } else {
         at.parent.wr-header(w);
         at.name.id.wr-header(w);
      }
   }
   write-cvar(w, true);
   write-gvar(w, true);
   write-enum(w, true);
   write-struct(w, true);
   write-func(w, true);

   out-path[out-path-len - 5] = ''h;
   if !('c:fd.open(out-fd, out-path, #create | #truncate | #write, 0o644)) {
      'c.out.printf("Cannot open file for writing: %s\n", out-path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();
   var final-path:char[512];
   out-path[out-path-len - 5] = ''b;
   'c.memcpy(final-path, out-path, out-path-len - 4);
   final-path[out-path-len - 4] = 0;
   'c.rename(out-path, final-path);
   .lock-path = null; // Do not unlink lock-path at exit
   out-path[out-path-len - 5] = ''h;
   'c.memcpy(final-path, out-path, out-path-len - 4);
   final-path[out-path-len - 4] = 0;
   'c.rename(out-path, final-path);
   return 0;
}
 

}
