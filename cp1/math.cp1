using Cp1 = Cp1;
using (Cp1) {
enum Math[#add, #sub, #mul, #div, #lshift, #rshift, #and, #or, #xor]:u8 {
   wr(e:this, w:Wtr) @inline {
      w.n1(e);
   }
   rd(e:this&, r:Rdr) @inline {
      e = r.n1():Math;
   }
}
expr-math(left:ExprI, right:ExprI, type:Math):ExprI {
   quick-alloc-one(+(e:ExprMath));
   +e-idx = expr-push(e.base, #math);
   e.left = left;
   e.right = right;
   e.type = type;
   return e-idx;
}
expr-math-add(expr:ExprI, right:ExprI):ExprI {
   var e:ExprMath = expr.ptr();
   +i = e.item-c++;
   if e.item-cap <= e.item-c {
      +old-cap = e.item-cap;
      grow(e.item-cap, e.item-c);
      realloc(e.item-v, e.item-cap, old-cap);
   }
   +item = e.item-v[i];
   item.expr = right;
   return expr;
}
using (ExprI) {
   try-deduce-math(expr:Expr, at:At) @case.try-deduce() @inline {
      var e:ExprMath = expr;
      e.left.try-deduce(at);
      e.right.try-deduce(at);
      loop i = 0; e.item-c; i++ {
         e.item-v[i].expr.try-deduce(at);
      }
   }
   wr-math(expr:Expr, w:Wtr, header:bool) @case.wr() @inline {
      var e:ExprMath = expr;
      e.left.wr(w, header);
      e.right.wr(w, header);
      e.type.wr(w);
      w.n1(e.item-c);
      loop i = 0; e.item-c; i++ {
         e.item-v[i].expr.wr(w, header);
      }
   }
   rd-math(e-idx:ExprI, r:Rdr) @case.rd() @inline {
      quick-alloc-one(+(e:ExprMath));
      e-idx.set(e.base, #math);
      e.left.rd(r);
      e.right.rd(r);
      e.type.rd(r);
      +item-c = r.n1();
      if item-c > 0 {
         e.item-c = item-c;
         quick-alloc-arr(e.item-v, item-c);
         loop i = 0; e.item-c; i++ {
            e.item-v[i].expr.rd(r);
         }
      }
   }
   write-math(expr:Expr) @case.write() @inline {
      var e:ExprMath = expr;
      switch e.type {
         case #add {
            e.left.write-value(e.left-val);
            .out.printf(" + ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" + ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #sub {
            e.left.write-value(e.left-val);
            .out.printf(" - ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" - ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #mul {
            e.left.write-value(e.left-val);
            .out.printf(" * ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" * ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #div {
            e.left.write-value(e.left-val);
            .out.printf(" / ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" / ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #lshift {
            e.left.write-value(e.left-val);
            .out.printf(" << ");
            e.right.write-value(e.right-val);
         }
         case #rshift {
            e.left.write-value(e.left-val);
            .out.printf(" >> ");
            e.right.write-value(e.right-val);
         }
         case #and {
            e.left.write-value(e.left-val);
            .out.printf(" & ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" & ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #or {
            e.left.write-value(e.left-val);
            .out.printf(" | ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" | ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
         case #xor {
            e.left.write-value(e.left-val);
            .out.printf(" ^ ");
            e.right.write-value(e.right-val);
            loop i = 0; e.item-c; i++ {
               .out.printf(" ^ ");
               e.item-v[i].expr.write-value(e.item-v[i].val);
            }
         }
      }
   }
   value-math(e:this, reff:i8, paren:bool, v:Value, ok:bool&) @case.value() @inline {
      var expr:ExprMath = e.ptr();
      // if expr.left.value(1, paren, v) == false {
      //    return;
      // }
      if !expr.left.value(1, paren, v) { return }
      // +left = e.left.type();
      // +right = e.right.type();
      // +left-size = left.real.basicType.to()Size;
      // if left-size > 0 {
      //    if left-size > right.real.basicType.to()struct Size[ 
      //       v.decl = left,
      //    ]
      // }
      v.paren = paren;
      v.reff = reff;
      ok = true;
   }
   type-math(expr:Expr, at:At&) @case.type() @inline {
      var e:ExprMath = expr;
      at = e.left.type();
   }
   process-math(expr:Expr, ok:bool&) @case.process() @inline {
      var e:ExprMath = expr;
      if !e.left.value(1, true, e.left-val) {
         return;
      }
      e.right.try-deduce(e.left-val.type);
      if !e.right.value(1, true, e.right-val) {
         return;
      }
      loop i = 0; e.item-c; i++ {
         +item = e.item-v[i];
         if !item.expr.value(1, true, item.val) { return }
      }
      ok = true;
   }
}
 

}
