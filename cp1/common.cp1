using 'cp1 = :cp1;
using 'c = :stdc;
{at(:cp1)
:at-map(data:u64[(#hash-table-size + 7) >> 3]) {
   init(m:this);
   get-or-insert(m:this, parent:at, type:name-type, name:id, val:i32):i32;
}
:map(data:u64[(#hash-table-size + 7) >> 3]) {
   init(m:this);
   get-or-insert(m:this, str:char[], len:u8, val:i32):i32;
}
{gvar id-map:map+}
{gvar include-map:map+}
{gvar at-map:at-map+}
:struct-data(
#if(compiler)
   file:file,
#endif
   begin-row:i32,
   begin-col:i32,
   end-row:i32,
   end-col:i32,
   include:include,
   at:at,
   flags:struct-flags,
   real-name:id,
#if(compiler)
   method-c:i32,
   method-cap:i32,
   method-v:func[],
#endif
   fvar-c:u32,
   fvar-v:fvar-data+[0],
);
:stmt-if(
   base:stmt+,
   not:bool,
   expr:expr-i,
#if(compiler)
   val:value+
#endif
);
:stmt-if-elif(
   base:stmt+,
   not:bool,
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
);
:stmt-if-else(
   base:stmt+,
);
:stmt-if-end(
   base:stmt+,
);
:stmt-switch(
   base:stmt+,
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
   cases:expr-i,
#if(compiler)
   case-func-c:u32,
   case-func-v:stmt-switch-case-func+[],
#endif
);
:stmt-case-item(
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
);
{at(:lvar)
#if(compiler)
   ptr(l:this):lvar-data @inline {
      return .ctx-func.lvar-v[l];
   }
   name(l:this):id @inline {
      return l.ptr().decl.name;
   }
#endif
#if(parser)
   ptr(l:this):lvar-data @inline {
      return .ctx-func.lvar-v[l];
   }
   name(l:this):id @inline {
      return l.ptr().decl.name;
   }
#endif
}
:enum-data(
#if(compiler)
   file:file,
#endif
   begin-row:i32,
   begin-col:i32,
   end-row:i32,
   end-col:i32,
   include:include,
   at:at,
   base-type:at,
   flags:enum-flags,
   real-name:id,
#if(compiler)
   method-c:i32,
   method-cap:i32,
   method-v:func[],
#endif
);
:expr-compare(
   base:expr+,
   left:expr-i,
   right:expr-i,
   type:compare,
#if(compiler)
   left-val:value+,
   right-val:value+,
#endif
);
:expr-assign(
   base:expr+,
   left:expr-i,
   right:expr-i,
   type:assign,
#if(compiler)
   left-val:value+,
   right-val:value+,
#endif
);
:expr-index(
   base:expr+,
   left:expr-i,
   right:expr-i,
#if(compiler)
   left-val:value+,
   right-val:value+,
#endif
);
:expr-math-item(
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
);
:expr-math(
   base:expr+,
   left:expr-i,
   right:expr-i,
   type:math,
#if(compiler)
   left-val:value+,
   right-val:value+,
#endif
   item-c:u8,
#if(parser)
   item-cap:u8,
#endif
   item-v:expr-math-item+[],
);
:expr-bools-item(
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
);
:expr-bools(
   base:expr+,
   left:expr-i,
   right:expr-i,
   type:bools,
#if(compiler)
   left-val:value+,
   right-val:value+,
#endif
   item-c:u8,
#if(parser)
   item-cap:u8,
#endif
   item-v:expr-bools-item+[],
);
:expr-fvar(
   base:expr+,
   expr:expr-i,
   member:id,
#if(compiler)
   fvar:fvar,
   val:value+,
#endif
);
:expr-cvar(
   base:expr+,
   at:at,
   name:id,
#if(compiler)
   cvar:cvar,
   try:at,
#endif
);
:expr-ref(
   base:expr+,
   expr:expr-i,
#if(compiler)
   val:value+,
#endif
);
:expr-unary(
   base:expr+,
   expr:expr-i,
   type:unary,
#if(compiler)
   val:value+,
#endif
);
:expr-cast-fast(
   base:expr+,
   expr:expr-i,
   type:at,
#if(compiler)
   val:value+,
#endif
);
:expr-gvar(
   base:expr+,
#if(parser)
   at:at,
   name:id,
#endif
#if(compiler)
   gvar:gvar,
#endif
);
:decl-gvar(
#if(compiler)
   file:file,
#endif
   row:i32,
   col:i32,
   include:include,
   at:at,
   flags:gvar-flags,
   decl:decl-var-data+,
);
:cvar-data(
#if(compiler)
   file:file,
#endif
   row:i32,
   col:i32,
   include:include,
   at:at,
   flags:cvar-flags,
   // real-name:id,
   decl:decl-var-data+,
   expr-set:expr-i,
   last-cvar:cvar,
);
:decl-var-data(
   name:id,
   type:at,
   flags:var-flags,
   real-name:id,
   type-info:type-info+,
   size-c:u8,
   size-expr-v:expr-i[],
#if(compiler)
   size-value-v:value+[],
#endif
);
:carg(
   ref:i8,
   expr:expr-i,
#if(compiler)
   value:value+,
#endif
);
:expr-func(
   base:expr+,
   at:at,
   func-name:id,
#if(compiler)
   func-idx:func,
#endif
   group-c:u8,
   group-v:u8[#expr-carg-group-limit],
   carg-c:u8,
   carg-v:carg+[0],
);
:expr-method(
   base:expr+,
   this:expr-i,
   func-name:id,
#if(compiler)
   func-idx:func,
   this-value:value+,
#endif
   group-c:u8,
   group-v:u8[#expr-carg-group-limit],
   carg-c:u8,
   carg-v:carg+[0],
);
:decl-func(
#if(compiler)
   process-next:func,
   file:file,
#endif
   begin-row:i32,
   begin-col:i32,
   end-row:i32,
   end-col:i32,
   include:include,
   at:at,
   // name:id,
   flags:func-flags,
   real-name:id,
   decl-str:char[],
   decl-len:i32,
   case:id,
   // type:at,
   decl:decl-var-data+,
#if(parser)
   stmt-space:stmt-space,
#endif
#if(compiler)
   stmt-space:stmt-space+,
#endif
//    stmt-c:u32,
// #if(compiler)
//    stmt-cap:u32,
// #endif
//    stmt-v:stmt[],
#if(compiler)
   lvar-c:lvar,
   // lvar-cap:lvar,
   lvar-v:lvar-data+[],
   // lvar-name-v:id[],
   body-file-pos:u32,
#endif
#if(parser)
   lvar-c:lvar,
   lvar-cap:lvar,
   lvar-v:lvar-data[],
#endif
   this-idx:i8,
   this-group:i8,
   group-c:i8,
   group-v:i8[#expr-carg-group-limit],
   farg-c:u8,
   farg-v:farg+[0],
);
{gvar quick-alloc-c:i32}
{gvar quick-alloc-cap:i32}
{gvar quick-alloc-v:ref}
quick-alloc-init() {
   .quick-alloc-cap = 16 * 1024;
   .quick-alloc-v = 'c.malloc(.quick-alloc-cap);
   'c.memset(.quick-alloc-v, 0, .quick-alloc-cap);
}
quick-alloc(size:i32):ref @real-name(qalloc) {
   // +mem = 'c.malloc(size);
   // 'c.memset(mem, 0, size);
   // return mem;
   // snap to :usz
   {if(:ref[:usz] == 8)
      size = (size + 7) & (-1 ^ 7);
   }{else
      size = (size + 3) & (-1 ^ 3);
   }
   {if(size <= (.quick-alloc-cap - .quick-alloc-c))
      {+r:rdr+}
      r.ref = .quick-alloc-v;
      r.pos += .quick-alloc-c;
      .quick-alloc-c += size;
      return r.ref;
   }
   // expand
   grow(.quick-alloc-cap, .quick-alloc-c + size);
   .quick-alloc-v = 'c.malloc(.quick-alloc-cap);
   'c.memset(.quick-alloc-v, 0, .quick-alloc-cap);
   // 'c.out.printf("expanding to %u\n", .quick-alloc-cap);
   .quick-alloc-c = size;
   return .quick-alloc-v;
}
quick-alloc-undo(size:i32) @real-name(qalloc_undo) {
   {if(:ref[:usz] == 8)
      size = (size + 7) & (-1 ^ 7);
   }{else
      size = (size + 3) & (-1 ^ 3);
   }
   .quick-alloc-c -= size;
}
quick-alloc-one(r:ref)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-arr(r:ref, c:i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) * (c))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-plus(r:ref, plus:i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) + plus)>)
   @inline {
   quick-alloc(0);
}
malloc(r:ref)
   @no-body
   @decl('<# r = malloc(sizeof(r[0])); memset(r, 0, sizeof(r[0]))>)
   @inline {
   'c.malloc(0);
}
malloc-arr(r:ref, c:i32)
   @no-body
   @decl('<# r = malloc(sizeof(r[0]) * (c)); memset(r, 0, sizeof(r[0]) * (c))>)
   @inline {
   'c.malloc(0);
}
realloc(r:ref, c:i32, oldc:i32)
   @no-body
   @decl('<# r = realloc(r, sizeof(r[0]) * (c)); memset(r + (oldc), 0, sizeof(r[0]) * ((c) - (oldc)))>)
   @inline {
   'c.realloc(null, 0);
}
{include("num.c")
   grow(cap:i32, c:i32)
      @no-body
      @decl('<# cap = Fpow2gteq((c) + 8)>)
      @inline;
}
{cvar #decl-at-name-limit:i32 = 3}
:at-name(id:id, basic:basic-type-id) @union;
:at-type(struct:struct, enum:enum) @union;
{:at-def[#undefined, #module, #struct, #enum, #basic]:u8}
:at-data(
   type:name-type,
   parent:at,
   name:at-name+,
#if(compiler)
   func-c:i32,
   func-cap:i32,
   func-v:func[],
   gvar-c:i32,
   gvar-cap:i32,
   gvar-v:gvar[],
   cvar-c:i32,
   cvar-cap:i32,
   cvar-v:cvar[],
   decl:at-type+,
   def:at-def,
#endif
   ) {
   init(at:this, type:name-type, parent:at, name:id) {
      at.type = type;
      at.parent = parent;
      at.name.id = name;
      at.func-c = 0;
      at.func-cap = 0;
      at.func-v = null;
      at.gvar-c = 0;
      at.gvar-cap = 0;
      at.gvar-v = null;
      at.decl.struct = #nil;
      at.def = #undefined;
   }
}
{:name-type[#module, #struct-enum, #basic]:u8
   rd(i:this&, r:rdr) @inline {
      i = r.n1():name-type;
   }
   wr(i:this, w:wtr) @inline {
      w.n1(i);
   }
   cp1-name(e:this):char[] @cp1-name;
}
{gvar at-c:at}
{gvar at-cap:at}
{gvar at-v:at-data+[]}
{:at[#nil = -1, #root, #relative]:i32
   finalize(at-i:this, ti:type-info, row:i32, col:i32):bool {
      +at = at-i.ptr();
      {if(at.def == #struct)
         {if(ti.built-in)
            {if(ti.ref-v[0] != 0)
               'c.out.printf("%s:%d:%d: Can't use plus symbol (+) because type '/%s' has reference\n", .ctx-func.file.path(), row, col, at.name.id.str());
               return false;
            }
            ti.ref-v[0] = -1;
         // }{else
         //    {if!(ti.built-in)
         //       'c.err.printf("%s:%d:%d: Missing plus symbol (+) because type '/%s' is a value\n", .ctx-func.file.path(), row, col, at.name.id.str());
         //       return false;
         //    }
         }
      }{else
			{if(ti.built-in)
				'c.out.printf("%s:%d:%d: Can't use plus symbol (+) because type is not a struct\n", .ctx-func.file.path(), row, col);
				return false;
			}
      }
      return true;
   }
   output(at-i:this, file:file, row:i32, col:i32) {
      +at = at-i.ptr();
      {switch(at.type)
         {case(#struct-enum)
            {if(at.def == #struct)
               {if(at.decl.struct == #nil)
                  'c.out.printf("%s:%u:%u: Error, struct '/%s' was not defined\n", file.path(), row, col, at.name.id.str());
                  'c.exit(#failure);
               }
               at.decl.struct.output();
            }{elif(at.def == #enum)
               {if(at.decl.enum == #nil)
                  'c.out.printf("%s:%u:%u: Error, enum '\\%s' was not defined\n", file.path(), row, col, at.name.id.str());
                  'c.exit(#failure);
               }
               at.decl.enum.output();
            }
         }
         {case(#basic)
            {switch(at.name.basic)
               {case(#bool)
                  .include-stdbool = true;
               }
               {case(#usz)
                  .include-stddef = true;
               }
               {case(#i8)
                  .include-stdint = true;
               }
               {case(#u8)
                  .include-stdint = true;
               }
               {case(#i16)
                  .include-stdint = true;
               }
               {case(#u16)
                  .include-stdint = true;
               }
               {case(#i32)
                  .include-stdint = true;
               }
               {case(#u32)
                  .include-stdint = true;
               }
               {case(#i64)
                  .include-stdint = true;
               }
               {case(#u64)
                  .include-stdint = true;
               }
            }
         }
      }
   }
	write-type-info(td:this, ti:type-info, add:i32):bool {
		ti.count();
      td.write-type();
      +s = td.count-stars0(ti) + add;
      {if(s > 0)
         .out.write("********************************", s);
      }
		return true;
	}
	count-stars(td:this, ti:type-info):i32 {
		{if(td == #root)
			return td.count-stars0(ti) + 1;
		}{else
			return td.count-stars0(ti);
		}
	}
   pointer(td:this):i32 @inline {
      {if(td.ptr().def == #struct)
         return 1;
      }{else
         return 0;
      }
   }
	count-stars0(td:this, ti:type-info):i32 {
      return ti.star-c + td.pointer();
	}
   write-type(td:this):bool {
      td.write();
// 	{if(td.typeType == #value)
// 		{if(td.real.baseDecl == null)
// 			+loc = td.location;
// 			'c.err.printf("%s:%d:%d: base type was null\n", loc.path, loc.row, loc.col);
// 			return false;
// 		}
// 		return td.real.baseDecl.write()Type(t);
// 	}
// 	{if(td.real.basicType == #none)
// 		{if(td.real.typeDef)
// 		}{else
// 			{if(:Config.target == #c)
// 				{if(td.real.is-union())
// 					t.write("union "#);
// 				}{else
// 					t.write("struct "#);
// 				}
// 			}
// 		}
// 		td.write(t);
// 	}{else
// 		td.write(t);
// 	}
   	return true;
   }
   ptr(i:this):at-data @inline {
      return .at-v[i];
   }
   rd(i:this&, r:rdr) @inline {
      +idx = (r.n() - 1):at;
      {if(idx == #nil)
         i = #nil;
      }{else
         i = .at-table[idx];
      }
   }
   put-to-header(at:this) {
      {if((.at-in-header-v[at >> 3] & (1 << (at & 7))) == 0)
         .at-in-header-v[at >> 3] |= 1 << (at & 7);
         .at-in-header-idx-v[at] = .at-in-header-c;
         .at-in-header-at-v[.at-in-header-c++] = at;
         {if(&&, at != #root, at != #relative)
            at.ptr().parent.put-to-header();
         }
      }
   }
   wr-header(id:this, w:wtr) @inline {
      {if(id == #nil)
         w.n(0);
      }{else
         w.n(1 + .at-in-header-idx-v[id]);
      }
   }
   wr(at:this, w:wtr, header:bool) @inline {
      {if(at == #nil)
         w.n(0);
      }{else
         {if(header)
            w.n(1 + .at-in-header-idx-v[at]);
         }{else
            w.n(1 + at);
            at.put-to-header();
         }
      }
   }
   write(at-idx:this) {
      +at = at-idx.ptr();
      {switch(at.type)
         {case(#module)
            {if(at.parent != #root) at.parent.write-space()}
            .out.printf("_M%s", at.name.id.c-name());
         }
         {case(#struct-enum)
            {if(at.def == #struct)
               +t-idx = at.decl.struct;
               +t = t-idx.ptr();
               {if(t-idx != #nil)
                  {if((t.flags & #real-name) != #0)
                     {if(t.real-name == #nil)
                        {if((t.flags & #union) != #0)
                           .out.printf("union %s", at.name.id.c-name());
                        }{else
                           .out.printf("struct %s", at.name.id.c-name());
                        }
                     }{else
                        {if((t.flags & #union) != #0)
                           .out.printf("union %s", t.real-name.str());
                        }{else
                           .out.printf("struct %s", t.real-name.str());
                        }
                     }
                     return;
                  }
               }
               {if((t.flags & #union) != #0)
                  .out.printf("union ");
               }{else
                  .out.printf("struct ");
               }
               {if(at.parent != #root) at.parent.write-space()}
               .out.printf("_N%s", at.name.id.c-name());
            }{elif(at.def == #enum)
               +t-idx = at.decl.enum;
               {if(t-idx != #nil)
                  +t = t-idx.ptr();
                  {if((t.flags & #real-name) != #0)
                     .out.printf("%s", t.real-name.str());
                     return;
                  }
               }
               {if(at.parent != #root) at.parent.write-space()}
               .out.printf("_N%s", at.name.id.c-name());
            }
         }
         {case(#basic)
            {switch(at.name.basic)
               {case(#ref)
                  .out.printf("void*");
               }
               {case(#bool)
                  .out.printf("bool");
               }
               {case(#char)
                  .out.printf("char");
               }
               {case(#intc)
                  .out.printf("int");
               }
               {case(#i8)
                  .out.printf("int8_t");
               }
               {case(#u8)
                  .out.printf("uint8_t");
               }
               {case(#i16)
                  .out.printf("int16_t");
               }
               {case(#u16)
                  .out.printf("uint16_t");
               }
               {case(#i32)
                  .out.printf("int32_t");
               }
               {case(#u32)
                  .out.printf("uint32_t");
               }
               {case(#i64)
                  .out.printf("int64_t");
               }
               {case(#u64)
                  .out.printf("uint64_t");
               }
               {case(#isz)
                  .out.printf("ssize_t");
               }
               {case(#usz)
                  .out.printf("size_t");
               }
               {case(#f32)
                  .out.printf("float");
               }
               {case(#f64)
                  .out.printf("double");
               }
            }
         }
      }
   }
   write-space(at-idx:this) {
      +at = at-idx.ptr();
      {switch(at.type)
         {case(#module)
            {if(at.parent != #root) at.parent.write-space()}
            .out.printf("_M%s", at.name.id.c-name());
         }
         {case(#struct-enum)
            // {if(at.def == #struct)
               {if(at.parent != #root) at.parent.write-space()}
               .out.printf("_N%s", at.name.id.c-name());
            // }{elif(at.def == #enum)
            //    {if(at.parent != #root) at.parent.write-space()}
            //    .out.printf("_E%s", at.name.id.c-name());
            // }
         }
         {case(#basic)
            {switch(at.name.basic)
               {case(#ref)
                  .out.printf("_Tref");
               }
               {case(#bool)
                  .out.printf("_Tbool");
               }
               {case(#char)
                  .out.printf("_Tchar");
               }
               {case(#intc)
                  .out.printf("_Tintc");
               }
               {case(#i8)
                  .out.printf("_Ti8");
               }
               {case(#u8)
                  .out.printf("_Tu8");
               }
               {case(#i16)
                  .out.printf("_Ti16");
               }
               {case(#u16)
                  .out.printf("_Tu16");
               }
               {case(#i32)
                  .out.printf("_Ti32");
               }
               {case(#u32)
                  .out.printf("_Tu32");
               }
               {case(#i64)
                  .out.printf("_Ti64");
               }
               {case(#u64)
                  .out.printf("_Tu64");
               }
               {case(#isz)
                  .out.printf("_Tisz");
               }
               {case(#usz)
                  .out.printf("_Tusz");
               }
               {case(#f32)
                  .out.printf("_Tf32");
               }
               {case(#f64)
                  .out.printf("_Tf64");
               }
            }
         }
      }
   }
}

{:include[#nil = -1, #0]:i32
   str(i:this):char[] @inline {
      return .include-str-v[i];
   }
   wr(i:this, w:wtr) @inline {
      w.n(i + 1);
   }
   rd(i:this&, r:rdr) @inline {
      +idx = (r.n() - 1):include;
      {if(idx == #nil)
         i = #nil;
      }{else
         i = .include-table[idx];
      }
   }
   output(this:this) @inline {
      +num = this:u32;
      +n3 = num >> 3;
      +n17 = 1 << (num & 7);
      {if((.include-is-outputted[n3] & n17) != 0) return}
      .include-is-outputted[n3] |= n17;
      .include-outputted-v[.include-outputted-c++] = this;
   }
}

{gvar id-c:i32}
{gvar id-cap:i32}
{gvar id-str-v:char[][]}
{gvar id-len-v:u8[]}
{gvar id-c-name-v:char[][]}
{gvar include-c:i32}
{gvar include-cap:i32}
{gvar include-str-v:char[][]}
{gvar include-len-v:u8[]}
{gvar func-main:func}
{:id[#nil = -1, #0]:i32
   c-name(id:this):char[] {
      {+c-name:char[] = .id-c-name-v[id]}
      {if(c-name != null) return c-name}
      +len = .id-len-v[id];
      +str = .id-str-v[id];
      c-name = quick-alloc(len + 1);
      .id-c-name-v[id] = c-name;
      {do{+i = 0}{(len) i++}
         {if(str[i] == ''-)
            c-name[i] = ''_;
         }{else
            c-name[i] = str[i];
         }
      }
      c-name[len] = ''\0;
      return c-name;
   }
   str(id:this):char[] @inline {
      return .id-str-v[id];
   }
   len(id:this):u8 @inline {
      return .id-len-v[id];
   }
   wr-header(id:this, w:wtr) @inline {
      {if(id == #nil)
         w.n(0);
      }{else
         w.n(1 + .id-in-header-idx-v[id]);
      }
   }
   wr(id:this, w:wtr, header:bool) @inline {
      {if(id == #nil)
         w.n(0);
      }{else
         {if(header)
            w.n(1 + .id-in-header-idx-v[id]);
         }{else
            w.n(1 + id);
            {if((.id-in-header-v[id >> 3] & (1 << (id & 7))) == 0)
               .id-in-header-v[id >> 3] |= 1 << (id & 7);
               .id-in-header-idx-v[id] = .id-in-header-c;
               .id-in-header-id-v[.id-in-header-c++] = id;
            }
         }
      }
   }
   rd(id:this&, r:rdr) @inline {
      +idx = (r.n() - 1):id;
      {if(idx == #nil)
         id = #nil;
      }{else
         id = .id-table[idx];
      }
   }
}
 

}
