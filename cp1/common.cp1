using Cp1 = Cp1;
using C = LibC;
using Cp1 {
struct AtMap[data:u64[(#hash-table-size + 7) >> 3]] {
   init(m:this);
   get-or-insert(m:this, parent:At, type:NameType, name:Id, val:i32):i32 {
      return m.get-or-insert(parent:u32 | (type:u32 << 30), name, val);
   }
   get-or-insert(m:this, parent-and-type:u32, name:Id, val:i32):i32;
}
struct Map[data:u64[(#hash-table-size + 7) >> 3]] {
   init(m:this);
   get-or-insert(m:this, str:char[], len:u8, val:i32):i32;
}
var id-map:Map+;
var include-map:Map+;
var at-map:AtMap+;
struct StructData[
#if(compile)
   file:File,
#endif
   begin-row:u32,
   begin-col:u32,
   end-row:u32,
   end-col:u32,
   include:Include,
   at:At,
   flags:StructFlags,
   real-name:Id,
#if(compile)
   method-c:i32,
   method-cap:i32,
   method-v:Func[],
#endif
   fvar-c:u32,
   fvar-v:FvarData+[0],
];
struct StmtIf[
   base:Stmt+,
   expr:ExprI,
#if(compile)
   val:Value+
#endif
];
struct StmtIfElif[
   base:Stmt+,
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
];
struct StmtIfElse[
   base:Stmt+,
];
struct StmtIfEnd[
   base:Stmt+,
];
struct StmtSwitch[
   base:Stmt+,
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
   cases:ExprI,
#if(compile)
   case-func-c:u32,
   case-func-v:StmtSwitchCaseFunc+[],
#endif
];
struct StmtCaseItem[
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
];
using Lvar {
#if(compile)
   ptr(l:this):LvarData @inline {
      return .ctx-func.lvar-v[l];
   }
   name(l:this):Id @inline {
      return l.ptr().decl.name;
   }
#endif
#if(parse)
   ptr(l:this):LvarData @inline {
      return .ctx-func.lvar-v[l];
   }
   name(l:this):Id @inline {
      return l.ptr().decl.name;
   }
#endif
}
struct EnumData[
#if(compile)
   file:File,
#endif
   begin-row:u32,
   begin-col:u32,
   end-row:u32,
   end-col:u32,
   include:Include,
   at:At,
   base-type:At,
   flags:EnumFlags,
   soa-field-gvar-at:At,
   soa-field-gvar-id:Id,
   real-name:Id,
#if(compile)
   method-c:i32,
   method-cap:i32,
   method-v:Func[],
#endif
];
struct ExprCompare[
   base:Expr+,
   left:ExprI,
   right:ExprI,
   type:Compare,
#if(compile)
   left-val:Value+,
   right-val:Value+,
#endif
];
struct ExprAssign[
   base:Expr+,
   left:ExprI,
   right:ExprI,
   type:Assign,
#if(compile)
   left-val:Value+,
   right-val:Value+,
#endif
];
struct ExprIndex[
   base:Expr+,
   left:ExprI,
   right:ExprI,
#if(compile)
   left-val:Value+,
   right-val:Value+,
#endif
];
struct ExprMathItem[
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
];
struct ExprMath[
   base:Expr+,
   left:ExprI,
   right:ExprI,
   type:Math,
#if(compile)
   left-val:Value+,
   right-val:Value+,
#endif
   item-c:u8,
#if(parse)
   item-cap:u8,
#endif
   item-v:ExprMathItem+[],
];
struct ExprBoolsItem[
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
];
struct ExprBools[
   base:Expr+,
   left:ExprI,
   right:ExprI,
   type:Bools,
#if(compile)
   left-val:Value+,
   right-val:Value+,
#endif
   item-c:u8,
#if(parse)
   item-cap:u8,
#endif
   item-v:ExprBoolsItem+[],
];
struct ExprFvar[
   base:Expr+,
   expr:ExprI,
   member:Id,
#if(compile)
   fvar:Fvar,
   val:Value+,
#endif
];
struct ExprSoaField[
   base:Expr+,
   expr:ExprI,
   group:Id,
   field:Id,
#if(compile)
   expr2:ExprI,
   val:Value+,
#endif
];
struct ExprCvar[
   base:Expr+,
   at:At,
   name:Id,
#if(compile)
   cvar:Cvar,
   try:At,
#endif
];
struct ExprRef[
   base:Expr+,
   expr:ExprI,
#if(compile)
   val:Value+,
#endif
];
struct ExprUnary[
   base:Expr+,
   expr:ExprI,
   type:Unary,
#if(compile)
   val:Value+,
#endif
];
struct ExprCastFast[
   base:Expr+,
   expr:ExprI,
   type:At,
#if(compile)
   val:Value+,
#endif
];
struct ExprGvar[
   base:Expr+,
#if(parse)
   at:At,
   name:Id,
#endif
#if(compile)
   gvar:Gvar,
#endif
];
struct DeclGvar[
#if(compile)
   file:File,
#endif
   row:u32,
   col:u32,
   include:Include,
   at:At,
   flags:GvarFlags,
   decl:DeclVarData+,
];
struct CvarData[
#if(compile)
   file:File,
#endif
   row:u32,
   col:u32,
   include:Include,
   at:At,
   flags:CvarFlags,
   // real-name:Id,
   decl:DeclVarData+,
   expr-set:ExprI,
   last-cvar:Cvar,
];
struct DeclVarData[
   name:Id,
   type:At,
   flags:VarFlags,
   real-name:Id,
   type-info:TypeInfo+,
   size-c:u8,
   size-expr-v:ExprI[],
#if(compile)
   size-value-v:Value+[],
#endif
];
struct Carg[
   reff:i8,
   expr:ExprI,
#if(compile)
   value:Value+,
#endif
];
struct ExprFunc[
   base:Expr+,
   at:At,
   func-name:Id,
#if(compile)
   func-idx:Func,
#endif
   group-c:u8,
   group-v:u8[#expr-carg-group-limit],
   carg-c:u8,
   carg-v:Carg+[0],
];
struct ExprMetaFunc[
   base:Expr+,
#if(parse)
   at:At,
   func-name:Id,
   lvar:ExprI,
   group-c:u8,
   group-v:u8[#expr-carg-group-limit],
   carg-c:u8,
   carg-v:Carg+[0],
#endif
#if(compile)
   expr-c:u8,
   expr-v:ExprI[0],
#endif
];
struct ExprMethod[
   base:Expr+,
   thiss:ExprI,
   func-name:Id,
#if(compile)
   func-idx:Func,
   this-value:Value+,
#endif
   group-c:u8,
   group-v:u8[#expr-carg-group-limit],
   carg-c:u8,
   carg-v:Carg+[0],
];
struct DeclFunc[
#if(compile)
   process-next:Func,
   file:File,
#endif
   begin-row:u32,
   begin-col:u32,
   end-row:u32,
   end-col:u32,
   include:Include,
   at:At,
   // name:Id,
   flags:FuncFlags,
   real-name:Id,
   decl-str:char[],
   decl-len:i32,
   cas:Id,
   // type:At,
   decl:DeclVarData+,
#if(parse)
   stmt-space:StmtSpace,
#endif
#if(compile)
   stmt-space:StmtSpace+,
#endif
//    stmt-c:u32,
// #if(compile)
//    stmt-cap:u32,
// #endif
//    stmt-v:Stmt[],
#if(compile)
   lvar-c:Lvar,
   // lvar-cap:Lvar,
   lvar-v:LvarData+[],
   // lvar-name-v:Id[],
   body-file-pos:u32,
#endif
#if(parse)
   lvar-c:Lvar,
   lvar-cap:Lvar,
   lvar-v:LvarData[],
#endif
   this-idx:i8,
   this-group:i8,
   group-c:i8,
   group-v:i8[#expr-carg-group-limit],
   farg-c:u8,
   farg-v:Farg+[0],
];
var quick-alloc-c:i32;
var quick-alloc-cap:i32;
var quick-alloc-v:ref;
quick-alloc-init() {
   .quick-alloc-cap = 16 * 1024;
   .quick-alloc-v = C.malloc(.quick-alloc-cap);
   C.memset(.quick-alloc-v, 0, .quick-alloc-cap);
}
quick-alloc(size:i32):ref @real-name(qalloc) {
   // +mem = C.malloc(size);
   // C.memset(mem, 0, size);
   // return mem;
   // snap to usz
   // if ref[usz] == 8 {
      size = (size + 7) & (-1 ^ 7); // align to u64
   // } else {
      // size = (size + 3) & (-1 ^ 3);
   // }
   if size <= (.quick-alloc-cap - .quick-alloc-c) {
      var r:Rdr+;
      r.reff = .quick-alloc-v;
      r.pos += .quick-alloc-c;
      .quick-alloc-c += size;
      return r.reff;
   }
   // expand
   grow(.quick-alloc-cap, .quick-alloc-c + size);
   .quick-alloc-v = C.malloc(.quick-alloc-cap);
   C.memset(.quick-alloc-v, 0, .quick-alloc-cap);
   // C<stdout "expanding to " .quick-alloc-cap ''\n>;
   .quick-alloc-c = size;
   return .quick-alloc-v;
}
quick-alloc-undo(size:i32) @real-name(qalloc_undo) {
   // if ref[usz] == 8 {
      size = (size + 7) & (-1 ^ 7);
   // } else {
      // size = (size + 3) & (-1 ^ 3);
   // }
   .quick-alloc-c -= size;
}
quick-alloc-one(r:ref)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-arr(r:ref, c:i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) * (c))>)
   @inline {
   quick-alloc(0);
}
quick-alloc-plus(r:ref, plus:i32)
   @no-body
   @decl('<# r = qalloc(sizeof(r[0]) + plus)>)
   @inline {
   quick-alloc(0);
}
malloc(r:ref)
   @no-body
   @decl('<# r = malloc(sizeof(r[0])); memset(r, 0, sizeof(r[0]))>)
   @inline {
   C.malloc(0);
}
malloc-arr(r:ref, c:i32)
   @no-body
   @decl('<# r = malloc(sizeof(r[0]) * (c)); memset(r, 0, sizeof(r[0]) * (c))>)
   @inline {
   C.malloc(0);
}
realloc(r:ref, c:i32, oldc:i32)
   @no-body
   @decl('<# r = realloc(r, sizeof(r[0]) * (c)); memset(r + (oldc), 0, sizeof(r[0]) * ((c) - (oldc)))>)
   @inline {
   C.realloc(null, 0);
}
include "num.c" {
   grow(cap:i32, c:i32)
      @decl('<# cap = Fpow2gteq((c) + 8)>);
   grow(c:i32):i32
      @decl('<# Fpow2gteq((c) + 8)>);
}
#decl-at-name-limit:i32 = 3;
union AtName[id:Id, basic:BasicTypeId];
union AtType[structt:Struct, enumm:Enum];
enum AtDef[#undefined, #module, #struct, #enum, #basic]:u8;
struct AtData[
   type:NameType,
   parent:At,
   name:AtName+,
#if(compile)
   func-c:i32,
   func-cap:i32,
   func-v:Func[],
   gvar-c:i32,
   gvar-cap:i32,
   gvar-v:Gvar[],
   cvar-c:i32,
   cvar-cap:i32,
   cvar-v:Cvar[],
   decl:AtType+,
   def:AtDef,
#endif
   ] {
   init(at:this, type:NameType, parent:At, name:Id) {
      at.type = type;
      at.parent = parent;
      at.name.id = name;
      at.func-c = 0;
      at.func-cap = 0;
      at.func-v = null;
      at.gvar-c = 0;
      at.gvar-cap = 0;
      at.gvar-v = null;
      at.decl.structt = #nil;
      at.def = #undefined;
   }
}
enum NameType[#module, #struct-enum, #basic]:u8 {
   rd(i:this&, r:Rdr) @inline {
      i = r.n1():NameType;
   }
   wr(i:this, w:Wtr) @inline {
      w.n1(i:base);
   }
   cp1-name(e:this):char[] @cp1-name;
}
var at-c:At;
var at-cap:At;
var at-v:AtData+[];
enum At[#nil = -1, #root, #relative]:i32 {
   finalize(at-i:this, ti:TypeInfo, row:u32, col:u32):bool {
      +at = at-i.ptr();
      if at.def == #struct {
         if ti.built-in {
            if ti.ref-v[0] != 0 {
               C<stdout .ctx-func.file '': row '': col ": Can't use plus symbol (+) because type '" at.name.id "' has reference\n">;
               return false;
            }
            ti.ref-v[0] = -1;
         // } else {
         //    if !ti.built-in {
         //       C.err.printf("%s:%d:%d: Missing plus symbol (+) because type '/%s' is a value\n", .ctx-func.file.path(), row, col, at.name.id.str());
         //       return false;
         //    }
         }
      } else {
         if ti.built-in {
            C<stdout .ctx-func.file '': row '': col ": Can't use plus symbol (+) because type '" at.name.id "' is not a struct\n">;
            return false;
         }
      }
      return true;
   }
   output(at-i:this, file:File, row:u32, col:u32) {
      +at = at-i.ptr();
      switch at.type {
         case #struct-enum {
            if at.def == #struct {
               if at.decl.structt == #nil {
                  C<stdout file '': row '': col ": Error, struct '/" at.name.id "' was not defined\n">;
                  C.exit(#failure);
               }
               at.decl.structt.output();
            } elif at.def == #enum {
               if at.decl.enumm == #nil {
                  C<stdout file '': row '': col ": Error, enum '\\" at.name.id "' was not defined\n">;
                  C.exit(#failure);
               }
               at.decl.enumm.output();
            }
         }
         case #basic {
            switch at.name.basic {
               case #bool {
                  .include-stdbool = true;
               }
               case #usz {
                  .include-stddef = true;
               }
               case #i8 {
                  .include-stdint = true;
               }
               case #u8 {
                  .include-stdint = true;
               }
               case #i16 {
                  .include-stdint = true;
               }
               case #u16 {
                  .include-stdint = true;
               }
               case #i32 {
                  .include-stdint = true;
               }
               case #u32 {
                  .include-stdint = true;
               }
               case #i64 {
                  .include-stdint = true;
               }
               case #u64 {
                  .include-stdint = true;
               }
            }
         }
      }
   }
   write-type-info(td:this, ti:TypeInfo, add:i32):bool {
      ti.count();
      td.write-type();
      +s = td.count-stars0(ti) + add;
      if s > 0 {
         .out.write("********************************", s);
      }
      return true;
   }
   count-stars(td:this, ti:TypeInfo):i32 {
      if td == #root {
         return td.count-stars0(ti) + 1;
      } else {
         return td.count-stars0(ti);
      }
   }
   pointer(td:this):i32 @inline {
      if td.ptr().def == #struct {
         return 1;
      } else {
         return 0;
      }
   }
   count-stars0(td:this, ti:TypeInfo):i32 {
      return ti.star-c + td.pointer();
   }
   write-type(td:this):bool {
      td.write();
//    if td.typeType == #value {
//       if td.real.baseDecl == null {
//          +loc = td.location;
//          C.err.printf("%s:%d:%d: base type was null\n", loc.path, loc.row, loc.col);
//          return false;
//       }
//       return td.real.baseDecl.write()struct Type[t];
//    }
//    if td.real.basicType == #none {
//       if td.real.typestruct Def[
//       ] else {
//          if :Config.target == #c {
//             if td.real.is-union() {
//                t.write("union "#);
//             } else {
//                t.write("struct "#);
//             }
//          }
//       }
//       td.write(t);
//    } else {
//       td.write(t);
//    }
      return true;
   }
   ptr(i:this):AtData @inline {
      return .at-v[i];
   }
   rd(i:this&, r:Rdr) @inline {
      +idx = (r.n() - 1):At;
      if idx == #nil {
         i = #nil;
      } else {
         i = .at-table[idx];
      }
   }
   put-to-header(at:this) {
      if (.at-in-header-v[at >> 3] & (1 << (at & 7))) == 0 {
         .at-in-header-v[at >> 3] |= 1 << (at & 7);
         .at-in-header-idx-v[at] = .at-in-header-c;
         .at-in-header-at-v[.at-in-header-c++] = at;
         if (&&, at != #root, at != #relative) {
            at.ptr().parent.put-to-header();
         }
      }
   }
   wr-header(id:this, w:Wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + .at-in-header-idx-v[id]);
      }
   }
   wr(at:this, w:Wtr) @inline {
      if at == #nil {
         w.n(0);
      } else {
         w.n(1 + at);
      }
   }
   wr(at:this, w:Wtr, header:bool) @inline {
      if at == #nil {
         w.n(0);
      } else {
         if header {
            w.n(1 + .at-in-header-idx-v[at]);
         } else {
            w.n(1 + at);
            at.put-to-header();
         }
      }
   }
   write(at-idx:this) {
      +at = at-idx.ptr();
      switch at.type {
         case #module {
            if at.parent != #root { at.parent.write-space() }
            .out.printf("_M%s", at.name.id.c-name());
         }
         case #struct-enum {
            if at.def == #struct {
               +t-idx = at.decl.structt;
               +t = t-idx.ptr();
               if t-idx != #nil {
                  if (t.flags & #real-name) != #0 {
                     if t.real-name == #nil {
                        if (t.flags & #union) != #0 {
                           .out.printf("union %s", at.name.id.c-name());
                        } else {
                           .out.printf("struct %s", at.name.id.c-name());
                        }
                     } else {
                        if (t.flags & #union) != #0 {
                           .out.printf("%s", t.real-name.str());
                        } else {
                           .out.printf("%s", t.real-name.str());
                        }
                     }
                     return;
                  }
               }
               if (t.flags & #union) != #0 {
                  .out.printf("union ");
               } else {
                  .out.printf("struct ");
               }
               if at.parent != #root { at.parent.write-space() }
               .out.printf("_N%s", at.name.id.c-name());
            } elif at.def == #enum {
               +t-idx = at.decl.enumm;
               if t-idx != #nil {
                  +t = t-idx.ptr();
                  if (t.flags & #real-name) != #0 {
                     .out.printf("%s", t.real-name.str());
                     return;
                  }
               }
               if at.parent != #root { at.parent.write-space() }
               .out.printf("_N%s", at.name.id.c-name());
            }
         }
         case #basic {
            switch at.name.basic {
               case #ref {
                  .out.printf("void*");
               }
               case #bool {
                  .out.printf("bool");
               }
               case #char {
                  .out.printf("char");
               }
               case #intc {
                  .out.printf("int");
               }
               case #i8 {
                  .out.printf("int8_t");
               }
               case #u8 {
                  .out.printf("uint8_t");
               }
               case #i16 {
                  .out.printf("int16_t");
               }
               case #u16 {
                  .out.printf("uint16_t");
               }
               case #i32 {
                  .out.printf("int32_t");
               }
               case #u32 {
                  .out.printf("uint32_t");
               }
               case #i64 {
                  .out.printf("int64_t");
               }
               case #u64 {
                  .out.printf("uint64_t");
               }
               case #isz {
                  .out.printf("ssize_t");
               }
               case #usz {
                  .out.printf("size_t");
               }
               case #f32 {
                  .out.printf("float");
               }
               case #f64 {
                  .out.printf("double");
               }
            }
         }
      }
   }
   write-space(at-idx:this) {
      +at = at-idx.ptr();
      switch at.type {
         case #module {
            if at.parent != #root { at.parent.write-space() }
            .out.printf("_M%s", at.name.id.c-name());
         }
         case #struct-enum {
            // if at.def == #struct {
               if at.parent != #root { at.parent.write-space() }
               .out.printf("_N%s", at.name.id.c-name());
            // } elif at.def == #enum {
            //    if at.parent != #root { at.parent.write-space() }
            //    .out.printf("_E%s", at.name.id.c-name());
            // }
         }
         case #basic {
            switch at.name.basic {
               case #ref {
                  .out.printf("_Tref");
               }
               case #bool {
                  .out.printf("_Tbool");
               }
               case #char {
                  .out.printf("_Tchar");
               }
               case #intc {
                  .out.printf("_Tintc");
               }
               case #i8 {
                  .out.printf("_Ti8");
               }
               case #u8 {
                  .out.printf("_Tu8");
               }
               case #i16 {
                  .out.printf("_Ti16");
               }
               case #u16 {
                  .out.printf("_Tu16");
               }
               case #i32 {
                  .out.printf("_Ti32");
               }
               case #u32 {
                  .out.printf("_Tu32");
               }
               case #i64 {
                  .out.printf("_Ti64");
               }
               case #u64 {
                  .out.printf("_Tu64");
               }
               case #isz {
                  .out.printf("_Tisz");
               }
               case #usz {
                  .out.printf("_Tusz");
               }
               case #f32 {
                  .out.printf("_Tf32");
               }
               case #f64 {
                  .out.printf("_Tf64");
               }
            }
         }
      }
   }
}

enum Include[#nil = -1, #0]:i32 {
   str(i:this):char[] @inline {
      return .include-str-v[i];
   }
   wr(i:this, w:Wtr) @inline {
      w.n(i:base + 1);
   }
   rd(i:this&, r:Rdr) @inline {
      +idx = (r.n() - 1):Include;
      if idx == #nil {
         i = #nil;
      } else {
         i = .include-table[idx];
      }
   }
   output(thiss:this) @inline {
      +num = thiss:u32;
      +n3 = num >> 3;
      +n17 = 1 << (num & 7);
      if (.include-is-outputted[n3] & n17) != 0 { return }
      .include-is-outputted[n3] |= n17;
      .include-outputted-v[.include-outputted-c++] = thiss;
   }
}

var id-c:i32;
var id-cap:i32;
var id-str-v:char[][];
var id-len-v:u8[];
var id-c-name-v:char[][];
var include-c:i32;
var include-cap:i32;
var include-str-v:char[][];
var include-len-v:u8[];
var func-main:Func;
enum Id[#nil = -1, #0]:i32 {
   stdout(id:this, so:C.Stdout) @inline {
      C.stdout-bytes(id.str(), id.len());
   }
   c-name(id:this):char[] {
      var c-name:char[] = .id-c-name-v[id];
      if c-name != null { return c-name }
      +len = .id-len-v[id];
      +str = .id-str-v[id];
      c-name = quick-alloc(len + 1);
      .id-c-name-v[id] = c-name;
      loop i = 0; len; i++ {
         if str[i] == ''- {
            c-name[i] = ''_;
         } else {
            c-name[i] = str[i];
         }
      }
      c-name[len] = ''\0;
      return c-name;
   }
   str(id:this):char[] @inline {
      return .id-str-v[id];
   }
   len(id:this):u8 @inline {
      return .id-len-v[id];
   }
   wr-header(id:this, w:Wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + .id-in-header-idx-v[id]);
      }
   }
   wr(id:this, w:Wtr) @inline {
      if id == #nil {
         w.n(0);
      } else {
         w.n(1 + id);
      }
   }
   wr(id:this, w:Wtr, header:bool) @inline {
      if id == #nil {
         w.n(0);
      } else {
         if header {
            w.n(1 + .id-in-header-idx-v[id]);
         } else {
            w.n(1 + id);
            if (.id-in-header-v[id >> 3] & (1 << (id & 7))) == 0 {
               .id-in-header-v[id >> 3] |= 1 << (id & 7);
               .id-in-header-idx-v[id] = .id-in-header-c;
               .id-in-header-id-v[.id-in-header-c++] = id;
            }
         }
      }
   }
   rd(id:this&, r:Rdr) @inline {
      +idx = (r.n() - 1):Id;
      if idx == #nil {
         id = #nil;
      } else {
         id = .id-table[idx];
      }
   }
}
 

}
