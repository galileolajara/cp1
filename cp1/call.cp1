using Cp1 = Cp1;
using C = LibC;
using Cp1 {
print-type(at-i:At, info:TypeInfo) {
   +at = at-i.ptr();
   if at.type == #basic {
      C<stdout "basic type "; at.name.basic.cp1-name(); ", star-c "; info.star-c; ''\n>;
   } else {
      C<stdout "custom type "; at.name.id; ", star-c "; info.star-c; ''\n>;
   }
}
compatible(src:At, src-c:u8, des:At, des-c:u8):bool {
   if src == des { return true }
   if (src >= basic-type(#char)) && (src <= basic-type(#usz)) {
      if (des >= basic-type(#char)) && (des <= basic-type(#usz)) {
         return true;
      }
   }
   if des == basic-type(#ref) {
      if src-c > 0 {
         return true;
      }
   }
   if src == basic-type(#ref) {
      if des-c > 0 {
         return true;
      }
   }
   return false;
}
farg-process(e:ExprI, ca-ref:i8, ca-value:Value, fd-arg:DeclVarData, base-at:At, arg-num:i32):bool {
   +ce = e.ptr();
   var r:i32;
   if ca-ref != 0 {
      r = 1 + ca-ref;
   } else {
      r = 1;
      r += fd-arg.type-info.ref-v[fd-arg.type-info.array-c]:i32;
   }
   // C<stdout "r "; r; ", "; j; '' ; fd-arg.type-info.array-c; '' ; fd-arg.type-info.ref-v[fd-arg.type-info.array-c]; ''\n>;
   if ce.type == #lvar {
      var ve:ExprLvar = ce;
      +lvar = ve.lvar.ptr();
      +vd = lvar.decl;
      if vd.type == #nil {
         if (lvar.flags & #set-expr) == #0 {
            // if vd.type-info.array-c != fd-arg.type-info.array-c {
            //    C.err.printf("%s:%u:%u: Type deduction failed for lvar '%s', array dimension mismatch\n", .ctx-func.file.path(), lvar.row, lvar.col, vd.name.str());
            //    return false;
            // }
            +parent = fd-arg.type.ptr().parent.ptr();
            if (parent.type == #basic) && (parent.name.basic == #relative) {
               C<stdout "farg-process without processing farg first\n">;
               C.exit(#failure);
            }
            vd.type = fd-arg.type;
            vd.type-info.init();
            vd.type-info.copy-from(fd-arg.type-info);
            if fd-arg.type-info.built-in {
               vd.type-info.built-in = true;
               vd.type-info.ref-v[0] = ''\0;
            } elif vd.type-info.ref-v[0] + vd.type.pointer() {
               vd.type-info.ref-v[vd.type-info.array-c] -= 1:char;
               vd.type-info.star-c -= 1;
            }
         }
      }
   }
   // fd-arg.validate(base-at);
   e.try-deduce(fd-arg.type);
   if !e.value(r, false, ca-value) { return false }
   if !compatible(ca-value.type, ca-value.info.star-c + ca-value.type.pointer(), fd-arg.type, fd-arg.type-info.star-c + fd-arg.type.pointer()) {
      C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; ": Type mismatch for the function argument ">;
      if arg-num == -1 {
         C<stdout "'this'\n">;
      } else {
         C<stdout ''#; (arg-num + 1):u32; ''\n>;
      }
      // print-type(ca-value.type, ca-value.info);
      // print-type(fd-arg.type, fd-arg.type-info);
      return false;
   }
   return true;
}
using ExprI {
   value-func(e:this, reff:i32, paren:bool, v:Value, ok:bool&) @case.value() @inline {
      var expr:ExprFunc = e.ptr();
      +f = expr.func-idx.ptr();
      v.set(reff, paren, f.decl.type, f.decl.type-info);
      if v.reff == 1 {
         v.paren = false;
      }
      ok = true;
   }
   type-func(expr:Expr, at:At&) @case.type() @inline {
      var e:ExprFunc = expr;
      at = e.func-idx.ptr().decl.type;
   }
   value-method(e:this, reff:i32, paren:bool, v:Value, ok:bool&) @case.value() @inline {
      var expr:ExprMethod = e.ptr();
      +f = expr.func-idx.ptr();
      v.set(reff, paren, f.decl.type, f.decl.type-info);
      if v.reff == 1 {
         v.paren = false;
      }
      ok = true;
   }
   type-method(expr:Expr, at:At&) @case.type() @inline {
      var e:ExprMethod = expr;
      at = e.func-idx.ptr().decl.type;
   }
   write-method(expr:Expr) @case.write() @inline {
      var e:ExprMethod = expr;
      +f = e.func-idx.ptr();
      f.write();
      .out.printf("(");
      +first = true;
      +i = 0;
      loop ; f.this-idx; i++ {
         if first {
            first = false;
         } else {
            .out.printf(", ");
         }
         +ca = e.carg-v[i];
         ca.expr.write-value(ca.value);
      }
      if first {
         first = false;
      } else {
         .out.printf(", ");
      }
      e.thiss.write-value(e.this-value);
      loop ; e.carg-c - f.this-idx; i++ {
         .out.printf(", ");
         +ca = e.carg-v[i];
         ca.expr.write-value(ca.value);
      }
      .out.printf(")");
   }
   wr-method(expr:Expr, w:Wtr, header:bool) @case.wr() @inline {
      var e:ExprMethod = expr;
      e.thiss.wr(w, header);
      e.func-name.wr(w, header);
      w.n1(e.group-c);
      loop i = 0; e.group-c; i++ {
         w.n1(e.group-v[i]);
      }
      w.n1(e.carg-c);
      loop i = 0; e.carg-c; i++ {
         e.carg-v[i].expr.wr(w, header);
      }
   }
   rd-method(e-idx:ExprI, r:Rdr) @case.rd() @inline {
      ExprI.rd(+this-expr, r);
      Id.rd(+func-name, r);
      +group-c = r.n1();
      var group-v:u8[#expr-carg-group-limit];
      loop i = 0; group-c; i++ {
         group-v[i] = r.n1();
      }
      +carg-c = r.n1();
      var carg-v:ExprI[256];
      loop i = 0; carg-c; i++ {
         carg-v[i].rd(r);
      }
      set-method(e-idx, this-expr, func-name, group-c, group-v, carg-c, carg-v);
   }
   set-method(e-idx:ExprI, this-expr:ExprI, func-name:Id, group-c:u8, group-v:u8[], carg-c:u8, carg-v:ExprI[]) {
      quick-alloc-plus(+(e:ExprMethod), Carg[usz] * carg-c);
      e-idx.set(e.base, #method);
      e.thiss = this-expr;
      e.func-name = func-name;
      e.group-c = group-c;
      loop i = 0; group-c; i++ {
         e.group-v[i] = group-v[i];
      }
      e.carg-c = carg-c;
      loop i = 0; carg-c; i++ {
         e.carg-v[i].expr = carg-v[i];
      }
   }
   process-method(expr:Expr, ok:bool&) @case.process() @inline {
      var e:ExprMethod = expr;
      +func-name = e.func-name;
      +group-c = e.group-c;
      +group-v = e.group-v;
      +carg-c = e.carg-c;
      +carg-c1 = carg-c + 1;
      +at-idx = e.thiss.type();
      if at-idx == #nil {
         C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; " - "; .ctx-end-row; '':; .ctx-end-col; ": Cannot call method "; func-name; " on a value without a type\n">;
         return;
      }
      +at = at-idx.ptr();
      var method-c, method-v;
      if at.type == #basic {
         +t = .basic-type[at.name.basic];
         method-c = t.method-c;
         method-v = t.method-v;
      } else {
         if (&&, at.decl.structt == #nil, at.type != #basic, at.type != #module) {
            C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; " - "; .ctx-end-row; '':; .ctx-end-col; ": Cannot call method "; func-name; " because the type :"; at.name.id; " is not defined\n">;
            return;
         }
         if at.def == #struct {
            +t = at.decl.structt.ptr();
            method-c = t.method-c;
            method-v = t.method-v;
         } elif at.def == #enum {
            +t = at.decl.enumm.ptr();
            method-c = t.method-c;
            method-v = t.method-v;
         }
      }
      +found = -1;
      +similar-c = 0:u32;
      loop i = 0; method-c; i++ {
         +f-idx = method-v[i];
         +f = f-idx.ptr();
         if f.decl.name != func-name { continue }
         found = i;
         similar-c++;
         if f.group-c != group-c { continue }
         +match = true;
         if (f.flags & #var-args) != #0 {
            if f.farg-c > carg-c1 { continue }
            loop j = 0; group-c - 1; j++ {
               if f.this-group == j {
                  if f.group-v[j] != (group-v[j] + 1) {
                     match = false;
                     break;
                  }
               } else {
                  if f.group-v[j] != group-v[j] {
                     match = false;
                     break;
                  }
               }
            }
            if match {
               +j = group-c - 1;
               if f.this-group == j {
                  if f.group-v[j] > (group-v[j] + 1) {
                     match = false;
                  }
               } else {
                  if f.group-v[j] > group-v[j] {
                     match = false;
                  }
               }
            }
         } else {
            if f.farg-c != carg-c1 { continue }
            loop j = 0; group-c; j++ {
               if f.this-group == j {
                  if f.group-v[j] != (group-v[j] + 1) {
                     match = false;
                     break;
                  }
               } else {
                  if f.group-v[j] != group-v[j] {
                     match = false;
                     break;
                  }
               }
            }
         }
         if !match { continue }
         if !f-idx.process-later() {
            return;
         }
         +f-at = f.at;
         +j = 0;
         +k = 0;
         loop ; f.this-idx; j++; k++ {
            +ca = e.carg-v[k];
            if !farg-process(ca.expr, ca.reff, ca.value, f.farg-v[j].decl, f-at, k) { return }
         }
         if !farg-process(e.thiss, 0, e.this-value, f.farg-v[j++].decl, f-at, -1) { return }
         loop ; (f.farg-c - 1) - f.this-idx; j++; k++ {
            +ca = e.carg-v[k];
            if !farg-process(ca.expr, ca.reff, ca.value, f.farg-v[j].decl, f-at, k) { return }
         }
         e.func-idx = f-idx;
         if (f.flags & #var-args) != #0 {
            loop ; e.carg-c - k; k++ {
               +ca = e.carg-v[k];
               var r:i32;
               if ca.reff {
                  r = 1 + ca.reff;
               } else {
                  r = 1;
               }
               if !ca.expr.value(r, false, ca.value) { return }
            }
         }
         ok = true;
         return;
      }
      C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; " - "; .ctx-end-row; '':; .ctx-end-col; ": Cannot find method "; func-name; " with "; carg-c; " argument/s\n">;
      if found != -1 {
         C<stdout "But found "; similar-c; " functions with different no. of argument/s:\n">;
         loop i = 0; at.func-c; i++ {
            +f-idx = at.func-v[i];
            +f = .func-v[f-idx];
            if f.decl.name == func-name {
               C<stdout "- :"; func-name; " with "; f.farg-c; " args\n">;
            }
         }
      }
   }
   write-func(expr:Expr) @case.write() @inline {
      var e:ExprFunc = expr;
      +f = e.func-idx.ptr();
      f.write();
      .out.printf("(");
      loop i = 0; e.carg-c; i++ {
         if i != 0 {
            .out.printf(", ");
         }
         e.carg-v[i].expr.write-value(e.carg-v[i].value);
      }
      .out.printf(")");
   }
   write-metafunc(expr:Expr) @case.write() @inline {
      var e:ExprMetaFunc = expr;
      e.expr-v[0].write();
      loop i = 1; e.expr-c - 1; i++ {
         .out.printf(";\n");
         e.expr-v[i].write();
      }
   }
   wr-metafunc(expr:Expr, w:Wtr, header:bool) @case.wr() @inline {
      var e:ExprMetaFunc = expr;
      e.at.wr(w, header);
      e.func-name.wr(w, header);
      w.n1(e.group-c);
      loop i = 0; e.group-c; i++ {
         w.n1(e.group-v[i]);
      }
      w.n1(e.carg-c);
      loop i = 0; e.carg-c; i++ {
         e.carg-v[i].expr.wr(w, header);
      }
      e.lvar.wr(w, header);
   }
   rd-metafunc(e-idx:ExprI, r:Rdr) @case.rd() @inline {
      At.rd(+at-idx, r);
      Id.rd(+func-name, r);
      +group-c = r.n1();
      var group-v:u8[#expr-carg-group-limit];
      loop i = 0; group-c; i++ {
         group-v[i] = r.n1();
      }
      +carg-c = r.n1();
      var carg-v:ExprI[256];
      loop i = 0; carg-c; i++ {
         carg-v[i].rd(r);
      }
      ExprI.rd(+lvar, r);

      +expr-c = group-c + 1;
      quick-alloc-plus(+(e:ExprMetaFunc), ExprI[usz] * expr-c);
      e-idx.set(e.base, #metafunc);

      e.expr-c = expr-c;
      e-idx = ExprI.alloc();
      e.expr-v[0] = e-idx;
      +j = 0;
      if true {
         var group-v:u8[1];
         group-v[0] = 1;
         var carg-v:ExprI[1];
         carg-v[0] = lvar;
         set-func(e-idx, at-idx, func-name, 1, group-v, 1, carg-v);
      }
      // C<stdout "group-c "; group-c; ", carg-c "; carg-c; ''\n>;
      loop i = 1; group-c - 1; i++ {
         +carg-c = group-v[i];
         e-idx = ExprI.alloc();
         e.expr-v[i] = e-idx;

         +carg = carg-v[j++];
         +e-carg = carg.ptr();
         var group-v:u8[1];
         var carg2-v:ExprI[256];
         if e-carg.type == #str {
            var e-str:ExprStr = e-carg;
            group-v[0] = 2 + (carg-c - 1);
            carg2-v[0] = carg;
            +e-idx2 = ExprI.alloc();
            quick-alloc-one(+(e:ExprIntData));
            e-idx2.set(e.base, #int);
            e.value.ii32 = e-str.len();
            e.type = #u32;
            carg2-v[1] = e-idx2;
            loop k = 2; carg-c - 1 {
               carg2-v[k++] = carg-v[j++];
            }
            if .id-cstr == 0:Id {
               .id-cstr = id-add(4, "cstr");
            }
            // C<stdout "lvar.cstr()\n">;
            set-method(e-idx, lvar, .id-cstr, 1, group-v, group-v[0], carg2-v);
         } else {
            group-v[0] = 1 + (carg-c - 1);
            carg2-v[0] = lvar;
            loop k = 1; carg-c - 1 {
               carg2-v[k++] = carg-v[j++];
            }
            // C<stdout "carg."; func-name; "()\n">;
            set-method(e-idx, carg, func-name, 1, group-v, group-v[0], carg2-v);
         }
      }
      e-idx = ExprI.alloc();
      e.expr-v[e.expr-c - 1] = e-idx;
      if true {
         var group-v:u8[1];
         group-v[0] = 0;
         if .id-end == 0:Id {
            .id-end = id-add(3, "end");
         }
         set-method(e-idx, lvar, .id-end, 1, group-v, 0, null);
      }
   }
   var id-end:Id;
   var id-str:Id;
   var id-cstr:Id;
   wr-func(expr:Expr, w:Wtr, header:bool) @case.wr() @inline {
      var e:ExprFunc = expr;
      e.at.wr(w, header);
      e.func-name.wr(w, header);
      w.n1(e.group-c);
      loop i = 0; e.group-c; i++ {
         w.n1(e.group-v[i]);
      }
      w.n1(e.carg-c);
      loop i = 0; e.carg-c; i++ {
         e.carg-v[i].expr.wr(w, header);
      }
   }
   rd-func(e-idx:ExprI, r:Rdr) @case.rd() @inline {
      At.rd(+at-idx, r);
      Id.rd(+func-name, r);
      +group-c = r.n1();
      var group-v:u8[#expr-carg-group-limit];
      loop i = 0; group-c; i++ {
         group-v[i] = r.n1();
      }
      +carg-c = r.n1();
      var carg-v:ExprI[256];
      loop i = 0; carg-c; i++ {
         carg-v[i].rd(r);
      }
      set-func(e-idx, at-idx, func-name, group-c, group-v, carg-c, carg-v);
   }
   set-func(e-idx:ExprI, at-idx:At, func-name:Id, group-c:u8, group-v:u8[], carg-c:u8, carg-v:ExprI[]) {
      quick-alloc-plus(+(e:ExprFunc), Carg[usz] * carg-c);
      e-idx.set(e.base, #func);
      e.at = at-idx;
      e.func-name = func-name;
      e.group-c = group-c;
      loop i = 0; group-c; i++ {
         e.group-v[i] = group-v[i];
      }
      e.carg-c = carg-c;
      loop i = 0; carg-c; i++ {
         e.carg-v[i].expr = carg-v[i];
      }
   }
   process-metafunc(expr:Expr, ok:bool&) @case.process() @inline {
      var e:ExprMetaFunc = expr;
      if !e.expr-v[0].process() {
         return;
      }
      loop i = 1; e.expr-c - 2; i++ {
         +e-idx = e.expr-v[i];
         var e-method:ExprMethod = e-idx.ptr();
         +e-idx2 = e-method.thiss;
         +e-data2 = e-idx2.ptr();
         // C<stdout i; ") carg-c "; e-method.carg-c; ", type "; e-data2.type.cp1-name(); ''\n>;
         if e-data2.type == #str {
            // C<stdout "constant string\n">;
         } else {
            var val;
            if !e-idx2.value(1, true, val) {
               return;
            }
            // C<stdout "val.info.array-c "; val.info.array-c; ''\n>;
            if (val.info.array-c > 0) && (val.type == basic-type(#char)) {
               // C<stdout "string detected\n">;
               e-method.thiss = e-method.carg-v[0].expr;
               e-method.carg-v[0].expr = e-idx2;
               if .id-str == 0:Id {
                  .id-str = id-add(3, "str");
               }
               e-method.func-name = .id-str;
            }
         }
         if !e-idx.process() {
            return;
         }
      }
      if !e.expr-v[e.expr-c - 1].process() {
         return;
      }
      ok = true;
   }
   process-func(expr:Expr, ok:bool&) @case.process() @inline {
      var e:ExprFunc = expr;
      +func-name = e.func-name;
      +carg-c = e.carg-c;
      +group-c = e.group-c;
      +group-v = e.group-v;
      +at-idx = e.at;
      +try-parent = false;
      if at-idx == #nil {
         at-idx = .ctx-func.at;
         try-parent = true;
      } else {
         at-idx = at-validate(at-idx, .ctx-func.at, .ctx-func.file, .ctx-begin-row, .ctx-begin-col);
         e.at = at-idx;
      }
      loop {
         +at = at-idx.ptr();
         // if (&&, at.decl.struct == #nil, at.type != #basic, at.type != #module) {
         //    C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; " - "; .ctx-end-row; '':; .ctx-end-col; ": Cannot call function "; func-name; " because the type :"; at.name.id; " is not defined\n">;
         //    return;
         // }
         // +found = -1;
         // +similar-c = 0;
         // C<stdout "searching from "; at.func-c; " functions\n">;
         loop i = 0; at.func-c; i++ {
            +f-idx = at.func-v[i];
            +f = f-idx.ptr();
            if f.decl.name != func-name { continue }
            // found = i;
            // similar-c++;
            if f.group-c != group-c { continue }
            +match = true;
            if (f.flags & #var-args) != #0 {
               if f.farg-c > carg-c { continue }
               loop j = 0; group-c - 1; j++ {
                  if f.group-v[j] != group-v[j] {
                     match = false;
                     break;
                  }
               }
               if match {
                  +j = group-c - 1;
                  if f.group-v[j] > group-v[j] {
                     match = false;
                  }
               }
            } else {
               if f.farg-c != carg-c { continue }
               loop j = 0; group-c; j++ {
                  if f.group-v[j] != group-v[j] {
                     match = false;
                     break;
                  }
               }
            }
            if !match { continue }
            if !f-idx.process-later() {
               return;
            }
            +f-at = f.at;
            +j = 0;
            loop ; f.farg-c; j++ {
               +ca = e.carg-v[j];
               if !farg-process(ca.expr, ca.reff, ca.value, f.farg-v[j].decl, f-at, j) { return }
            }
            e.func-idx = f-idx;
            if (f.flags & #var-args) != #0 {
               loop ; e.carg-c - j; j++ {
                  +ca = e.carg-v[j];
                  var r:i32;
                  if ca.reff {
                     r = 1 + ca.reff;
                  } else {
                     r = 1;
                  }
                  if !ca.expr.value(r, false, ca.value) { return }
               }
            }
            e.func-idx = f-idx;
            ok = true;
            return;
         }
         if !try-parent { break }
         if at-idx == #root { break }
         at-idx = at.parent;
      }
      C<stdout .ctx-func.file; '':; .ctx-begin-row; '':; .ctx-begin-col; " - "; .ctx-end-row; '':; .ctx-end-col; ": Cannot find function "; func-name; " with "; carg-c; " argument/s\n">;
      // if found != -1 {
      //    C<stdout "But found "; similar-c; " functions with different no. of argument/s:\n">;
      //    loop i = 0; at.func-c; i++ {
      //       +f-idx = at.func-v[i];
      //       +f = .func-v[f-idx];
      //       if f.decl.name == func-name {
      //          C<stdout "- :"; func-name; " with "; f.farg-c; " args\n">;
      //       }
      //    }
      // }
   }
   process-case-func(expr:Expr, f-idx:Func):bool @inline {
      var e:ExprFunc = expr;
      +func-name = e.func-name;
      +carg-c = e.carg-c;
      +group-c = e.group-c;
      +group-v = e.group-v;
      +at = .ctx-func.at.ptr();
      if !f-idx.process-later() {
         return false;
      }
      +f = f-idx.ptr();
      +f-at = f.at;
      +j = 0;
      loop ; f.farg-c; j++ {
         +ca = e.carg-v[j];
         if !farg-process(ca.expr, ca.reff, ca.value, f.farg-v[j].decl, f-at, j) { return false }
      }
      e.func-idx = f-idx;
      if (f.flags & #var-args) != #0 {
         loop ; e.carg-c - j; j++ {
            +ca = e.carg-v[j];
            var r:i32;
            if ca.reff {
               r = 1 + ca.reff;
            } else {
               r = 1;
            }
            if !ca.expr.value(r, false, ca.value) { return false }
         }
      }
      e.func-idx = f-idx;
      return true;
   }
}
 

}
