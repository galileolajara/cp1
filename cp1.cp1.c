// Generated by Cp1
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include "file.cp1.h"
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>
#define _NPosix_NFd_Cnil (-1)
#define _NLibC_NExit_Csuccess 0
#define _NLibC_NExit_Cfailure (_NLibC_NExit_Csuccess + 1)
#define _NCmd_Cc 0
#define _NCmd_Crun (_NCmd_Cc + 1)
#define _NWindows_NCreateFileShareMode_C0 0
#define _NWindows_NHandle_Cnull 0
typedef int _NPosix_NFd;
typedef int _NPosix_NOpenFlags;
typedef int _NLibC_NExit;
typedef uint8_t _NCmd;
typedef uint32_t _NWindows_NCreateFileAccess;
typedef uint32_t _NWindows_NCreateFileShareMode;
typedef uint32_t _NWindows_NCreateFileCreationDisposition;
typedef uint32_t _NWindows_NCreateFileFlags;
typedef int _NPosix_NSeek;
struct _NLibC_NStdout;
struct _NLibC_NStdout {
};
char _Ginclude_dir[512];
uint16_t _Ginclude_dir_len;
int32_t _Gcp1_path_c;
char** _Gcp1_path_v;
char** _Gcp1_path_real_v;
uint32_t _Gatexit_rm_c;
char** _Gatexit_rm_v;
uint32_t _Gatexit_rm_cap;
char* _Gstdout_buf_data;
uint32_t _Gstdout_buf_len;
char _Gcmd_preprocess[512];
int32_t _Gincluded_c;
uint32_t* _Gincluded_len_v;
char** _Gincluded_v;
int32_t _Gincluded_cap;
uint32_t _Gstdout_buf_cap;
int32_t _Gcp1_path_cap;
uint32_t* _Gcp1_path_len_v;
uint32_t* _Gcp1_path_real_len_v;
int main(int _Larg_c_0, char** _Larg_v_1);
void _Pon_exit_0();
#ifdef _WIN32
#define _NPosix_Popen_2(p, f) open(p, f | O_BINARY)
#else
#define _NPosix_Popen_2(p, f) open(p, f)
#endif
void _NLibC_Pstdout_1(struct _NLibC_NStdout* _Lso_0);
void _NLibC_NStdout_Pcstr_3(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1, uint32_t _Llen_2);
void _NLibC_NStdout_Pstr_2(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1);
void _NLibC_NStdout_Pend_1(struct _NLibC_NStdout* _Lso_0);
void _Pprint_commands_1(char* _Lbin_0);
void _Pprint_c_usage_1(char* _Lbin_0);
bool _Pvalidate_cp1_paths_5(int32_t _Lstart_0, int32_t _Larg_c_1, char** _Larg_v_2, char* _Lbin_3, _NCmd _Lcmd_4);
void _Pprint_command_2(int32_t _Larg_c_0, char** _Larg_v_1);
void _Patexit_rm_1(char* _Lpath_0);
void _Tchar_Pstdout_2(char _Lval_0, struct _NLibC_NStdout* _Lso_1);
FILE* _NPosix_NFd_Pfopen_2(_NPosix_NFd _Lfile_0, char* _Lmode_1);
void _Pprint_run_usage_1(char* _Lbin_0);
int _NPosix_NFd_Pclose_1(_NPosix_NFd _Lfile_0);
void _Pget_compile_2(char* _Lbin_0, FILE* _Lninja_f_1);
void _NLibC_Pstdout_bytes_2(void* _Ldata_0, size_t _Lsize_1);
void _NLibC_Pstdout_cstr_1(char* _Lstr_0);
void _NLibC_Pstdout_flush_0();
void _Pprint_usage_2(char* _Lbin_0, _NCmd _Lcmd_1);
bool _Pcp1_path_input_4(char* _Lcp1_path_0, int32_t _Lcp1_path_len_1, char* _Lbin_2, _NCmd _Lcmd_3);
void _NLibC_Pstdout_char_1(char _Lval_0);
void _NLibC_Pstdout_reserve_1(uint32_t _Llen_0);
void* _NCp1_Pread_file_3(char* _Lpath_0, int32_t _Ladd_len_1, size_t* _Lout_size_2);
void _Tu32_Pstdout_2(uint32_t _Lval_0, struct _NLibC_NStdout* _Lso_1);
void _Pcp1_path_add_4(char* _Lcp1_path_real_0, int32_t _Lcp1_path_real_len_1, char* _Lcp1_path_2, int32_t _Lcp1_path_len_3);
void _NLibC_NStdout_Pstr_3(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1, uint32_t _Llen_2);
#define _NLibC_Prealloc_arr_2(var, c) var = realloc(var, sizeof(var[0]) * (c))
#define _NLibC_Pmalloc_arr_2(var, c) var = malloc(sizeof(var[0]) * (c))
bool _NPosix_NFd_Popen_3(_NPosix_NFd* _Lfile_0, char* _Lpath_1, _NPosix_NOpenFlags _Lflags_2);
void _NLibC_Pstdout_u32_1(uint32_t _Lval_0);
int main(int _Larg_c_0, char** _Larg_v_1) {
char* _Lbin_7;
char _Labs_path_8[512];
uint16_t _Labs_path_len_9;
char* _Lslash1_18;
char* _Lslash2_19;
char* _Lcmd_20;
if(false) {
_Pon_exit_0();
}
#ifdef _WIN32
if(true) {
char* _Larg_2;
size_t _Llen_3;
_Larg_2 = _Larg_v_1[0];
_Llen_3 = strlen(_Larg_2);
if(((_Larg_2[(_Llen_3 - 4)] == '.') && (_Larg_2[(_Llen_3 - 3)] == 'e') && (_Larg_2[(_Llen_3 - 2)] == 'x') && (_Larg_2[(_Llen_3 - 1)] == 'e'))) {
_Larg_2[(_Llen_3 - 4)] = '\0';
}
}
int32_t _Li_4;
_Li_4 = 0;
for(int i = _Larg_c_0; i > 0; ) {
i --;
char* _Larg_5;
_Larg_5 = _Larg_v_1[_Li_4];
int32_t _Lj_6;
_Lj_6 = 0;
while(1) {
if(_Larg_5[_Lj_6] == '\0') {
goto break_1;
} else if(_Larg_5[_Lj_6] == '\\') {
_Larg_5[_Lj_6] = '/';
}
continue_1:;
_Lj_6++;
}
break_1:;
continue_0:;
_Li_4++;
}
break_0:;
#endif
atexit(_Pon_exit_0);
_Lbin_7 = _Larg_v_1[0];
_Labs_path_len_9 = 0;
if(_Lbin_7[0] == '/') {
_Labs_path_len_9 = strlen(_Lbin_7);
memcpy(_Labs_path_8, _Lbin_7, _Labs_path_len_9);
_Labs_path_8[_Labs_path_len_9] = '\0';
} else {
bool _Lhas_slash_10;
_Lhas_slash_10 = false;
int32_t _Li_11;
_Li_11 = 0;
while(1) {
if(_Lbin_7[_Li_11] == '\0') {
goto break_2;
}
if(_Lbin_7[_Li_11] == '/') {
_Lhas_slash_10 = true;
goto break_2;
}
continue_2:;
_Li_11++;
}
break_2:;
if(_Lhas_slash_10) {
char _Lcwd_12[512];
int32_t _Li_13;
#ifdef _WIN32
getcwd(_Lcwd_12, 512);
strcpy(_Labs_path_8, &_Lcwd_12[2]);
_Li_13 = 0;
while(1) {
if(_Labs_path_8[_Li_13] == '\0') {
goto break_3;
} else if(_Labs_path_8[_Li_13] == '\\') {
_Labs_path_8[_Li_13] = '/';
}
continue_3:;
_Li_13++;
}
break_3:;
_Labs_path_8[_Li_13++] = '/';
strcpy(&_Labs_path_8[_Li_13], _Lbin_7);
#else
realpath(_Lbin_7, _Labs_path_8);
#endif
} else {
char* _Lpath_14;
char* _Lfound_15;
_NPosix_NFd _Lfd_16;
_Lpath_14 = strdup(getenv("PATH"));
_Lfound_15 = strtok(_Lpath_14, ":");
_Lfd_16 = _NPosix_NFd_Cnil;
while(_Lfound_15 != NULL) {
sprintf(_Labs_path_8, "%s/%s", _Lfound_15, _Lbin_7);
_Lfd_16 = _NPosix_Popen_2(_Labs_path_8, O_RDONLY);
if(_Lfd_16 != _NPosix_NFd_Cnil) {
goto break_4;
}
_Lfound_15 = strtok(NULL, ":");
continue_4:;
}
break_4:;
if(_Lfd_16 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_17;
_NLibC_Pstdout_1(&_Lstdout_17);
_NLibC_NStdout_Pcstr_3(&_Lstdout_17, "Cannot run ", 11u);
_NLibC_NStdout_Pstr_2(&_Lstdout_17, _Lbin_7);
_NLibC_NStdout_Pcstr_3(&_Lstdout_17, " because we can't detect its absolute path\n", 43u);
_NLibC_NStdout_Pend_1(&_Lstdout_17);
exit(_NLibC_NExit_Cfailure);
}
free(_Lpath_14);
}
}
_Lslash1_18 = strrchr(_Labs_path_8, '/');
_Lslash1_18[0] = '\0';
_Lslash2_19 = strrchr(_Labs_path_8, '/');
_Lslash2_19[0] = '\0';
sprintf(_Ginclude_dir, "%s/include", _Labs_path_8);
_Lslash1_18[0] = '/';
_Lslash2_19[0] = '/';
_Ginclude_dir_len = strlen(_Ginclude_dir);
if(_Larg_c_0 < 2) {
_Pprint_commands_1(_Lbin_7);
exit(_NLibC_NExit_Cfailure);
}
_Lcmd_20 = _Larg_v_1[1];
if(strcmp(_Lcmd_20, "c") == 0) {
char* _Lc_path_21;
size_t _Lc_path_len_22;
char _Lninja_path_24[24];
_NPosix_NFd _Lninja_fd_25;
FILE* _Lninja_f_27;
char _Lcommand_30[24 + 9];
int _Lret_31;
if(_Larg_c_0 < 4) {
_Pprint_c_usage_1(_Lbin_7);
exit(_NLibC_NExit_Cfailure);
}
_Lc_path_21 = _Larg_v_1[2];
_Lc_path_len_22 = strlen(_Lc_path_21);
if(!((_Lc_path_len_22 > 2) && (_Lc_path_21[(_Lc_path_len_22 - 2)] == '.') && (_Lc_path_21[(_Lc_path_len_22 - 1)] == 'c'))) {
struct _NLibC_NStdout _Lstdout_23;
_Pprint_c_usage_1(_Lbin_7);
_NLibC_Pstdout_1(&_Lstdout_23);
_NLibC_NStdout_Pcstr_3(&_Lstdout_23, "Error, [output.c] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_23, _Lc_path_21);
_NLibC_NStdout_Pcstr_3(&_Lstdout_23, "') must be a filename that ends with '.c', for example: main.c\n", 63u);
_NLibC_NStdout_Pend_1(&_Lstdout_23);
exit(_NLibC_NExit_Cfailure);
}
if(!_Pvalidate_cp1_paths_5(3, _Larg_c_0, _Larg_v_1, _Lbin_7, _NCmd_Cc)) {
_Pprint_command_2(_Larg_c_0, _Larg_v_1);
exit(_NLibC_NExit_Cfailure);
}
#ifdef _WIN32
mkdir("cp1-tmp");
#else
mkdir("cp1-tmp", 0755);
#endif
strcpy(_Lninja_path_24, "cp1-tmp/ninja-XXXXXXXXX");
_Lninja_fd_25 = mkstemp(_Lninja_path_24);
_Patexit_rm_1(strdup(_Lninja_path_24));
if(_Lninja_fd_25 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_26;
_Pprint_c_usage_1(_Lbin_7);
_NLibC_Pstdout_1(&_Lstdout_26);
_NLibC_NStdout_Pcstr_3(&_Lstdout_26, "Error, cannot open file for reading: ", 37u);
_NLibC_NStdout_Pstr_2(&_Lstdout_26, _Lninja_path_24);
_Tchar_Pstdout_2('\n', &_Lstdout_26);
_NLibC_NStdout_Pend_1(&_Lstdout_26);
exit(_NLibC_NExit_Cfailure);
}
_Lninja_f_27 = _NPosix_NFd_Pfopen_2(_Lninja_fd_25, "wb");
fprintf(_Lninja_f_27, "rule parse\n");
#ifdef _WIN32
fprintf(_Lninja_f_27, " command = %s-parse.exe $in $out\n", _Lbin_7);
#else
fprintf(_Lninja_f_27, " command = %s-parse $in $out\n", _Lbin_7);
#endif
fprintf(_Lninja_f_27, "rule compile\n");
#ifdef _WIN32
fprintf(_Lninja_f_27, " command = %s-compile.exe $in $out\n", _Lbin_7);
#else
fprintf(_Lninja_f_27, " command = %s-compile $in $out\n", _Lbin_7);
#endif
int32_t _Li_28;
_Li_28 = 0;
for(int i = _Gcp1_path_c; i > 0; ) {
i --;
#ifdef _WIN32
fprintf(_Lninja_f_27, "build cp1-tmp/%s-b: parse %s | %s-parse.exe\n", _Gcp1_path_v[_Li_28], _Gcp1_path_real_v[_Li_28], _Labs_path_8);
#else
fprintf(_Lninja_f_27, "build cp1-tmp/%s-b: parse %s | %s-parse\n", _Gcp1_path_v[_Li_28], _Gcp1_path_real_v[_Li_28], _Labs_path_8);
#endif
continue_5:;
_Li_28++;
}
break_5:;
fprintf(_Lninja_f_27, "build %s: compile", _Lc_path_21);
int32_t _Li_29;
_Li_29 = 0;
for(int i = _Gcp1_path_c; i > 0; ) {
i --;
fprintf(_Lninja_f_27, " cp1-tmp/%s-b", _Gcp1_path_v[_Li_29]);
continue_6:;
_Li_29++;
}
break_6:;
#ifdef _WIN32
fprintf(_Lninja_f_27, " | %s-compile.exe\n", _Labs_path_8);
#else
fprintf(_Lninja_f_27, " | %s-compile\n", _Labs_path_8);
#endif
fclose(_Lninja_f_27);
sprintf(_Lcommand_30, "ninja -f %s", _Lninja_path_24);
_Lret_31 = system(_Lcommand_30);
if(_Lret_31 != 0) {
exit(_NLibC_NExit_Cfailure);
}
} else if(strcmp(_Lcmd_20, "run") == 0) {
char _Lc_path_32[22];
_NPosix_NFd _Lc_fd_33;
char _Lexe_path_35[24];
_NPosix_NFd _Lexe_fd_36;
char _Lninja_path_38[24];
_NPosix_NFd _Lninja_fd_39;
FILE* _Lninja_f_41;
char _Lcommand_44[32 + 9];
int _Lninja_ret_45;
int _Lexe_ret_47;
if(_Larg_c_0 < 3) {
_Pprint_run_usage_1(_Lbin_7);
exit(_NLibC_NExit_Cfailure);
}
if(!_Pvalidate_cp1_paths_5(2, _Larg_c_0, _Larg_v_1, _Lbin_7, _NCmd_Crun)) {
_Pprint_command_2(_Larg_c_0, _Larg_v_1);
exit(_NLibC_NExit_Cfailure);
}
#ifdef _WIN32
mkdir("cp1-tmp");
#else
mkdir("cp1-tmp", 0755);
#endif
strcpy(_Lc_path_32, "cp1-tmp/c-XXXXXXXXX");
_Lc_fd_33 = mkstemp(_Lc_path_32);
if(_Lc_fd_33 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_34;
_Pprint_run_usage_1(_Lbin_7);
_NLibC_Pstdout_1(&_Lstdout_34);
_NLibC_NStdout_Pcstr_3(&_Lstdout_34, "Error, cannot open file for reading: ", 37u);
_NLibC_NStdout_Pstr_2(&_Lstdout_34, _Lc_path_32);
_Tchar_Pstdout_2('\n', &_Lstdout_34);
_NLibC_NStdout_Pend_1(&_Lstdout_34);
exit(_NLibC_NExit_Cfailure);
}
_NPosix_NFd_Pclose_1(_Lc_fd_33);
unlink(_Lc_path_32);
strcpy(_Lexe_path_35, "cp1-tmp/exe-XXXXXXXXX");
_Lexe_fd_36 = mkstemp(_Lexe_path_35);
if(_Lexe_fd_36 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_37;
_Pprint_run_usage_1(_Lbin_7);
_NLibC_Pstdout_1(&_Lstdout_37);
_NLibC_NStdout_Pcstr_3(&_Lstdout_37, "Error, cannot open file for reading: ", 37u);
_NLibC_NStdout_Pstr_2(&_Lstdout_37, _Lexe_path_35);
_Tchar_Pstdout_2('\n', &_Lstdout_37);
_NLibC_NStdout_Pend_1(&_Lstdout_37);
exit(_NLibC_NExit_Cfailure);
}
_NPosix_NFd_Pclose_1(_Lexe_fd_36);
unlink(_Lexe_path_35);
_Lc_path_32[19] = '.';
_Lc_path_32[20] = 'c';
_Lc_path_32[21] = '\0';
_Patexit_rm_1(strdup(_Lc_path_32));
strcpy(_Lninja_path_38, "cp1-tmp/ninja-XXXXXXXXX");
_Lninja_fd_39 = mkstemp(_Lninja_path_38);
_Patexit_rm_1(strdup(_Lninja_path_38));
if(_Lninja_fd_39 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_40;
_Pprint_run_usage_1(_Lbin_7);
_NLibC_Pstdout_1(&_Lstdout_40);
_NLibC_NStdout_Pcstr_3(&_Lstdout_40, "Error, cannot open file for reading: ", 37u);
_NLibC_NStdout_Pstr_2(&_Lstdout_40, _Lninja_path_38);
_Tchar_Pstdout_2('\n', &_Lstdout_40);
_NLibC_NStdout_Pend_1(&_Lstdout_40);
exit(_NLibC_NExit_Cfailure);
}
_Lninja_f_41 = _NPosix_NFd_Pfopen_2(_Lninja_fd_39, "wb");
fprintf(_Lninja_f_41, "rule parse\n");
#ifdef _WIN32
fprintf(_Lninja_f_41, " command = %s-parse.exe $in $out\n", _Lbin_7);
#else
fprintf(_Lninja_f_41, " command = %s-parse $in $out\n", _Lbin_7);
#endif
fprintf(_Lninja_f_41, "rule compile\n");
#ifdef _WIN32
fprintf(_Lninja_f_41, " command = %s-compile.exe $in $out\n", _Lbin_7);
#else
fprintf(_Lninja_f_41, " command = %s-compile $in $out\n", _Lbin_7);
#endif
_Pget_compile_2(_Lbin_7, _Lninja_f_41);
int32_t _Li_42;
_Li_42 = 0;
for(int i = _Gcp1_path_c; i > 0; ) {
i --;
#ifdef _WIN32
fprintf(_Lninja_f_41, "build cp1-tmp/%s-b: parse %s | %s-parse.exe\n", _Gcp1_path_v[_Li_42], _Gcp1_path_real_v[_Li_42], _Labs_path_8);
#else
fprintf(_Lninja_f_41, "build cp1-tmp/%s-b: parse %s | %s-parse\n", _Gcp1_path_v[_Li_42], _Gcp1_path_real_v[_Li_42], _Labs_path_8);
#endif
continue_7:;
_Li_42++;
}
break_7:;
fprintf(_Lninja_f_41, "build %s: compile", _Lc_path_32);
int32_t _Li_43;
_Li_43 = 0;
for(int i = _Gcp1_path_c; i > 0; ) {
i --;
fprintf(_Lninja_f_41, " cp1-tmp/%s-b", _Gcp1_path_v[_Li_43]);
continue_8:;
_Li_43++;
}
break_8:;
#ifdef _WIN32
fprintf(_Lninja_f_41, " | %s-compile.exe\n", _Labs_path_8);
#else
fprintf(_Lninja_f_41, " | %s-compile\n", _Labs_path_8);
#endif
fprintf(_Lninja_f_41, "build %s: c %s\n", _Lexe_path_35, _Lc_path_32);
fclose(_Lninja_f_41);
sprintf(_Lcommand_44, "ninja --quiet -f %s", _Lninja_path_38);
_Lninja_ret_45 = system(_Lcommand_44);
if(_Lninja_ret_45 != 0) {
exit(_NLibC_NExit_Cfailure);
}
#ifdef _WIN32
int32_t _Li_46;
_Li_46 = 0;
while(1) {
if(_Lexe_path_35[_Li_46] == '\0') {
goto break_9;
} else if(_Lexe_path_35[_Li_46] == '/') {
_Lexe_path_35[_Li_46] = '\\';
}
continue_9:;
_Li_46++;
}
break_9:;
#endif
_Lexe_ret_47 = system(_Lexe_path_35);
unlink(_Lexe_path_35);
if(_Lexe_ret_47 != 0) {
exit(_NLibC_NExit_Cfailure);
}
} else {
_Pprint_commands_1(_Lbin_7);
exit(_NLibC_NExit_Cfailure);
}
return 0;
}
void _Pon_exit_0() {
int32_t _Li_0;
_Li_0 = 0;
for(int i = _Gatexit_rm_c; i > 0; ) {
i --;
unlink(_Gatexit_rm_v[_Li_0]);
continue_0:;
_Li_0++;
}
break_0:;
}
void _NLibC_Pstdout_1(struct _NLibC_NStdout* _Lso_0) {
}
inline void _NLibC_NStdout_Pcstr_3(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1, uint32_t _Llen_2) {
_NLibC_Pstdout_bytes_2(_Lstr_1, _Llen_2);
}
inline void _NLibC_NStdout_Pstr_2(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1) {
_NLibC_Pstdout_cstr_1(_Lstr_1);
}
void _NLibC_NStdout_Pend_1(struct _NLibC_NStdout* _Lso_0) {
_NLibC_Pstdout_flush_0();
}
void _Pprint_commands_1(char* _Lbin_0) {
struct _NLibC_NStdout _Lstdout_1;
struct _NLibC_NStdout _Lstdout_2;
struct _NLibC_NStdout _Lstdout_3;
struct _NLibC_NStdout _Lstdout_4;
_NLibC_Pstdout_1(&_Lstdout_1);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, "Usage: ", 7u);
_NLibC_NStdout_Pstr_2(&_Lstdout_1, _Lbin_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, " [command] [options]\n", 21u);
_NLibC_NStdout_Pend_1(&_Lstdout_1);
_NLibC_Pstdout_1(&_Lstdout_2);
_NLibC_NStdout_Pcstr_3(&_Lstdout_2, "Commands:\n", 10u);
_NLibC_NStdout_Pend_1(&_Lstdout_2);
_NLibC_Pstdout_1(&_Lstdout_3);
_NLibC_NStdout_Pcstr_3(&_Lstdout_3, "  c     Build a C file.\n", 24u);
_NLibC_NStdout_Pend_1(&_Lstdout_3);
_NLibC_Pstdout_1(&_Lstdout_4);
_NLibC_NStdout_Pcstr_3(&_Lstdout_4, "  run      Compile and run the cp1 codes.\n", 42u);
_NLibC_NStdout_Pend_1(&_Lstdout_4);
}
void _Pprint_c_usage_1(char* _Lbin_0) {
struct _NLibC_NStdout _Lstdout_1;
_NLibC_Pstdout_1(&_Lstdout_1);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, "Usage: ", 7u);
_NLibC_NStdout_Pstr_2(&_Lstdout_1, _Lbin_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, " c [output.c] [cp1 file/s...]\n", 30u);
_NLibC_NStdout_Pend_1(&_Lstdout_1);
}
bool _Pvalidate_cp1_paths_5(int32_t _Lstart_0, int32_t _Larg_c_1, char** _Larg_v_2, char* _Lbin_3, _NCmd _Lcmd_4) {
int32_t _Li_5;
_Li_5 = _Lstart_0;
for(int i = _Larg_c_1 - _Lstart_0; i > 0; ) {
i --;
char* _Lcp1_path_6;
size_t _Lcp1_path_len_8;
_Lcp1_path_6 = _Larg_v_2[_Li_5];
if(_Lcp1_path_6[0] == '/') {
struct _NLibC_NStdout _Lstdout_7;
_Pprint_usage_2(_Lbin_3, _Lcmd_4);
_NLibC_Pstdout_1(&_Lstdout_7);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_7, _Lcp1_path_6);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, "') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n", 91u);
_NLibC_NStdout_Pend_1(&_Lstdout_7);
exit(_NLibC_NExit_Cfailure);
}
_Lcp1_path_len_8 = strlen(_Lcp1_path_6);
if(((_Lcp1_path_6[0] == '.') && (_Lcp1_path_6[1] == '/'))) {
_Lcp1_path_6 = &_Lcp1_path_6[2];
_Lcp1_path_len_8 -= 2;
}
int32_t _Lj_9;
_Lj_9 = 0;
for(int i = _Lcp1_path_len_8; i > 0; ) {
i --;
if(_Lcp1_path_6[_Lj_9] == '\\') {
struct _NLibC_NStdout _Lstdout_10;
_Pprint_usage_2(_Lbin_3, _Lcmd_4);
_NLibC_Pstdout_1(&_Lstdout_10);
_NLibC_NStdout_Pcstr_3(&_Lstdout_10, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_10, _Lcp1_path_6);
_NLibC_NStdout_Pcstr_3(&_Lstdout_10, "') must not contain backslashes '\\', please use forward slashes '/' instead\n", 76u);
_NLibC_NStdout_Pend_1(&_Lstdout_10);
exit(_NLibC_NExit_Cfailure);
}
continue_1:;
_Lj_9++;
}
break_1:;
int32_t _Lj_11;
_Lj_11 = 0;
for(int i = _Lcp1_path_len_8 - 1; i > 0; ) {
i --;
if(((_Lcp1_path_6[_Lj_11] == '.') && (_Lcp1_path_6[(_Lj_11 + 1)] == '/'))) {
struct _NLibC_NStdout _Lstdout_12;
_Pprint_usage_2(_Lbin_3, _Lcmd_4);
_NLibC_Pstdout_1(&_Lstdout_12);
_NLibC_NStdout_Pcstr_3(&_Lstdout_12, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_12, _Lcp1_path_6);
_NLibC_NStdout_Pcstr_3(&_Lstdout_12, "') must not contain './'\n", 25u);
_NLibC_NStdout_Pend_1(&_Lstdout_12);
exit(_NLibC_NExit_Cfailure);
}
continue_2:;
_Lj_11++;
}
break_2:;
if(!((_Lcp1_path_len_8 > 4) && (_Lcp1_path_6[(_Lcp1_path_len_8 - 4)] == '.') && (_Lcp1_path_6[(_Lcp1_path_len_8 - 3)] == 'c') && (_Lcp1_path_6[(_Lcp1_path_len_8 - 2)] == 'p') && (_Lcp1_path_6[(_Lcp1_path_len_8 - 1)] == '1'))) {
struct _NLibC_NStdout _Lstdout_13;
_Pprint_usage_2(_Lbin_3, _Lcmd_4);
_NLibC_Pstdout_1(&_Lstdout_13);
_NLibC_NStdout_Pcstr_3(&_Lstdout_13, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_13, _Lcp1_path_6);
_NLibC_NStdout_Pcstr_3(&_Lstdout_13, "') must be a filename that ends with '.cp1', for example: main.cp1\n", 67u);
_NLibC_NStdout_Pend_1(&_Lstdout_13);
exit(_NLibC_NExit_Cfailure);
}
if(!_Pcp1_path_input_4(_Lcp1_path_6, _Lcp1_path_len_8, _Lbin_3, _Lcmd_4)) {
_Pprint_usage_2(_Lbin_3, _Lcmd_4);
return false;
}
continue_0:;
_Li_5++;
}
break_0:;
return true;
}
void _Pprint_command_2(int32_t _Larg_c_0, char** _Larg_v_1) {
struct _NLibC_NStdout _Lstdout_2;
struct _NLibC_NStdout _Lstdout_5;
_NLibC_Pstdout_1(&_Lstdout_2);
_NLibC_NStdout_Pcstr_3(&_Lstdout_2, "Command was:", 12u);
_NLibC_NStdout_Pend_1(&_Lstdout_2);
int32_t _Li_3;
_Li_3 = 0;
for(int i = _Larg_c_0; i > 0; ) {
i --;
struct _NLibC_NStdout _Lstdout_4;
_NLibC_Pstdout_1(&_Lstdout_4);
_Tchar_Pstdout_2(' ', &_Lstdout_4);
_NLibC_NStdout_Pstr_2(&_Lstdout_4, _Larg_v_1[_Li_3]);
_NLibC_NStdout_Pcstr_3(&_Lstdout_4, "", 0u);
_NLibC_NStdout_Pend_1(&_Lstdout_4);
continue_0:;
_Li_3++;
}
break_0:;
_NLibC_Pstdout_1(&_Lstdout_5);
_Tchar_Pstdout_2('\n', &_Lstdout_5);
_NLibC_NStdout_Pend_1(&_Lstdout_5);
}
void _Patexit_rm_1(char* _Lpath_0) {
uint32_t _Li_1;
_Li_1 = _Gatexit_rm_c++;
if(_Gatexit_rm_cap < _Gatexit_rm_c) {
_Gatexit_rm_cap = ((_Gatexit_rm_c << 1) + 8);
_Gatexit_rm_v = realloc(_Gatexit_rm_v, _Gatexit_rm_cap * sizeof(size_t));
}
_Gatexit_rm_v[_Li_1] = _Lpath_0;
}
void _Tchar_Pstdout_2(char _Lval_0, struct _NLibC_NStdout* _Lso_1) {
_NLibC_Pstdout_char_1(_Lval_0);
}
inline FILE* _NPosix_NFd_Pfopen_2(_NPosix_NFd _Lfile_0, char* _Lmode_1) {
return fdopen(_Lfile_0, _Lmode_1);
}
void _Pprint_run_usage_1(char* _Lbin_0) {
struct _NLibC_NStdout _Lstdout_1;
_NLibC_Pstdout_1(&_Lstdout_1);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, "Usage: ", 7u);
_NLibC_NStdout_Pstr_2(&_Lstdout_1, _Lbin_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_1, " run [cp1 file/s...]\n", 21u);
_NLibC_NStdout_Pend_1(&_Lstdout_1);
}
inline int _NPosix_NFd_Pclose_1(_NPosix_NFd _Lfile_0) {
return close(_Lfile_0);
}
void _Pget_compile_2(char* _Lbin_0, FILE* _Lninja_f_1) {
char* _Lpath_2;
char* _Lfound_4;
struct _NLibC_NStdout _Lstdout_7;
_Lpath_2 = strdup(getenv("PATH"));
#ifdef _WIN32
int32_t _Li_3;
_Li_3 = 0;
while(1) {
if(_Lpath_2[_Li_3] == '\0') {
goto break_0;
} else if(_Lpath_2[_Li_3] == '\\') {
_Lpath_2[_Li_3] = '/';
}
continue_0:;
_Li_3++;
}
break_0:;
#endif
#ifdef _WIN32
_Lfound_4 = strtok(_Lpath_2, ";");
#else
_Lfound_4 = strtok(_Lpath_2, ":");
#endif
while(_Lfound_4 != NULL) {
_NPosix_NFd _Lfd_5;
char _Lcompile_6[512];
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/tcc.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/tcc", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
fprintf(_Lninja_f_1, "rule c\n");
fprintf(_Lninja_f_1, " command = tcc -I. $in -o $out\n");
_NPosix_NFd_Pclose_1(_Lfd_5);
free(_Lpath_2);
return;
}
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/clang.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/clang", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
fprintf(_Lninja_f_1, "rule c\n");
fprintf(_Lninja_f_1, " command = clang -I. $in -o $out\n");
_NPosix_NFd_Pclose_1(_Lfd_5);
free(_Lpath_2);
return;
}
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/gcc.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/gcc", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
fprintf(_Lninja_f_1, "rule c\n");
fprintf(_Lninja_f_1, " command = gcc -I. $in -o $out\n");
_NPosix_NFd_Pclose_1(_Lfd_5);
free(_Lpath_2);
return;
}
#ifdef _WIN32
_Lfound_4 = strtok(NULL, ";");
#else
_Lfound_4 = strtok(NULL, ":");
#endif
continue_1:;
}
break_1:;
_NLibC_Pstdout_1(&_Lstdout_7);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, "Cannot execute '", 16u);
_NLibC_NStdout_Pstr_2(&_Lstdout_7, _Lbin_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, " run' because the required compile was not found: tcc clang or gcc\n", 67u);
_NLibC_NStdout_Pend_1(&_Lstdout_7);
exit(_NLibC_NExit_Cfailure);
}
inline void _NLibC_Pstdout_bytes_2(void* _Ldata_0, size_t _Lsize_1) {
_NLibC_Pstdout_reserve_1(_Lsize_1);
memcpy(&_Gstdout_buf_data[_Gstdout_buf_len], _Ldata_0, _Lsize_1);
_Gstdout_buf_len += _Lsize_1;
}
inline void _NLibC_Pstdout_cstr_1(char* _Lstr_0) {
_NLibC_Pstdout_bytes_2(_Lstr_0, strlen(_Lstr_0));
}
void _NLibC_Pstdout_flush_0() {
write((_NPosix_NFd)(1), _Gstdout_buf_data, _Gstdout_buf_len);
_Gstdout_buf_len = 0;
}
void _Pprint_usage_2(char* _Lbin_0, _NCmd _Lcmd_1) {
switch(_Lcmd_1) {
case _NCmd_Cc:;
_Pprint_c_usage_1(_Lbin_0);
break;
case _NCmd_Crun:;
_Pprint_run_usage_1(_Lbin_0);
break;
}
}
bool _Pcp1_path_input_4(char* _Lcp1_path_0, int32_t _Lcp1_path_len_1, char* _Lbin_2, _NCmd _Lcmd_3) {
char* _Ldata_5;
size_t _Llen_6;
uint32_t _Lpos_10;
uint32_t _Lline_11;
bool _Lpreprocess_12;
int32_t _Li_4;
_Li_4 = 0;
for(int i = _Gcp1_path_c; i > 0; ) {
i --;
if(memcmp(_Gcp1_path_v[_Li_4], _Lcp1_path_0, _Lcp1_path_len_1) == 0) {
return true;
}
continue_0:;
_Li_4++;
}
break_0:;
_Ldata_5 = _NCp1_Pread_file_3(_Lcp1_path_0, 0, &_Llen_6);
if(_Ldata_5 == NULL) {
struct _NLibC_NStdout _Lstdout_7;
_NLibC_Pstdout_1(&_Lstdout_7);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_7, _Lcp1_path_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_7, "') cannot be opened for reading\n", 32u);
_NLibC_NStdout_Pend_1(&_Lstdout_7);
return false;
}
if(!((_Llen_6 > 0) && (_Ldata_5[(_Llen_6 - 1)] == '\n'))) {
struct _NLibC_NStdout _Lstdout_8;
_NLibC_Pstdout_1(&_Lstdout_8);
_NLibC_NStdout_Pcstr_3(&_Lstdout_8, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_8, _Lcp1_path_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_8, "') must end a new line\n", 23u);
_NLibC_NStdout_Pend_1(&_Lstdout_8);
return false;
}
if(_Ldata_5[(_Llen_6 - 2)] == '\r') {
struct _NLibC_NStdout _Lstdout_9;
_NLibC_Pstdout_1(&_Lstdout_9);
_NLibC_NStdout_Pcstr_3(&_Lstdout_9, "Error, [cp1 file] (which is '", 29u);
_NLibC_NStdout_Pstr_2(&_Lstdout_9, _Lcp1_path_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_9, "') must have Unix line endings '\\n' instead of Windows line endings '\\r\\n'\n", 75u);
_NLibC_NStdout_Pend_1(&_Lstdout_9);
return false;
}
_Lpos_10 = (uint32_t)(0);
_Lline_11 = (uint32_t)(0);
_Lpreprocess_12 = false;
while(_Lpos_10 < _Llen_6) {
uint32_t _Lstart_13;
uint32_t _Lfirst_char_15;
_Lline_11++;
_Lstart_13 = _Lpos_10;
while(1) {
if(_Ldata_5[_Lpos_10] == '\n') {
goto break_2;
}
if(_Ldata_5[_Lpos_10] == '\t') {
struct _NLibC_NStdout _Lstdout_14;
_NLibC_Pstdout_1(&_Lstdout_14);
_NLibC_NStdout_Pstr_2(&_Lstdout_14, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_14);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_14);
_Tchar_Pstdout_2(':', &_Lstdout_14);
_Tu32_Pstdout_2((_Lpos_10 - _Lstart_13) + 1, &_Lstdout_14);
_NLibC_NStdout_Pcstr_3(&_Lstdout_14, ": Error, use of tabs is discouraged, please use spaces instead\n", 63u);
_NLibC_NStdout_Pend_1(&_Lstdout_14);
exit(_NLibC_NExit_Cfailure);
}
_Lpos_10++;
continue_2:;
}
break_2:;
_Lfirst_char_15 = _Lstart_13;
while(1) {
if(_Ldata_5[_Lfirst_char_15] == ' ') {
_Lfirst_char_15++;
goto continue_3;
} else {
goto break_3;
}
continue_3:;
}
break_3:;
if(((_Ldata_5[_Lfirst_char_15] == '#') && (_Ldata_5[(_Lfirst_char_15 + 1)] == 'i') && (_Ldata_5[(_Lfirst_char_15 + 2)] == 'f') && ((_Ldata_5[(_Lfirst_char_15 + 3)] == '(') || ((_Ldata_5[(_Lfirst_char_15 + 3)] == '!') && (_Ldata_5[(_Lfirst_char_15 + 4)] == '('))))) {
_Lpreprocess_12 = true;
goto break_1;
}
_Lpos_10++;
continue_1:;
}
break_1:;
if(_Lpreprocess_12) {
char _Ltmp_path_16[17];
_NPosix_NFd _Ltmp_fd_17;
void* _Ltmp_path_dup_19;
free(_Ldata_5);
memcpy(_Ltmp_path_16, "cp1-tmp-XXXXXXXX", 17);
_Ltmp_fd_17 = mkstemp(_Ltmp_path_16);
if(_Ltmp_fd_17 == _NPosix_NFd_Cnil) {
struct _NLibC_NStdout _Lstdout_18;
_NLibC_Pstdout_1(&_Lstdout_18);
_NLibC_NStdout_Pcstr_3(&_Lstdout_18, "Error, cannot create a temporary file at the current folder\n", 60u);
_NLibC_NStdout_Pend_1(&_Lstdout_18);
return false;
}
_NPosix_NFd_Pclose_1(_Ltmp_fd_17);
sprintf(_Gcmd_preprocess, "%s-preprocess %.*s %s\n", _Lbin_2, _Lcp1_path_len_1, _Lcp1_path_0, _Ltmp_path_16);
fflush(stdout);
if(system(_Gcmd_preprocess) != 0) {
return false;
}
_Ltmp_path_dup_19 = malloc(17);
memcpy(_Ltmp_path_dup_19, _Ltmp_path_16, 17);
_Patexit_rm_1(_Ltmp_path_dup_19);
_Pcp1_path_add_4(_Ltmp_path_dup_19, 16, _Lcp1_path_0, _Lcp1_path_len_1);
_Ldata_5 = _NCp1_Pread_file_3(_Ltmp_path_dup_19, 0, &_Llen_6);
if(_Ldata_5 == NULL) {
struct _NLibC_NStdout _Lstdout_20;
_NLibC_Pstdout_1(&_Lstdout_20);
_NLibC_NStdout_Pcstr_3(&_Lstdout_20, "Error, cannot open file for reading: ", 37u);
_NLibC_NStdout_Pstr_2(&_Lstdout_20, _Ltmp_path_16);
_Tchar_Pstdout_2('\n', &_Lstdout_20);
_NLibC_NStdout_Pend_1(&_Lstdout_20);
return false;
}
} else {
_Pcp1_path_add_4(_Lcp1_path_0, _Lcp1_path_len_1, _Lcp1_path_0, _Lcp1_path_len_1);
}
_Lpos_10 = 0;
_Lline_11 = 0;
while(_Lpos_10 < _Llen_6) {
uint32_t _Lstart_21;
uint32_t _Lfirst_char_22;
uint32_t _Li_66;
_Lline_11++;
_Lstart_21 = _Lpos_10;
while(1) {
if(_Ldata_5[_Lpos_10] == '\n') {
goto break_5;
}
_Lpos_10++;
continue_5:;
}
break_5:;
_Lfirst_char_22 = _Lstart_21;
while(1) {
if(_Ldata_5[_Lfirst_char_22] == ' ') {
_Lfirst_char_22++;
goto continue_6;
} else {
goto break_6;
}
continue_6:;
}
break_6:;
if(((_Ldata_5[_Lfirst_char_22] == '#') && (_Ldata_5[(_Lfirst_char_22 + 1)] == 'i') && (_Ldata_5[(_Lfirst_char_22 + 2)] == 'm') && (_Ldata_5[(_Lfirst_char_22 + 3)] == 'p') && (_Ldata_5[(_Lfirst_char_22 + 4)] == 'o') && (_Ldata_5[(_Lfirst_char_22 + 5)] == 'r') && (_Ldata_5[(_Lfirst_char_22 + 6)] == 't') && (_Ldata_5[(_Lfirst_char_22 + 7)] == ' '))) {
int32_t _Lbegin_23;
_Lstart_21 += 8;
_Lbegin_23 = -1;
uint32_t _Lj_24;
_Lj_24 = _Lstart_21;
for(int i = _Lpos_10 - _Lstart_21; i > 0; ) {
i --;
if(_Ldata_5[_Lj_24] == '\"') {
_Lbegin_23 = _Lj_24;
goto break_7;
} else if(_Ldata_5[_Lj_24] == ' ') {
} else {
struct _NLibC_NStdout _Lstdout_25;
_NLibC_Pstdout_1(&_Lstdout_25);
_NLibC_NStdout_Pstr_2(&_Lstdout_25, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_25);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_25);
_NLibC_NStdout_Pcstr_3(&_Lstdout_25, ": Invalid character '", 21u);
_Tchar_Pstdout_2(_Ldata_5[_Lj_24], &_Lstdout_25);
_NLibC_NStdout_Pcstr_3(&_Lstdout_25, "' found in #include <...>\n", 26u);
_NLibC_NStdout_Pend_1(&_Lstdout_25);
return false;
}
continue_7:;
_Lj_24++;
}
break_7:;
if(_Lbegin_23 != -1) {
int32_t _Lend_26;
char* _Limport_29;
int32_t _Limport_path_len_30;
char* _Limport_path_37;
_Lstart_21 = (_Lbegin_23 + 1);
_Lend_26 = -1;
uint32_t _Lj_27;
_Lj_27 = _Lstart_21;
for(int i = _Lpos_10 - _Lstart_21; i > 0; ) {
i --;
if(_Ldata_5[_Lj_27] == '\"') {
_Lend_26 = _Lj_27;
goto break_8;
}
continue_8:;
_Lj_27++;
}
break_8:;
if(_Lend_26 == -1) {
struct _NLibC_NStdout _Lstdout_28;
_NLibC_Pstdout_1(&_Lstdout_28);
_NLibC_NStdout_Pstr_2(&_Lstdout_28, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_28);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_28);
_NLibC_NStdout_Pcstr_3(&_Lstdout_28, ": #import \"...\" must end with '\"'\n", 34u);
_NLibC_NStdout_Pend_1(&_Lstdout_28);
return false;
}
_Limport_29 = &_Ldata_5[_Lstart_21];
_Limport_path_len_30 = (_Lend_26 - _Lstart_21);
if(((_Limport_path_len_30 >= 4) && (_Limport_29[(_Limport_path_len_30 - 4)] == '.') && (_Limport_29[(_Limport_path_len_30 - 3)] == 'c') && (_Limport_29[(_Limport_path_len_30 - 2)] == 'p') && (_Limport_29[(_Limport_path_len_30 - 1)] == '1'))) {
struct _NLibC_NStdout _Lstdout_31;
_NLibC_Pstdout_1(&_Lstdout_31);
_NLibC_NStdout_Pstr_2(&_Lstdout_31, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_31);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_31);
_NLibC_NStdout_Pcstr_3(&_Lstdout_31, ": #import \"", 11u);
_NLibC_NStdout_Pstr_3(&_Lstdout_31, _Limport_29, _Limport_path_len_30);
_NLibC_NStdout_Pcstr_3(&_Lstdout_31, "\" doesn't need a '.cp1' suffix\n", 31u);
_NLibC_NStdout_Pend_1(&_Lstdout_31);
return false;
}
if(_Limport_29[0] == '/') {
struct _NLibC_NStdout _Lstdout_32;
_NLibC_Pstdout_1(&_Lstdout_32);
_NLibC_NStdout_Pstr_2(&_Lstdout_32, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_32);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_32);
_NLibC_NStdout_Pcstr_3(&_Lstdout_32, ": #import \"", 11u);
_NLibC_NStdout_Pstr_3(&_Lstdout_32, _Limport_29, _Limport_path_len_30);
_NLibC_NStdout_Pcstr_3(&_Lstdout_32, "\" must be a relative path, '/' was detected at the beginning of file path\n", 74u);
_NLibC_NStdout_Pend_1(&_Lstdout_32);
return false;
}
int32_t _Lj_33;
_Lj_33 = 0;
for(int i = _Limport_path_len_30; i > 0; ) {
i --;
if(_Limport_29[_Lj_33] == '\\') {
struct _NLibC_NStdout _Lstdout_34;
_NLibC_Pstdout_1(&_Lstdout_34);
_NLibC_NStdout_Pstr_2(&_Lstdout_34, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_34);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_34);
_NLibC_NStdout_Pcstr_3(&_Lstdout_34, ": #import \"", 11u);
_NLibC_NStdout_Pstr_3(&_Lstdout_34, _Limport_29, _Limport_path_len_30);
_NLibC_NStdout_Pcstr_3(&_Lstdout_34, "\" must not contain backslashes '\\', please use forward slashes '/' instead\n", 75u);
_NLibC_NStdout_Pend_1(&_Lstdout_34);
return false;
}
continue_9:;
_Lj_33++;
}
break_9:;
int32_t _Lj_35;
_Lj_35 = 0;
for(int i = _Limport_path_len_30 - 1; i > 0; ) {
i --;
if(((_Limport_29[_Lj_35] == '.') && (_Limport_29[(_Lj_35 + 1)] == '/'))) {
struct _NLibC_NStdout _Lstdout_36;
_NLibC_Pstdout_1(&_Lstdout_36);
_NLibC_NStdout_Pstr_2(&_Lstdout_36, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_36);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_36);
_NLibC_NStdout_Pcstr_3(&_Lstdout_36, ": #import \"", 11u);
_NLibC_NStdout_Pstr_3(&_Lstdout_36, _Limport_29, _Limport_path_len_30);
_NLibC_NStdout_Pcstr_3(&_Lstdout_36, "\" must not contain './'\n", 24u);
_NLibC_NStdout_Pend_1(&_Lstdout_36);
return false;
}
continue_10:;
_Lj_35++;
}
break_10:;
_Limport_path_37 = malloc(_Limport_path_len_30 + 5);
memcpy(_Limport_path_37, _Limport_29, _Limport_path_len_30);
_Limport_path_37[_Limport_path_len_30++] = '.';
_Limport_path_37[_Limport_path_len_30++] = 'c';
_Limport_path_37[_Limport_path_len_30++] = 'p';
_Limport_path_37[_Limport_path_len_30++] = '1';
_Limport_path_37[_Limport_path_len_30] = '\0';
if(!_Pcp1_path_input_4(_Limport_path_37, _Limport_path_len_30, _Lbin_2, _Lcmd_3)) {
struct _NLibC_NStdout _Lstdout_38;
_NLibC_Pstdout_1(&_Lstdout_38);
_NLibC_NStdout_Pcstr_3(&_Lstdout_38, "Error from #import \"", 20u);
_NLibC_NStdout_Pstr_3(&_Lstdout_38, _Limport_29, _Limport_path_len_30 - 4);
_NLibC_NStdout_Pcstr_3(&_Lstdout_38, "\" at file '", 11u);
_NLibC_NStdout_Pstr_2(&_Lstdout_38, _Lcp1_path_0);
_NLibC_NStdout_Pcstr_3(&_Lstdout_38, "' line ", 7u);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_38);
_Tchar_Pstdout_2('\n', &_Lstdout_38);
_NLibC_NStdout_Pend_1(&_Lstdout_38);
return false;
}
}
_Lpos_10++;
goto continue_4;
} else if(((_Ldata_5[_Lfirst_char_22] == '#') && (_Ldata_5[(_Lfirst_char_22 + 1)] == 'i') && (_Ldata_5[(_Lfirst_char_22 + 2)] == 'n') && (_Ldata_5[(_Lfirst_char_22 + 3)] == 'c') && (_Ldata_5[(_Lfirst_char_22 + 4)] == 'l') && (_Ldata_5[(_Lfirst_char_22 + 5)] == 'u') && (_Ldata_5[(_Lfirst_char_22 + 6)] == 'd') && (_Ldata_5[(_Lfirst_char_22 + 7)] == 'e') && (_Ldata_5[(_Lfirst_char_22 + 8)] == ' '))) {
int32_t _Lbegin_39;
_Lstart_21 += 9;
_Lbegin_39 = -1;
uint32_t _Lj_40;
_Lj_40 = _Lstart_21;
for(int i = _Lpos_10 - _Lstart_21; i > 0; ) {
i --;
if(_Ldata_5[_Lj_40] == '<') {
_Lbegin_39 = _Lj_40;
goto break_11;
} else if(_Ldata_5[_Lj_40] == ' ') {
} else {
struct _NLibC_NStdout _Lstdout_41;
_NLibC_Pstdout_1(&_Lstdout_41);
_NLibC_NStdout_Pstr_2(&_Lstdout_41, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_41);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_41);
_NLibC_NStdout_Pcstr_3(&_Lstdout_41, ": Invalid character '", 21u);
_Tchar_Pstdout_2(_Ldata_5[_Lj_40], &_Lstdout_41);
_NLibC_NStdout_Pcstr_3(&_Lstdout_41, "' found in #include <...>\n", 26u);
_NLibC_NStdout_Pend_1(&_Lstdout_41);
return false;
}
continue_11:;
_Lj_40++;
}
break_11:;
if(_Lbegin_39 != -1) {
int32_t _Lend_42;
char* _Linclude_path_45;
int32_t _Linclude_path_len_46;
bool _Lfound_47;
_Lstart_21 = (_Lbegin_39 + 1);
_Lend_42 = -1;
uint32_t _Lj_43;
_Lj_43 = _Lstart_21;
for(int i = _Lpos_10 - _Lstart_21; i > 0; ) {
i --;
if(_Ldata_5[_Lj_43] == '>') {
_Lend_42 = _Lj_43;
goto break_12;
}
continue_12:;
_Lj_43++;
}
break_12:;
if(_Lend_42 == -1) {
struct _NLibC_NStdout _Lstdout_44;
_NLibC_Pstdout_1(&_Lstdout_44);
_NLibC_NStdout_Pstr_2(&_Lstdout_44, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_44);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_44);
_NLibC_NStdout_Pcstr_3(&_Lstdout_44, ": #include <...> must end with '>'\n", 35u);
_NLibC_NStdout_Pend_1(&_Lstdout_44);
return false;
}
_Linclude_path_45 = &_Ldata_5[_Lstart_21];
_Linclude_path_len_46 = (_Lend_42 - _Lstart_21);
_Lfound_47 = false;
int32_t _Lj_48;
_Lj_48 = 0;
for(int i = _Gincluded_c; i > 0; ) {
i --;
if(((_Linclude_path_len_46 == _Gincluded_len_v[_Lj_48]) && (memcmp(_Gincluded_v[_Lj_48], _Linclude_path_45, _Linclude_path_len_46) == 0))) {
_Lfound_47 = true;
goto break_13;
}
continue_13:;
_Lj_48++;
}
break_13:;
if(!_Lfound_47) {
int32_t _Li_49;
char* _Lpath_50;
char _Lspec_path_51[128];
char* _Lspec_data_53;
size_t _Lspec_len_54;
int32_t _Lspec_pos_56;
int32_t _Lspec_line_57;
_Li_49 = _Gincluded_c++;
if(_Gincluded_cap < _Gincluded_c) {
_Gincluded_cap = ((_Gincluded_c << 1) + 8);
_Gincluded_v = realloc(_Gincluded_v, _Gincluded_cap * sizeof(size_t));
_Gincluded_len_v = realloc(_Gincluded_len_v, _Gincluded_cap * sizeof(uint32_t));
}
_Lpath_50 = malloc(_Linclude_path_len_46 + 1);
memcpy(_Lpath_50, _Linclude_path_45, _Linclude_path_len_46);
_Lpath_50[_Linclude_path_len_46] = '\0';
_Gincluded_v[_Li_49] = _Lpath_50;
_Gincluded_len_v[_Li_49] = _Linclude_path_len_46;
sprintf(_Lspec_path_51, "%s/%s", _Ginclude_dir, _Lpath_50);
uint16_t _Li_52;
_Li_52 = (_Ginclude_dir_len + 1);
for(int i = strlen(_Lspec_path_51) - (_Ginclude_dir_len + 1); i > 0; ) {
i --;
if(_Lspec_path_51[_Li_52] == '/') {
_Lspec_path_51[_Li_52] = '-';
}
continue_14:;
_Li_52++;
}
break_14:;
_Lspec_data_53 = _NCp1_Pread_file_3(_Lspec_path_51, 0, &_Lspec_len_54);
if(_Lspec_data_53 == NULL) {
struct _NLibC_NStdout _Lstdout_55;
_NLibC_Pstdout_1(&_Lstdout_55);
_NLibC_NStdout_Pstr_2(&_Lstdout_55, _Lcp1_path_0);
_Tchar_Pstdout_2(':', &_Lstdout_55);
_Tu32_Pstdout_2(_Lline_11, &_Lstdout_55);
_NLibC_NStdout_Pcstr_3(&_Lstdout_55, ": #include <", 12u);
_NLibC_NStdout_Pstr_2(&_Lstdout_55, _Lpath_50);
_NLibC_NStdout_Pcstr_3(&_Lstdout_55, "> failed because '", 18u);
_NLibC_NStdout_Pstr_2(&_Lstdout_55, _Lspec_path_51);
_NLibC_NStdout_Pcstr_3(&_Lstdout_55, "' does not exists\n", 18u);
_NLibC_NStdout_Pend_1(&_Lstdout_55);
return false;
}
_Lspec_pos_56 = 0;
_Lspec_line_57 = 0;
while(_Lspec_pos_56 < _Lspec_len_54) {
int32_t _Lstart_58;
_Lspec_line_57++;
_Lstart_58 = _Lspec_pos_56;
while(1) {
if(_Lspec_data_53[_Lspec_pos_56] == '\n') {
if(_Lspec_data_53[_Lstart_58] == '<') {
int32_t _Lrangle_59;
_Lstart_58++;
_Lrangle_59 = -1;
int32_t _Lj_60;
_Lj_60 = _Lstart_58;
for(int i = _Lspec_pos_56 - _Lstart_58; i > 0; ) {
i --;
if(_Lspec_data_53[_Lj_60] == '>') {
_Lrangle_59 = _Lj_60;
goto break_17;
}
continue_17:;
_Lj_60++;
}
break_17:;
if(_Lrangle_59 != -1) {
char* _Lfile_path_61;
int32_t _Lfile_path_len_62;
char* _Lfile_path_dup_63;
char* _Lreal_path_64;
size_t _Lreal_path_len_65;
_Lfile_path_61 = &_Lspec_data_53[_Lstart_58];
_Lfile_path_len_62 = (_Lrangle_59 - _Lstart_58);
_Lfile_path_dup_63 = malloc(_Lfile_path_len_62 + 1);
memcpy(_Lfile_path_dup_63, _Lfile_path_61, _Lfile_path_len_62);
_Lfile_path_dup_63[_Lfile_path_len_62] = '\0';
_Lreal_path_64 = malloc(_Ginclude_dir_len + 1 + _Lfile_path_len_62 + 1);
sprintf(_Lreal_path_64, "%s/%.*s", _Ginclude_dir, _Lfile_path_len_62, _Lfile_path_61);
_Lreal_path_len_65 = strlen(_Lreal_path_64);
_Pcp1_path_add_4(_Lreal_path_64, _Lreal_path_len_65, _Lfile_path_dup_63, _Lfile_path_len_62);
}
}
_Lspec_pos_56++;
goto break_16;
}
_Lspec_pos_56++;
continue_16:;
}
break_16:;
continue_15:;
}
break_15:;
free(_Lspec_data_53);
}
}
_Lpos_10++;
goto continue_4;
}
_Li_66 = _Lfirst_char_22;
while(1) {
if(_Ldata_5[_Li_66] == '\n') {
goto break_18;
}
if(((_Ldata_5[_Li_66] == '/') && (_Ldata_5[(_Li_66 + 1)] == '/'))) {
goto break_18;
} else {
goto stop;
}
_Li_66++;
continue_18:;
}
break_18:;
_Lpos_10++;
continue_4:;
}
break_4:;
stop:
free(_Ldata_5);
return true;
}
inline void _NLibC_Pstdout_char_1(char _Lval_0) {
_NLibC_Pstdout_reserve_1(1);
_Gstdout_buf_data[_Gstdout_buf_len++] = _Lval_0;
}
inline void _NLibC_Pstdout_reserve_1(uint32_t _Llen_0) {
uint32_t _Lspace_1;
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
if(_Lspace_1 < _Llen_0) {
if(_Gstdout_buf_cap == 0) {
_Gstdout_buf_cap = 256;
} else {
_Gstdout_buf_cap += _Gstdout_buf_cap;
}
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
while(_Lspace_1 < _Llen_0) {
_Gstdout_buf_cap += _Gstdout_buf_cap;
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
continue_0:;
}
break_0:;
_NLibC_Prealloc_arr_2(_Gstdout_buf_data, _Gstdout_buf_cap);
}
}
inline void* _NCp1_Pread_file_3(char* _Lpath_0, int32_t _Ladd_len_1, size_t* _Lout_size_2) {
#ifdef _WIN32
if(true) {
HANDLE _Lh_3;
LARGE_INTEGER _Lf_size_4;
uint64_t _Lsize_5;
uint8_t* _Lbuf_6;
uint32_t _Lbytes_read_7;
_Lh_3 = CreateFileA(_Lpath_0, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, _NWindows_NHandle_Cnull);
if(_Lh_3 == INVALID_HANDLE_VALUE) {
return NULL;
}
if(!GetFileSizeEx(_Lh_3, &_Lf_size_4)) {
CloseHandle(_Lh_3);
return NULL;
}
_Lsize_5 = _Lf_size_4.QuadPart;
_NLibC_Pmalloc_arr_2(_Lbuf_6, _Lsize_5 + _Ladd_len_1);
if((!ReadFile(_Lh_3, _Lbuf_6, _Lsize_5, &_Lbytes_read_7, NULL) || (_Lbytes_read_7 != _Lsize_5))) {
free(_Lbuf_6);
CloseHandle(_Lh_3);
return NULL;
}
CloseHandle(_Lh_3);
(*_Lout_size_2) = _Lsize_5;
return _Lbuf_6;
}
#else
if(true) {
_NPosix_NFd _Lfd_8;
size_t _Lsize_9;
uint8_t* _Lbuf_10;
if(!_NPosix_NFd_Popen_3(&_Lfd_8, _Lpath_0, O_RDONLY)) {
return NULL;
}
_Lsize_9 = lseek(_Lfd_8, 0, SEEK_END);
if(_Lsize_9 == -1) {
_NPosix_NFd_Pclose_1(_Lfd_8);
return NULL;
}
if(lseek(_Lfd_8, 0, SEEK_SET) == -1) {
_NPosix_NFd_Pclose_1(_Lfd_8);
return NULL;
}
_NLibC_Pmalloc_arr_2(_Lbuf_10, _Lsize_9 + _Ladd_len_1);
if(read(_Lfd_8, _Lbuf_10, _Lsize_9) != _Lsize_9) {
free(_Lbuf_10);
_NPosix_NFd_Pclose_1(_Lfd_8);
return NULL;
}
_NPosix_NFd_Pclose_1(_Lfd_8);
(*_Lout_size_2) = _Lsize_9;
return _Lbuf_10;
}
#endif
}
void _Tu32_Pstdout_2(uint32_t _Lval_0, struct _NLibC_NStdout* _Lso_1) {
_NLibC_Pstdout_u32_1(_Lval_0);
}
void _Pcp1_path_add_4(char* _Lcp1_path_real_0, int32_t _Lcp1_path_real_len_1, char* _Lcp1_path_2, int32_t _Lcp1_path_len_3) {
int32_t _Li_4;
_Li_4 = _Gcp1_path_c++;
if(_Gcp1_path_cap < _Gcp1_path_c) {
_Gcp1_path_cap = ((_Gcp1_path_cap << 1) + 8);
_Gcp1_path_v = realloc(_Gcp1_path_v, _Gcp1_path_cap * sizeof(size_t));
_Gcp1_path_len_v = realloc(_Gcp1_path_len_v, _Gcp1_path_cap * sizeof(uint32_t));
_Gcp1_path_real_v = realloc(_Gcp1_path_real_v, _Gcp1_path_cap * sizeof(size_t));
_Gcp1_path_real_len_v = realloc(_Gcp1_path_real_len_v, _Gcp1_path_cap * sizeof(uint32_t));
}
_Gcp1_path_v[_Li_4] = _Lcp1_path_2;
_Gcp1_path_len_v[_Li_4] = _Lcp1_path_len_3;
_Gcp1_path_real_v[_Li_4] = _Lcp1_path_real_0;
_Gcp1_path_real_len_v[_Li_4] = _Lcp1_path_real_len_1;
}
inline void _NLibC_NStdout_Pstr_3(struct _NLibC_NStdout* _Lso_0, char* _Lstr_1, uint32_t _Llen_2) {
_NLibC_Pstdout_bytes_2(_Lstr_1, _Llen_2);
}
inline bool _NPosix_NFd_Popen_3(_NPosix_NFd* _Lfile_0, char* _Lpath_1, _NPosix_NOpenFlags _Lflags_2) {
_NPosix_NFd _Lfd_3;
_Lfd_3 = _NPosix_Popen_2(_Lpath_1, _Lflags_2);
if(_Lfd_3 != -1) {
(*_Lfile_0) = _Lfd_3;
return true;
} else {
return false;
}
}
void _NLibC_Pstdout_u32_1(uint32_t _Lval_0) {
_NLibC_Pstdout_reserve_1(10);
if(_Lval_0 == 0) {
_Gstdout_buf_data[_Gstdout_buf_len++] = '0';
} else {
char* _Ldata_1;
int32_t _Ldigits_2;
int32_t _Lstart_3;
int32_t _Lend_4;
_Ldata_1 = &_Gstdout_buf_data[_Gstdout_buf_len];
_Ldigits_2 = 0;
while(1) {
_Ldata_1[_Ldigits_2++] = ((_Lval_0 % 10) + '0');
_Lval_0 /= 10;
if(_Lval_0 == 0) {
goto break_0;
}
continue_0:;
}
break_0:;
_Lstart_3 = 0;
_Lend_4 = (_Ldigits_2 - 1);
while(_Lstart_3 < _Lend_4) {
char _Ltmp_5;
_Ltmp_5 = _Ldata_1[_Lstart_3];
_Ldata_1[_Lstart_3] = _Ldata_1[_Lend_4];
_Ldata_1[_Lend_4] = _Ltmp_5;
_Lstart_3++;
_Lend_4--;
continue_1:;
}
break_1:;
_Gstdout_buf_len += _Ldigits_2;
}
}
