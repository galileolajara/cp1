{using 'glc = :glc}
{using 'c = :stdc}
{using 'sys = :sys}
{at(:glc)
{gvar ctx-func:decl-func}
{gvar id-in-header-v:u8[]}
{gvar id-in-header-idx-v:u32[]}
{gvar id-in-header-id-v:u32[]}
{gvar id-in-header-c:i32}

{gvar at-in-header-v:u8[]}
{gvar at-in-header-idx-v:u32[]}
{gvar at-in-header-at-v:u32[]}
{gvar at-in-header-c:i32}

{gvar decl-include:include}
{gvar decl-include-row:i32}
{gvar decl-include-col:i32}
{type-info-begin()
   .decl-var.size-c = 0;
   .decl-var.type-info.init();
   .decl-var.flags = #0;
}
{type-info-finalize()
   .decl-var.type-info.finalize();
}
{type-info-arr(expr-v:expr-i[], expr-c:u8)
   {+r:rdr+}
   r.ref = expr-v;
   {if(expr-v == null)
      +ti = .decl-var.type-info;
      ti.array-c += 1;
      ti.ref-v[ti.array-c] = 0;
      return;
   }
   {do{+i = expr-c}(expr-c)
      type-info-arr(expr-v[i -= 1]);
   }
}
{type-info-arr(expr:expr-i)
   +ti = .decl-var.type-info;
	ti.array-c += 1;
	ti.ref-v[ti.array-c] = 0;
	{if(expr != #nil)
      +vd = .decl-var;
      {if(vd.size-c == 0)
         quick-alloc-arr(vd.size-expr-v, #decl-var-size-limit);
      }
      vd.size-expr-v[vd.size-c++] = expr;
      // 'c.out.printf("%s, vd.size-c = %d\n", vd.name.str(), vd.size-c);
	}
}
{type-info-ref(c:i8)
   +ti = .decl-var.type-info;
	ti.ref-v[ti.array-c] += c;
}
{type-info-static()
   // 'c.out.printf("built-in\n");
   .decl-var.type-info.built-in = true;
}
{decl-include-begin(inc:include, row:i32, col:i32)
   {if(.decl-include != #nil)
      'c.out.printf("%s:%u:%u: Cannot {include inside another {include of %u:%u\n", .input-path, row, col, .decl-include-row, .decl-include-col);
      'c.exit(#failure);
      return}
   .decl-include = inc;
   .decl-include-row = row;
   .decl-include-col = col;
}
{decl-include-end()
   .decl-include = #nil;
}
{gvar build-at:at}
{at-push(name:id, type:name-type, row:i32, col:i32)
   .build-at = at-create(.build-at, type, name);
}
{at-basic-type(type:basic-type-id):at
   {do{+i = 0:at}{(.at-c) i++}
      +at = .at-v[i];
      {if(&&, at.type == #basic, at.name.basic == type)
         return i;
      }
   }
   +build-idx = .at-c++;
   {if(.at-cap <= .at-c)
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = type;
   return build-idx;
}
{at-begin()
   .build-at = .decl-at;
}
{gvar at-begin-relative-pause:bool}
{at-begin-relative-pause()
   .at-begin-relative-pause = true;
}
{at-begin-relative-resume()
   .at-begin-relative-pause = false;
}
{at-begin-relative()
   {if(.at-begin-relative-pause)
      .build-at = .decl-at;
   }{else
      .build-at = #relative;
   }
}
{:alias[#nil = -1, #0]:i32}
{gvar at-alias-c:alias}
{gvar at-alias-cap:alias}
{gvar at-alias-name-v:id[]}
{gvar at-alias-at-v:at[]}
{gvar at-alias-pos-v:row-col+[]}
{:row-col(row:i32, col:i32)}
{at-alias(name:id, row:i32, col:i32)
   {do{+i = 0}{(.at-alias-c) i++}
      {if(.at-alias-name-v[i] == name)
         .build-at = .at-alias-at-v[i];
         return;
      }
   }
   'c.out.printf("%s:%u:%u: Cannot recognize the alias '%s\n", .input-path, row, col, name.str());
   'c.exit(#failure);
}
{decl-alias(name:id, at:at, row:i32, col:i32)
   // {if(at.ptr().type != #module)
   //    'c.out.printf("%s:%u:%u: Alias can only work on namespaces that ends with '%%'\n", .input-path, row, col);
   //    'c.exit(#failure);
   //    return;
   // }
   {do{+i = 0}{(.at-alias-c) i++}
      {if(.at-alias-name-v[i] == name)
         'c.out.printf("%s:%u:%u: Alias '%s was already declared at %u:%u\n", .input-path, row, col, name.str(), .at-alias-pos-v[i].row, .at-alias-pos-v[i].col);
         'c.exit(#failure);
         return;
      }
   }
   +alias-idx = .at-alias-c++;
   {if(.at-alias-cap <= .at-alias-c)
      +old-cap = .at-alias-cap;
      grow(.at-alias-cap, .at-alias-c);
      realloc(.at-alias-name-v, .at-alias-cap, old-cap);
      realloc(.at-alias-at-v, .at-alias-cap, old-cap);
      realloc(.at-alias-pos-v, .at-alias-cap, old-cap);
   }
   .at-alias-name-v[alias-idx] = name;
   .at-alias-at-v[alias-idx] = at;
   .at-alias-pos-v[alias-idx].row = row;
   .at-alias-pos-v[alias-idx].col = col;
}
{at-root()
   .build-at = #root;
}
{at-graves(graves:i8, row:i32, col:i32)
   .build-at = .decl-at;
   {while(graves > 0)
      graves--;
      {if(.build-at == #root)
         'c.out.printf("%s:%u:%u: Too many graves in the namespace, going beyond the root namespace\n", .input-path, row, col);
         'c.exit(#failure);
      }
      +at = .build-at.ptr();
      .build-at = at.parent;
   }
}
{at-done():at
   return .build-at;
}
{at-create(parent:at, type:name-type, name:id):at
   +found = .at-map.get-or-insert(parent, type, name, .at-c);
   {if(found != -1) return found}
   // {do{+i = 0:at}{(.at-c) i++}
   //    +at = .at-v[i];
   //    {if(&&,
   //       at.parent == parent,
   //       at.type == type,
   //       at.name.id == name)
   //       return i;
   //    }
   // }
   +build-idx = .at-c++;
   {if(.at-cap <= .at-c)
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = parent;
   at.type = type;
   at.name.id = name;
   return build-idx;
}
{at-create-basic(basic:basic-type-id):at
   {do{+i = 0:at}{(.at-c) i++}
      +at = .at-v[i];
      {if(&&,
         at.type == #basic,
         at.name.basic == basic)
         return i;
      }
   }
   +build-idx = .at-c++;
   {if(.at-cap <= .at-c)
      +old-cap = .at-cap;
      grow(.at-cap, .at-c);
      realloc(.at-v, .at-cap, old-cap);
   }
   +at = .at-v[build-idx];
   at.parent = #root;
   at.type = #basic;
   at.name.basic = basic;
   return build-idx;
}

{gvar decl-at:at}
{cvar #decl-at-nest-limit:i32 = 8}
{gvar decl-at-v:at[#decl-at-nest-limit]}
{gvar decl-at-c:u8}
{err-msg-namespace-limit(row:i32, col:i32)
   'c.out.printf("%s:%u:%u: Max number of ids in namespace reached\n", .input-path, row, col);
   'c.exit(#failure);
}
{decl-at-add(name:id, type:name-type)
   .build-at = at-create(.build-at, type, name);
}
{decl-at-basic(type:basic-type-id)
   .build-at = at-create-basic(type);
}
{decl-at-begin(row:i32, col:i32)
   .decl-at-v[.decl-at-c++] = .decl-at;
   .decl-at = .build-at;
}
{decl-at-end()
   .decl-at-c--;
   .decl-at = .decl-at-v[.decl-at-c];
}
{:token-data(
   row:i32,
   col:i32,
   id:i32,
   id2:i32,
   val:i32[12],
   )
}
{:lexer(
   content:u8[],
   start:u8[],
   cursor:u8[],
   // limit:u8[],
   marker:u8[],
   // ctx-marker:u8[],
   )
   {init(lex:this, data:u8[], size:usz)
      lex.start = data;
      lex.cursor = data;
      lex.content = data;
      // lex.limit = & data[size];
   }
   {scan(lex:this):token @real-name(glc_lexer_scan)}
   {get-u32-oct(lex:this):u32
      {+r-start:rdr+}
      r-start.ref = lex.start;
      {+r-cursor:rdr+}
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos;
      {if(length > 12)
         'c.out.printf("%s:%u:%u: Integer literal was too long\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      +val = 0:u64;
      {do(length)
         val = (val * 8:u64) + (r-start.p1[0] - ''0);
         r-start.pos++;
      }
      {if(val > 4294967295)
         'c.out.printf("%s:%u:%u: Integer literal was out of bounds\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      return val:u32;
   }
   {get-u32-dec(lex:this):u32
      {+r-start:rdr+}
      r-start.ref = lex.start;
      {+r-cursor:rdr+}
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos;
      {if(length > 10)
         'c.out.printf("%s:%u:%u: Integer literal was too long\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      +val = 0:u64;
      {do(length)
         val = (val * 10:u64) + (r-start.p1[0] - ''0);
         r-start.pos++;
      }
      {if(val > 4294967295)
         'c.out.printf("%s:%u:%u: Integer literal was out of bounds\n", .input-path, .row, .col);
         'c.exit(#failure);
      }
      return val:u32;
   }
   {get-id(lex:this, begin:u8, end:u8):i32
      {+r-start:rdr+}
      r-start.ref = lex.start;
      r-start.pos += begin;
      {+r-cursor:rdr+}
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos - end;
      {if(length > 255)
         'c.out.printf("too long id was detected\n");
         'c.exit(#failure);
      }
      +len = length:u8;
      +found = .id-map.get-or-insert(r-start.ref, len, .id-c);
      {if(found == -1)
         // inserted
         +id = .id-c++;
         {if(.id-cap <= .id-c)
            +old-cap = .id-cap;
            grow(.id-cap, .id-c);
            realloc(.id-str-v, .id-cap, old-cap);
            realloc(.id-len-v, .id-cap, old-cap);
         }
         {+text:char[] = quick-alloc(len + 1)}
         'c.memcpy(text, r-start.ref, len);
         text[len] = 0;
         .id-str-v[id] = text;
         .id-len-v[id] = len;
         return id;
      }{else
         // found
         return found;
      }
      // {do{+i = 0}{(.id-c) i++}
      //    {if(.id-len-v[i] == len)
      //       {if('c.memcmp(.id-str-v[i], r-start.ref, len) == 0)
      //          return i;
      //       }
      //    }
      // }
      // +id = .id-c++;
      // {if(.id-cap <= .id-c)
      //    +old-cap = .id-cap;
      //    grow(.id-cap, .id-c);
      //    realloc(.id-str-v, .id-cap, old-cap);
      //    realloc(.id-len-v, .id-cap, old-cap);
      // }
      // {+text:char[] = quick-alloc(len + 1)}
      // 'c.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .id-str-v[id] = text;
      // .id-len-v[id] = len;
      // return id;
   }
   {get-include(lex:this):i32
      {+r-start:rdr+}
      r-start.ref = lex.start;
      r-start.pos += 9;
      {+r-cursor:rdr+}
      r-cursor.ref = lex.cursor;
      +length = r-cursor.pos - r-start.pos - 1;
      {if(length > 255)
         'c.out.printf("too long include was detected\n");
         'c.exit(#failure);
      }
      +len = length:u8;
      +found = .include-map.get-or-insert(r-start.ref, len, .include-c);
      {if(found == -1)
         // inserted
         +include = .include-c++;
         {if(.include-cap <= .include-c)
            +old-cap = .include-cap;
            grow(.include-cap, .include-c);
            realloc(.include-str-v, .include-cap, old-cap);
            realloc(.include-len-v, .include-cap, old-cap);
         }
         {+text:char[] = quick-alloc(len + 1)}
         'c.memcpy(text, r-start.ref, len);
         text[len] = 0;
         .include-str-v[include] = text;
         .include-len-v[include] = len;
         return include;
      }{else
         // found
         return found;
      }
      // {do{+i = 0}{(.include-c) i++}
      //    {if(.include-len-v[i] == len)
      //       {if('c.memcmp(.include-str-v[i], r-start.ref, len) == 0)
      //          return i;
      //       }
      //    }
      // }
      // +include = .include-c++;
      // {if(.include-cap <= .include-c)
      //    +old-cap = .include-cap;
      //    grow(.include-cap, .include-c);
      //    realloc(.include-str-v, .include-cap, old-cap);
      //    realloc(.include-len-v, .include-cap, old-cap);
      // }
      // {+text:char[] = quick-alloc(len + 1)}
      // 'c.memcpy(text, r-start.ref, len);
      // text[len] = 0;
      // .include-str-v[include] = text;
      // .include-len-v[include] = len;
      // return include;
   }
}
{:parser()
   {alloc():parser}
   {free(psr:this)}
   {parse(psr:this, t:token, tok:token-data+) @real-name(glcParse)}
}
{gvar last-row:i32 @extern}
{gvar last-col:i32 @extern}
{gvar row:i32 @extern}
{gvar col:i32 @extern}
{write-func(w:wtr, header:bool) @inline
   w.n(.func-c);
   {do{+i = 0}(.func-c)
      +f = .func-v[i++];
      w.n1(f.farg-c);
      w.n(f.begin-row);
      w.n(f.begin-col);
      w.n(f.end-row);
      w.n(f.end-col);
      f.include.wr(w);
      f.at.wr(w, header);
      f.decl.wr(w, header);
      {do{+j = 0}{(f.farg-c) j++}
         f.farg-v[j].wr(w, header);
      }
      w.n1(f.this-idx);
      {if(f.this-idx != -1)
         w.n1(f.this-group);
      }
      w.n1(f.group-c);
      {do{+j = 0}{(f.group-c) j++}
         w.n1(f.group-v[j]);
      }
      {if(header)
         {if(f.flags & #inline)
            // proceed
            f.flags.wr(w);
         }{else
            // remove #has-body flag
            (f.flags & (-1 ^ :func-flags#has-body)):func-flags.wr(w);
         }
      }{else
         f.flags.wr(w);
      }
      {if((f.flags & #real-name) != #0)
         f.real-name.wr(w, header);
      }
      {if((f.flags & #case) != #0)
         f.case.wr(w, header);
      }
      {if((f.flags & #decl) != #0)
         w.n(f.decl-len);
         w.copy(f.decl-str, f.decl-len);
      }
   }
   .func-main.wr(w);
   {do{+i = 0}(.func-c)
      +f = .func-v[i++];
      {if((f.flags & #has-body) == #0) continue}
      {if(header)
         {if(f.flags & #inline)
            // proceed
         }{else
            // remove #has-body flag
            continue;
         }
      }
      {+pos-4:wtr+}
      pos-4.p1 = w.p1;
      w.pos += 4;
      +pos-4-next = w.pos;
      f.lvars-wr(w, header);
      f.stmt-space.wr(w, header);
      pos-4.n4(w.pos - pos-4-next);
   }
}
{write-cvar(w:wtr, header:bool)
   w.n(.cvar-c);
   {do{+i = 0}{(.cvar-c) i++}
      +cvar = .cvar-v[i];
      cvar.include.wr(w);
      cvar.at.wr(w, header);
      cvar.decl.wr(w, header);
      cvar.flags.wr(w);
      {if((cvar.flags & #set-expr) != #0)
         cvar.expr-set.wr(w, header);
      }{else
         cvar.last-cvar.wr(w);
      }
   }
}
{write-gvar(w:wtr, header:bool)
   w.n(.gvar-c);
   {do{+i = 0}{(.gvar-c) i++}
      +gvar = .gvar-v[i];
      gvar.include.wr(w);
      gvar.at.wr(w, header);
      gvar.decl.wr(w, header);
   }
}
{write-enum(w:wtr, header:bool)
   w.n(.enum-c);
   {do{+i = 0}(.enum-c)
      +e = .enum-v[i++];
      w.n(e.begin-row);
      w.n(e.begin-col);
      w.n(e.end-row);
      w.n(e.end-col);
      e.include.wr(w);
      e.at.wr(w, header);
      e.base-type.wr(w, header);
      e.flags.wr(w);
      {if((e.flags & #real-name) != #0)
         e.real-name.wr(w, header);
      }
   }
}
{write-struct(w:wtr, header:bool)
   w.n(.struct-c);
   {do{+i = 0}(.struct-c)
      +s = .struct-v[i++];
      w.n1(s.fvar-c);
      w.n(s.begin-row);
      w.n(s.begin-col);
      w.n(s.end-row);
      w.n(s.end-col);
      s.include.wr(w);
      s.at.wr(w, header);
      s.flags.wr(w);
      // 'c.out.printf("write-struct %s\n", s.at.ptr().name.id.str());
      // s.name.wr(w, header);
      {do{+j = 0}{(s.fvar-c) j++}
         s.fvar-v[j].wr(w, header);
      }
      {if((s.flags & #real-name) != #0)
         s.real-name.wr(w, header);
      }
   }
}
{token-name(tok:token):char[]
   return tok.cgl-name();
}
{parse-str-init(max-size:i32)}
{get-row-col(out-row:i32&, out-col:i32&, end:ref, begin:ref)
   +row = 1;
   +col = 1;
   {+r:rdr+}
   r.ref = begin;
   {+r-end:rdr+}
   r-end.ref = end;
   {while(r.pos < r-end.pos)
      {if(r.p1[0] == ''\n)
         row++;
         col = 1;
      }{else
         col++;
      }
      r.pos++;
   }
   out-row = row;
   {if(r.p1[0] == ''\n)
      out-col = col - 1;
   }{else
      out-col = col;
   }
}
{parse-string(r:rdr, w:wtr, ending:char, in-data:ref)
   w.p1[0] = ''\';
   w.p1[1] = r.p1[1];
   w.pos += 2;
   r.pos += 2;
   {do()
      +c = r.p1[0];
      {if(c == ''\n)
         get-row-col(+row, +col, r.ref, in-data);
         'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
         'c.exit(#failure);
      }
      w.p1[0] = c;
      w.pos++;
      r.pos++;
      {if(c == ending)
         return;
      }
   }
}
{parse-comment(r:rdr, w:wtr, ending:char, in-data:ref)
   {+r-begin:rdr+}
   r-begin.pos = r.pos;
   r.pos += 2;
   {do()
      +c = r.p1[0];
      {if(c == ''\n)
         get-row-col(+row, +col, r.ref, in-data);
         'c.out.printf("%s:%u:%u: Unterminated comment\n", .input-path, row, col);
         'c.exit(#failure);
      }
      r.pos++;
      {if(c == ending)
         +len = r.pos - r-begin.pos;
         {do(len)
            w.p1[0] = '' ;
            w.pos++;
         }
         return;
      }
   }
}
{gvar input-path:char[] @real-name(input_path)}
{convert-old-to-new(in-data:ref, in-out-size:i32&):ref
   +in-size = in-out-size;
   {+r:rdr+}
   r.ref = in-data;
   {if(&&, r.p1[0] == ''{, r.p1[1] == ''g, r.p1[2] == ''l, r.p1[3] == ''c, r.p1[4] == ''\n, r.p1[in-size - 2] == ''}, r.p1[in-size - 1] == ''\n)
      // remove the {glc and } from head and tail of the file
      r.p1[0] = '' ;
      r.p1[1] = '' ;
      r.p1[2] = '' ;
      r.p1[3] = '' ;
      r.p1[in-size - 2] = '' ;
   }
   {+r-end:rdr+}
   r-end.ref = in-data;
   r-end.pos += in-size;
   {+w-begin:wtr+}
   w-begin.ref = 'c.malloc(in-size << 1);
   {+w:wtr+}
   w.ref = w-begin.ref;
   {while(r.pos < r-end.pos)
      {if(&&, r.p1[0] == ''@, r.p1[1] == ''r, r.p1[2] == ''e, r.p1[3] == ''a, r.p1[4] == ''l, r.p1[5] == ''N, r.p1[6] == ''a, r.p1[7] == ''m, r.p1[8] == ''e)
         // realName -> real-name
         w.p1[0] = ''@;
         w.p1[1] = ''r;
         w.p1[2] = ''e;
         w.p1[3] = ''a;
         w.p1[4] = ''l;
         w.p1[5] = ''-;
         w.p1[6] = ''n;
         w.p1[7] = ''a;
         w.p1[8] = ''m;
         w.p1[9] = ''e;
         w.pos += 10;
         r.pos += 9;
      }{elif(&&, r.p1[0] == ''@, r.p1[1] == ''n, r.p1[2] == ''o, r.p1[3] == ''D, r.p1[4] == ''e, r.p1[5] == ''c, r.p1[6] == ''l)
         // noDecl -> no-decl
         w.p1[0] = ''@;
         w.p1[1] = ''n;
         w.p1[2] = ''o;
         w.p1[3] = ''-;
         w.p1[4] = ''d;
         w.p1[5] = ''e;
         w.p1[6] = ''c;
         w.p1[7] = ''l;
         w.pos += 8;
         r.pos += 7;
      }{elif(&&, r.p1[0] == ''@, r.p1[1] == ''n, r.p1[2] == ''o, r.p1[3] == ''B, r.p1[4] == ''o, r.p1[5] == ''d, r.p1[6] == ''y)
         // noBody -> no-body
         w.p1[0] = ''@;
         w.p1[1] = ''n;
         w.p1[2] = ''o;
         w.p1[3] = ''-;
         w.p1[4] = ''b;
         w.p1[5] = ''o;
         w.p1[6] = ''d;
         w.p1[7] = ''y;
         w.pos += 8;
         r.pos += 7;
      }{elif(&&, r.p1[0] == ''`, r.p1[1] == ''s, r.p1[2] == ''i, r.p1[3] == ''z, r.p1[4] == ''e, r.p1[5] == ''O, r.p1[6] == ''f, r.p1[7] == ''[)
         // :uszOf[:type] -> :type[:usz]
         r.pos += 8;
         {+r-type:rdr+}
         r-type.ref = r.ref;
         {do()
            +c = r.p1[0];
            {if(c == ''])
               {while(r-type.pos < r.pos)
                  w.p1[0] = r-type.p1[0];
                  w.pos++;
                  r-type.pos++;
               }
               w.p1[0] = ''[;
               w.p1[1] = ''`;
               w.p1[2] = ''s;
               w.p1[3] = ''i;
               w.p1[4] = ''z;
               w.p1[5] = ''e;
               w.pos += 6;
               break;
            }
            r.pos++;
         }
      }{elif(&&, r.p1[0] == ''`, r.p1[1] == ''-, r.p1[2] == '' )
         // comment that's only for the older glc
         // but a code for the newer glc
         w.p1[0] = '' ;
         w.p1[1] = '' ;
         w.p1[2] = '' ;
         w.pos += 3;
         r.pos += 3;
      }{elif(&&, r.p1[0] == ''\', r.p1[1] == ''\', r.p1[2] == ''`, r.p1[3] == ''~)
         w.p1[0] = ''\';
         w.p1[1] = ''\';
         w.p1[2] = ''`;
         w.pos += 3;
         r.pos += 4;
      }{elif(&&, r.p1[0] == '' , r.p1[1] == ''+, r.p1[2] == ''+)
         // remove space from increment operator
         w.p1[0] = ''+;
         w.p1[1] = ''+;
         w.pos += 2;
         r.pos += 3;
      }{elif(&&, r.p1[0] == '' , r.p1[1] == ''-, r.p1[2] == ''-)
         // remove space from decrement operator
         w.p1[0] = ''-;
         w.p1[1] = ''-;
         w.pos += 2;
         r.pos += 3;
      }{else
         w.p1[0] = r.p1[0];
         w.pos++;
         r.pos++;
      }
   }
   w.p1[0] = 0;
   {+path:char[256]}
   'c.sprintf(path, "glc-edit/%s", .input-path);
   {if!('c:file.create(++out-fd, path, #write | #truncate, 0o644))
      'c.out.printf("Cannot open file for writing: %s\n", path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();
   in-out-size = w.pos - w-begin.pos;
   return w-begin.ref;
}
{char-escape-value(c:char):i32}
{gvar lock-path:char[]}
{parser-at-exit()}
{main(arg-c:i32, arg-v:char[][]):i32 @main
   {if(false) preprocess-def("", 0); export()}
   .id-map.init();
   .include-map.init();
   .at-map.init();
   quick-alloc-init();
   .func-main = #nil;
   .decl-include = #nil;
   {if(arg-c != 3)
      'c.out.printf("Usage: %s [file.cgl] [output.cgl-b]\n", arg-v[0]);
      return 0;
   }
   .input-path = arg-v[1];
   // 'c.out.printf("reading %s\n", .input-path);
   {if!('c:fd.open(++in-fd, .input-path, #read))
      'c.out.printf("Cannot open file for reading: %s\n", .input-path);
      'c.exit(#failure);
   }
   +lock-path = arg-v[2];
   .lock-path = lock-path;
   {if(true)
      {if!('c:fd.open(++fd, lock-path, #create | #excl))
         // Can't create output file
         'sys.stat(lock-path, +out-stat);
         in-fd.stat(+in-stat);
         {+skip}
         {if("__APPLE__")
            skip = (||, out-stat.mtimespec.sec > in-stat.mtimespec.sec, (&&, out-stat.mtimespec.sec == in-stat.mtimespec.sec, out-stat.mtimespec.nsec > in-stat.mtimespec.nsec));
         }
         {if("__linux__")
            skip = (||, out-stat.mtim.sec > in-stat.mtim.sec, (&&, out-stat.mtim.sec == in-stat.mtim.sec, out-stat.mtim.nsec > in-stat.mtim.nsec));
         }
         {if(skip)
            // Skip parsing
            'c.out.printf("Skipping parsing of %s because the output file is newer than the input file\n", .input-path);
            return 0;
         }
      }{else
         // We created the output file, make sure to unlink it when
         // the parser gets parsing error
         parser-at-exit();
      }
      fd.close();
   }
   +in-size = in-fd.seek(0, #end);
   {+in-data:u8[] = 'c.malloc(in-size + 2)}
   in-fd.seek(0, #set);
   in-fd.read(in-data, in-size);
   in-data[in-size] = 0;
   in-data[in-size + 1] = 0;
   in-fd.close();

   {if(&&, in-data[in-size - 2] == ''\r, in-data[in-size - 1] == ''\n)
      'c.out.printf("Error reading file '%s' because it uses Windows-style line endings\n", .input-path);
      'c.out.printf("Please convert the line endings to Unix-style line endings\n");
      'c.exit(#failure);
   }
   {if(in-data[in-size - 1] != ''\n)
      'c.out.printf("Error reading file '%s' because it doesn't end with a new line\n", .input-path);
      'c.exit(#failure);
   }
   {if(true) // Process comments
      +preprocess = false;
      // in-data = convert-old-to-new(in-data, in-size);
      {+r-end:rdr+}
      r-end.ref = in-data;
      r-end.pos += in-size;
      {+r:rdr+}
      r.ref = in-data;
      {+new-data = 'c.malloc(in-size + 1)}
      {+w:wtr+}
      w.ref = new-data;
      // Ignore consecutive lines that begins with '#'
      {while(r.p1[0] == ''#)
         {do()
            r.pos++;
            {if(r.p1[0] == ''\n)
               {if(&&, r.p1[0] == ''#, r.p1[1] == ''i, r.p1[2] == ''f, (||, r.p1[3] == ''(, (&&, r.p1[3] == ''!, r.p1[4] == ''()))
                  preprocess = true;
               }
               w.p1[0] = ''\n;
               w.pos++;
               r.pos++;
               break;
            }
         }
      }
      {while(r.pos < r-end.pos)
         {if(r.p1[0] == ''/)
            {if(&&, r.p1[1] == ''/, (||, r.p1[2] == '' , r.p1[2] == ''\t))
               {if(r.ref == in-data)
                  // ok
               }{elif(||, r.p1[-1] == '' , r.p1[-1] == ''\t, r.p1[-1] == ''\n)
                  // ok
               }{else
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: There must be a space or tab before the // comment\n", .input-path, row, col);
                  'c.exit(#failure);
               }
               // comment
               r.pos += 3;
               {do()
                  {if(r.p1[0] == ''\n)
                     break;
                  }
                  r.pos++;
                  {if(r.pos >= r-end.pos)
                     get-row-col(+row, +col, r.ref, in-data);
                     'c.out.printf("%s:%u:%u: Comment did not end with a new line\n", .input-path, row, col);
                     'c.exit(#failure);
                  }
               }
               continue;
            }{elif(r.p1[1] == ''\")
               parse-comment(r, w, ''\", in-data);
               continue;
            }{elif(r.p1[1] == ''|)
               parse-comment(r, w, ''|, in-data);
               continue;
            }{elif(r.p1[1] == '';)
               parse-comment(r, w, '';, in-data);
               continue;
            }{elif(r.p1[1] == ''_)
               parse-comment(r, w, ''_, in-data);
               continue;
            }{elif(r.p1[1] == ''+)
               parse-comment(r, w, ''+, in-data);
               continue;
            }{elif(r.p1[1] == ''<)
               parse-comment(r, w, ''>, in-data);
               continue;
            }{elif(r.p1[1] == ''[)
               parse-comment(r, w, ''], in-data);
               continue;
            }{elif(r.p1[1] == ''{)
               parse-comment(r, w, ''}, in-data);
               continue;
            }{elif(r.p1[1] == ''()
               parse-comment(r, w, ''), in-data);
               continue;
            }
         }{elif(r.p1[0] == ''\')
            {if(r.p1[1] == ''\')
               // char
               {if(r.p1[2] == ''\\)
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = ''\\;
                  w.p1[3] = r.p1[3];
                  w.pos += 4;
                  r.pos += 4;
                  continue;
               }{else
                  w.p1[0] = ''\';
                  w.p1[1] = ''\';
                  w.p1[2] = r.p1[2];
                  w.pos += 3;
                  r.pos += 3;
                  continue;
               }
            }{elif(&&, (||, r.p1[2] == '' , r.p1[2] == ''\t), (||, r.p1[1] == ''-, r.p1[1] == ''=))
               // string
               w.p1[0] = ''\';
               w.p1[1] = r.p1[1];
               w.p1[2] = r.p1[2];
               w.pos += 3;
               r.pos += 3;
               {do()
                  +c = r.p1[0];
                  w.p1[0] = c;
                  w.pos++;
                  r.pos++;
                  {if(c == ''\n)
                     break;
                  }
                  {if(r.pos >= r-end.pos)
                     get-row-col(+row, +col, r.ref, in-data);
                     'c.out.printf("%s:%u:%u: String did not end with a new line\n", .input-path, row, col);
                     'c.exit(#failure);
                  }
               }
               continue;
            }{elif(r.p1[1] == ''\")
               parse-string(r, w, ''\", in-data);
               continue;
            }{elif(r.p1[1] == ''|)
               parse-string(r, w, ''|, in-data);
               continue;
            }{elif(r.p1[1] == '';)
               parse-string(r, w, '';, in-data);
               continue;
            }{elif(r.p1[1] == ''_)
               parse-string(r, w, ''_, in-data);
               continue;
            }{elif(r.p1[1] == ''+)
               parse-string(r, w, ''+, in-data);
               continue;
            }{elif(r.p1[1] == ''<)
               parse-string(r, w, ''>, in-data);
               continue;
            }{elif(r.p1[1] == ''[)
               parse-string(r, w, ''], in-data);
               continue;
            }{elif(r.p1[1] == ''{)
               parse-string(r, w, ''}, in-data);
               continue;
            }{elif(r.p1[1] == ''()
               parse-string(r, w, ''), in-data);
               continue;
            }
         }{elif(r.p1[0] == ''\") // C-string
            w.p1[0] = ''\";
            w.pos++;
            r.pos++;
            {do()
               {if(r.p1[0] == ''\n)
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
                  'c.exit(#failure);
               }{elif(r.p1[0] == ''\")
                  w.p1[0] = ''\";
                  w.pos++;
                  r.pos++;
                  break;
               }{elif(r.p1[0] == ''\\)
                  {switch(r.p1[1])
                     {case(''0) }
                     {case(''\\) }
                     {case(''\") }
                     {case(''\') }
                     {case(''a) }
                     {case(''b) }
                     {case(''f) }
                     {case(''n) }
                     {case(''r) }
                     {case(''t) }
                     {case(''v) }
                     {default
                        get-row-col(+row, +col, r.ref, in-data);
                        'c.out.printf("%s:%u:%u: Encountered invalid escape sequence in the string: '\\%c'\n", .input-path, row, col, r.p1[1]);
                        'c.exit(#failure);
                     }
                  }
                  w.p1[0] = ''\\;
                  w.p1[1] = r.p1[1];
                  w.pos += 2;
                  r.pos += 2;
               }{else
                  w.p1[0] = r.p1[0];
                  w.pos++;
                  r.pos++;
               }
               {if(r.pos >= r-end.pos)
                  get-row-col(+row, +col, r.ref, in-data);
                  'c.out.printf("%s:%u:%u: Unterminated string\n", .input-path, row, col);
                  'c.exit(#failure);
               }
            }
            continue;
         }{elif(&&, r.p1[0] == ''#, r.p1[1] == ''i, r.p1[2] == ''f, (||, r.p1[3] == ''(, (&&, r.p1[3] == ''!, r.p1[4] == ''()))
            {if(r.ref == in-data)
               // ok
               preprocess = true;
            }{elif(r.p1[-1] == ''\n)
               // ok
               preprocess = true;
            }
         }
         w.p1[0] = r.p1[0];
         w.pos++;
         r.pos++;
      }
      w.p1[0] = ''\0;
      'c.free(in-data);
      in-data = new-data;
      {+w-begin:wtr+}
      w-begin.ref = new-data;
      in-size = w.pos - w-begin.pos;
      // 'c:fd.open(+fd, "out:parsed.glc", #write | #truncate | #create, 0o644);
      // fd.write(in-data, in-size);
      // fd.close();
      // 'c.out.write(in-data, in-size);
      {if(preprocess)
         preprocess-init();
         preprocess(in-data, in-size);
      }
   }
   {+r-end:rdr+}
   r-end.ref = in-data;
   r-end.pos += in-size;
   parse-str-init(in-size);

   .id-cap = 64;
   malloc-arr(.id-str-v, .id-cap);
   malloc-arr(.id-len-v, .id-cap);
   .include-cap = 64;
   malloc-arr(.include-str-v, .include-cap);
   malloc-arr(.include-len-v, .include-cap);
   .at-cap = 64:at;
   malloc-arr(.at-v, .at-cap);
   .at-c = 2:at;
   .at-v[0].type = #basic;
   .at-v[0].parent = #nil;
   .at-v[0].name.basic = #root;
   .at-v[1].type = #basic;
   .at-v[1].parent = #nil;
   .at-v[1].name.basic = #relative;
   .func-cap = 32:func;
   malloc-arr(.func-v, .func-cap);
   .struct-cap = 32:struct;
   malloc-arr(.struct-v, .struct-cap);
   .decl-fvar-cap = 32;
   malloc-arr(.decl-fvar-v, .decl-fvar-cap);

   +psr = :parser.alloc();
   :lexer.init(+lex, in-data, in-size);
   +next-row = 1;
   +next-col = 1;
   .row = 1;
   .col = 1;
   {+tok:token-data+}
   {do()
      tok.row = next-row;
      tok.col = next-col;
      +t = lex.scan();
      {if(true) // t != #space)
         // when reporting the row and column of tokens, skip the spaces
         +pos = lex.start;
         {while(pos < r-end.p1)
            {if(||, pos[0] == '' , pos[0] == ''\t)
               tok.col++;
            }{elif(pos[0] == ''\n)
               tok.row++;
               tok.col = 1;
            }{else
               break;
            }
            pos++;
         }
      }
      .last-row = .row;
      .last-col = .col;
      .row = tok.row;
      .col = tok.col;
      // 'c.out.printf("%s:%u:%u: token %s\n", .input-path, tok.row, tok.col, t.cgl-name());
      // 'c.out.flush();
      {if(&&, t >= #id-colon, t < #id)
         tok.id = lex.get-id(1, 0);
         psr.parse(t, tok);
      }{else
         {switch(t)
            // {case(#id-lparen)
            //    tok.id = lex.get-id(0, 1);
            //    psr.parse(t, tok);
            // }
            {case(#char1)
               {+r:rdr+}
               r.ref = lex.start;
               tok.id = r.p1[2];
               psr.parse(t, tok);
            }
            {case(#char2)
               {+r:rdr+}
               r.ref = lex.start;
               tok.id = char-escape-value(r.p1[3]);
               psr.parse(t, tok);
            }
            {case(#space-at-real-name-str)
               // find the '@' character and start counting from there
               {+r-start:rdr+}
               r-start.ref = lex.start;
               +start = 11;
               {do()
                  start++;
                  r-start.pos++;
                  {if(r-start.p1[0] == ''@)
                     break;
                  }
               }
               tok.id = lex.get-id(start, 1);
               psr.parse(t, tok);
            }
            {case(#num-dec)
               tok.id = lex.get-u32-dec();
               psr.parse(t, tok);
            }
            {case(#num-oct)
               tok.id = lex.get-u32-oct();
               psr.parse(t, tok);
            }
            {case(#include)
               tok.id = lex.get-include();
               psr.parse(t, tok);
            }
            {case(#id)
               tok.id = lex.get-id(0, 0);
               {if(lex.cursor[0] == ''()
                  t = #id-lparen;
               }
               psr.parse(t, tok);
            }
            {default
               psr.parse(t, tok);
            }
         }
      }
      {if(t == #end) break}
      +pos = lex.start;
      {while(pos < lex.cursor)
         {if((pos[0] & 128) == 0)
            {if(pos[0] == ''\n)
               next-row++;
               next-col = 1;
            }{else
               next-col++;
            }
         }
         pos++;
      }
   }
   psr.parse(#nil, tok);
   psr.free();
   // 'c.out.printf("parsing finished\n");
   {+w-begin:wtr+}
   w-begin.ref = quick-alloc((in-size << 2) + 1024);
   {+w:wtr+}
   w.ref = w-begin.ref;
   w.n(.id-c);
   {do{+i = 0}{(.id-c) i++}
      w.n1(.id-len-v[i]);
      w.copy(.id-str-v[i], .id-len-v[i]);
      w.n1(0);
   }
   +id-bit8-c = (.id-c + 7) >> 3;
   malloc-arr(.id-in-header-v, id-bit8-c);
   malloc-arr(.id-in-header-idx-v, .id-c);
   malloc-arr(.id-in-header-id-v, .id-c);

   w.n(.include-c);
   // 'c.out.printf("There are %u includes\n", .include-c);
   {do{+i = 0}{(.include-c) i++}
      w.n1(.include-len-v[i]);
      w.copy(.include-str-v[i], .include-len-v[i]);
      w.n1(0);
   }

   +at-bit8-c = (.at-c + 7) >> 3;
   malloc-arr(.at-in-header-v, at-bit8-c);
   malloc-arr(.at-in-header-idx-v, .at-c);
   malloc-arr(.at-in-header-at-v, .at-c);

   w.n(.at-c);
   {do{+i = 0}{(.at-c) i++}
      +at = .at-v[i];
      at.type.wr(w);
      {if(at.type == #basic)
         at.name.basic.wr(w);
      }{else
         at.parent.wr(w, false);
         at.name.id.wr(w, false);
      }
   }

   write-cvar(w, false);
   write-gvar(w, false);
   write-enum(w, false);
   write-struct(w, false);
   write-func(w, false);
   
   {+out-path:char[] = 'c.malloc('c.strlen(lock-path) + 4 + 1)}
   'c.sprintf(out-path, "%s.tmp", lock-path);
   +out-path-len = 'c.strlen(out-path);
   {if!('c:fd.open(++out-fd, out-path, #create | #truncate | #write, 0o644))
      'c.out.printf("Cannot open file for writing: %s\n", out-path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();

   w.ref = w-begin.ref;
   w.n(.id-in-header-c);
   {do{+j = 0}{(.id-in-header-c) j++}
      +i = .id-in-header-id-v[j];
      w.n1(.id-len-v[i]);
      w.copy(.id-str-v[i], .id-len-v[i]);
      w.n1(0);
   }
   w.n(.include-c);
   {do{+i = 0}{(.include-c) i++}
      w.n1(.include-len-v[i]);
      w.copy(.include-str-v[i], .include-len-v[i]);
      w.n1(0);
   }
   w.n(.at-in-header-c);
   {do{+j = 0}{(.at-in-header-c) j++}
      +i = .at-in-header-at-v[j];
      +at = .at-v[i];
      at.type.wr(w);
      {if(at.type == #basic)
         at.name.basic.wr(w);
      }{else
         at.parent.wr-header(w);
         at.name.id.wr-header(w);
      }
   }
   write-cvar(w, true);
   write-gvar(w, true);
   write-enum(w, true);
   write-struct(w, true);
   write-func(w, true);

   out-path[out-path-len - 5] = ''h;
   {if!('c:fd.open(out-fd, out-path, #create | #truncate | #write, 0o644))
      'c.out.printf("Cannot open file for writing: %s\n", out-path);
      'c.exit(#failure);
   }
   out-fd.write(w-begin.ref, w.pos - w-begin.pos);
   out-fd.close();
   {+final-path:char[512]}
   out-path[out-path-len - 5] = ''b;
   'c.memcpy(final-path, out-path, out-path-len - 4);
   final-path[out-path-len - 4] = 0;
   'c.rename(out-path, final-path);
   .lock-path = null; // Do not unlink lock-path at exit
   out-path[out-path-len - 5] = ''h;
   'c.memcpy(final-path, out-path, out-path-len - 4);
   final-path[out-path-len - 4] = 0;
   'c.rename(out-path, final-path);
   return 0;
}
 

}
