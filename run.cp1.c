// Generated by Cp1
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#define _NLibC_NExit_Csuccess 0
#define _NLibC_NExit_Cfailure (_NLibC_NExit_Csuccess + 1)
#define _NPosix_NFd_Cnil (-1)
typedef int _NLibC_NExit;
typedef int _NPosix_NFd;
typedef int _NPosix_NOpenFlags;
struct _NLibCp1_NStdOut;
struct _NLibCp1_NStdOut {
uint32_t _Freserve;
};
uint32_t _Gstdout_buf_cap;
uint32_t _Gstdout_buf_len;
char* _Gstdout_buf_data;
int main(int _Larg_c_0, char** _Larg_v_1);
void _Pprint_commands_1(char* _Lbin_0);
void _Pvalidate_cp1_path_2(char* _Lbin_0, char* _Lcp1_path_1);
static inline void _NLibCp1_Pstdout_1(struct _NLibCp1_NStdOut* _Lso_0);
static inline void _NLibCp1_NStdOut_Pstdout_reserve_cstr_4(struct _NLibCp1_NStdOut* _Lso_0, char* _Lstr_1, uint32_t _Llen_2, int _Lunused_3);
static inline void _Tchar_Pstdout_reserve_arr_3(char* _Lstr_0, struct _NLibCp1_NStdOut* _Lso_1, uint32_t* _Llen_2);
static inline void _Tchar_Pstdout_reserve_3(char _Lval_0, struct _NLibCp1_NStdOut* _Lso_1, int _Lunused_2);
static inline void _NLibCp1_NStdOut_Pstdout_reserve_end_1(struct _NLibCp1_NStdOut* _Lso_0);
static inline void _NLibCp1_NStdOut_Pstdout_cstr_4(struct _NLibCp1_NStdOut* _Lso_0, char* _Lstr_1, uint32_t _Llen_2, int _Lunused_3);
static inline void _Tchar_Pstdout_arr_3(char* _Lstr_0, struct _NLibCp1_NStdOut* _Lso_1, uint32_t _Llen_2);
static inline void _Tchar_Pstdout_3(char _Lval_0, struct _NLibCp1_NStdOut* _Lso_1, int _Lunused_2);
static inline void _NLibCp1_NStdOut_Pstdout_end_1(struct _NLibCp1_NStdOut* _Lso_0);
void _Pget_compiler_2(char* _Lbin_0, char* _Lcompiler_1);
void _NLibCp1_Pstdout_reserve_1(uint32_t _Llen_0);
static inline void _NLibCp1_Pstdout_bytes_nr_2(void* _Ldata_0, size_t _Lsize_1);
static inline void _NLibCp1_Pstdout_char_nr_1(char _Lval_0);
static inline void _NLibCp1_Pstdout_flush_0();
#ifdef _WIN32
#define _NPosix_Popen_2(p, f) open(p, f | O_BINARY)
#else
#define _NPosix_Popen_2(p, f) open(p, f)
#endif
#define _NLibC_Prealloc_arr_2(var, c) var = realloc(var, sizeof(var[0]) * (c))
int main(int _Larg_c_0, char** _Larg_v_1) {
char* _Lbin_7;
char _Lc_path_8[15] = {0};
_NPosix_NFd _Lc_fd_9;
char _Lexe_path_14[17] = {0};
_NPosix_NFd _Lexe_fd_15;
char _Lcompiler_20[8] = {0};
char _Lcommand_22[1024] = {0};
int _Lc_ret_23;
int _Lcompile_ret_24;
int _Lexe_ret_26;
#ifdef _WIN32
if(true) {
char* _Larg_2;
size_t _Llen_3;
_Larg_2 = _Larg_v_1[0];
_Llen_3 = strlen(_Larg_2);
if(((_Larg_2[(_Llen_3 - 4)] == '.') && (_Larg_2[(_Llen_3 - 3)] == 'e') && (_Larg_2[(_Llen_3 - 2)] == 'x') && (_Larg_2[(_Llen_3 - 1)] == 'e'))) {
_Larg_2[(_Llen_3 - 4)] = '\0';
}
}
int32_t _Li_4;
_Li_4 = 0;
for(int i = _Larg_c_0; i > 0; ) {
i --;
char* _Larg_5;
_Larg_5 = _Larg_v_1[_Li_4];
int32_t _Lj_6;
_Lj_6 = 0;
while(1) {
if(_Larg_5[_Lj_6] == '\0') {
goto break_1;
} else if(_Larg_5[_Lj_6] == '\\') {
_Larg_5[_Lj_6] = '/';
}
continue_1:;
_Lj_6++;
}
break_1:;
continue_0:;
_Li_4++;
}
break_0:;
#endif
_Lbin_7 = _Larg_v_1[0];
if(_Larg_c_0 != 2) {
_Pprint_commands_1(_Lbin_7);
exit(_NLibC_NExit_Cfailure);
}
_Pvalidate_cp1_path_2(_Lbin_7, _Larg_v_1[1]);
strcpy(_Lc_path_8, "cp1-c-XXXXXX");
_Lc_fd_9 = mkstemp(_Lc_path_8);
if(_Lc_fd_9 == _NPosix_NFd_Cnil) {
int _L_10 = {0};
uint32_t _L_11 = {0};
int _L_12 = {0};
struct _NLibCp1_NStdOut _L_13 = {0};
_Pprint_commands_1(_Lbin_7);
_NLibCp1_Pstdout_1(&_L_13);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_13, "Error, cannot open file for reading: ", 37u, _L_10);
_Tchar_Pstdout_reserve_arr_3(_Lc_path_8, &_L_13, &_L_11);
_Tchar_Pstdout_reserve_3('\n', &_L_13, _L_12);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_13);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_13, "Error, cannot open file for reading: ", 37u, _L_10);
_Tchar_Pstdout_arr_3(_Lc_path_8, &_L_13, _L_11);
_Tchar_Pstdout_3('\n', &_L_13, _L_12);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_13);
exit(_NLibC_NExit_Cfailure);
}
close(_Lc_fd_9);
unlink(_Lc_path_8);
strcpy(_Lexe_path_14, "./cp1-exe-XXXXXX");
_Lexe_fd_15 = mkstemp(_Lexe_path_14);
if(_Lexe_fd_15 == _NPosix_NFd_Cnil) {
int _L_16 = {0};
uint32_t _L_17 = {0};
int _L_18 = {0};
struct _NLibCp1_NStdOut _L_19 = {0};
_Pprint_commands_1(_Lbin_7);
_NLibCp1_Pstdout_1(&_L_19);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_19, "Error, cannot open file for reading: ", 37u, _L_16);
_Tchar_Pstdout_reserve_arr_3(_Lexe_path_14, &_L_19, &_L_17);
_Tchar_Pstdout_reserve_3('\n', &_L_19, _L_18);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_19);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_19, "Error, cannot open file for reading: ", 37u, _L_16);
_Tchar_Pstdout_arr_3(_Lexe_path_14, &_L_19, _L_17);
_Tchar_Pstdout_3('\n', &_L_19, _L_18);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_19);
exit(_NLibC_NExit_Cfailure);
}
close(_Lexe_fd_15);
unlink(_Lexe_path_14);
_Lc_path_8[12] = '.';
_Lc_path_8[13] = 'c';
_Lc_path_8[14] = '\0';
_Pget_compiler_2(_Lbin_7, _Lcompiler_20);
#ifdef _WIN32
if(_Lbin_7[0] != '/') {
int32_t _Li_21;
_Li_21 = 0;
while(_Lbin_7[_Li_21] != '\0') {
if(_Lbin_7[_Li_21] == '/') {
_Lbin_7[_Li_21] = '\\';
}
continue_2:;
_Li_21++;
}
break_2:;
}
#endif
sprintf(_Lcommand_22, "%.*s-compile -c %s %s", ((int)(strlen(_Lbin_7) - 4)), _Lbin_7, _Lc_path_8, _Larg_v_1[1]);
_Lc_ret_23 = system(_Lcommand_22);
if(_Lc_ret_23 != 0) {
unlink(_Lc_path_8);
exit(_NLibC_NExit_Cfailure);
}
sprintf(_Lcommand_22, "%s -o %s %s", _Lcompiler_20, _Lexe_path_14, _Lc_path_8);
_Lcompile_ret_24 = system(_Lcommand_22);
unlink(_Lc_path_8);
if(_Lcompile_ret_24 != 0) {
exit(_NLibC_NExit_Cfailure);
}
#ifdef _WIN32
int32_t _Li_25;
_Li_25 = 0;
while(1) {
if(_Lexe_path_14[_Li_25] == '\0') {
goto break_3;
} else if(_Lexe_path_14[_Li_25] == '/') {
_Lexe_path_14[_Li_25] = '\\';
}
continue_3:;
_Li_25++;
}
break_3:;
#endif
_Lexe_ret_26 = system(_Lexe_path_14);
unlink(_Lexe_path_14);
if(_Lexe_ret_26 != 0) {
exit(_NLibC_NExit_Cfailure);
}
return 0;
}
void _Pprint_commands_1(char* _Lbin_0) {
int _L_1 = {0};
uint32_t _L_2 = {0};
int _L_3 = {0};
struct _NLibCp1_NStdOut _L_4 = {0};
_NLibCp1_Pstdout_1(&_L_4);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_4, "Usage: ", 7u, _L_1);
_Tchar_Pstdout_reserve_arr_3(_Lbin_0, &_L_4, &_L_2);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_4, " [file.cp1]\n", 12u, _L_3);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_4);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_4, "Usage: ", 7u, _L_1);
_Tchar_Pstdout_arr_3(_Lbin_0, &_L_4, _L_2);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_4, " [file.cp1]\n", 12u, _L_3);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_4);
}
void _Pvalidate_cp1_path_2(char* _Lbin_0, char* _Lcp1_path_1) {
size_t _Lcp1_path_len_6;
if(_Lcp1_path_1[0] == '/') {
int _L_2 = {0};
uint32_t _L_3 = {0};
int _L_4 = {0};
struct _NLibCp1_NStdOut _L_5 = {0};
_Pprint_commands_1(_Lbin_0);
_NLibCp1_Pstdout_1(&_L_5);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_5, "Error, [cp1 file] (which is '", 29u, _L_2);
_Tchar_Pstdout_reserve_arr_3(_Lcp1_path_1, &_L_5, &_L_3);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_5, "') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n", 91u, _L_4);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_5);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_5, "Error, [cp1 file] (which is '", 29u, _L_2);
_Tchar_Pstdout_arr_3(_Lcp1_path_1, &_L_5, _L_3);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_5, "') must be a relative filepath (e.g. file.cp1), not an absolute path (/home/user/file.cp1)\n", 91u, _L_4);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_5);
exit(_NLibC_NExit_Cfailure);
}
_Lcp1_path_len_6 = strlen(_Lcp1_path_1);
if(((_Lcp1_path_1[0] == '.') && (_Lcp1_path_1[1] == '/'))) {
_Lcp1_path_1 = ((void*)&_Lcp1_path_1[2]);
_Lcp1_path_len_6 -= 2;
}
int32_t _Lj_7;
_Lj_7 = 0;
for(int i = _Lcp1_path_len_6; i > 0; ) {
i --;
if(_Lcp1_path_1[_Lj_7] == '\\') {
int _L_8 = {0};
uint32_t _L_9 = {0};
int _L_10 = {0};
struct _NLibCp1_NStdOut _L_11 = {0};
_Pprint_commands_1(_Lbin_0);
_NLibCp1_Pstdout_1(&_L_11);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_11, "Error, [cp1 file] (which is '", 29u, _L_8);
_Tchar_Pstdout_reserve_arr_3(_Lcp1_path_1, &_L_11, &_L_9);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_11, "') must not contain backslashes '\\', please use forward slashes '/' instead\n", 76u, _L_10);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_11);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_11, "Error, [cp1 file] (which is '", 29u, _L_8);
_Tchar_Pstdout_arr_3(_Lcp1_path_1, &_L_11, _L_9);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_11, "') must not contain backslashes '\\', please use forward slashes '/' instead\n", 76u, _L_10);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_11);
exit(_NLibC_NExit_Cfailure);
}
continue_0:;
_Lj_7++;
}
break_0:;
int32_t _Lj_12;
_Lj_12 = 0;
for(int i = _Lcp1_path_len_6; i > 0; ) {
i --;
if(_Lcp1_path_1[_Lj_12] == ' ') {
int _L_13 = {0};
uint32_t _L_14 = {0};
int _L_15 = {0};
struct _NLibCp1_NStdOut _L_16 = {0};
_Pprint_commands_1(_Lbin_0);
_NLibCp1_Pstdout_1(&_L_16);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_16, "Error, [cp1 file] (which is '", 29u, _L_13);
_Tchar_Pstdout_reserve_arr_3(_Lcp1_path_1, &_L_16, &_L_14);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_16, "') must not contain a space\n", 28u, _L_15);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_16);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_16, "Error, [cp1 file] (which is '", 29u, _L_13);
_Tchar_Pstdout_arr_3(_Lcp1_path_1, &_L_16, _L_14);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_16, "') must not contain a space\n", 28u, _L_15);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_16);
exit(_NLibC_NExit_Cfailure);
}
continue_1:;
_Lj_12++;
}
break_1:;
int32_t _Lj_17;
_Lj_17 = 0;
for(int i = _Lcp1_path_len_6 - 1; i > 0; ) {
i --;
if(((_Lcp1_path_1[_Lj_17] == '.') && (_Lcp1_path_1[(_Lj_17 + 1)] == '/'))) {
int _L_18 = {0};
uint32_t _L_19 = {0};
int _L_20 = {0};
struct _NLibCp1_NStdOut _L_21 = {0};
_Pprint_commands_1(_Lbin_0);
_NLibCp1_Pstdout_1(&_L_21);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_21, "Error, [cp1 file] (which is '", 29u, _L_18);
_Tchar_Pstdout_reserve_arr_3(_Lcp1_path_1, &_L_21, &_L_19);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_21, "') must not contain './'\n", 25u, _L_20);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_21);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_21, "Error, [cp1 file] (which is '", 29u, _L_18);
_Tchar_Pstdout_arr_3(_Lcp1_path_1, &_L_21, _L_19);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_21, "') must not contain './'\n", 25u, _L_20);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_21);
exit(_NLibC_NExit_Cfailure);
}
continue_2:;
_Lj_17++;
}
break_2:;
if(!((_Lcp1_path_len_6 > 4) && (_Lcp1_path_1[(_Lcp1_path_len_6 - 4)] == '.') && (_Lcp1_path_1[(_Lcp1_path_len_6 - 3)] == 'c') && (_Lcp1_path_1[(_Lcp1_path_len_6 - 2)] == 'p') && (_Lcp1_path_1[(_Lcp1_path_len_6 - 1)] == '1'))) {
int _L_22 = {0};
uint32_t _L_23 = {0};
int _L_24 = {0};
struct _NLibCp1_NStdOut _L_25 = {0};
_Pprint_commands_1(_Lbin_0);
_NLibCp1_Pstdout_1(&_L_25);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_25, "Error, [cp1 file] (which is '", 29u, _L_22);
_Tchar_Pstdout_reserve_arr_3(_Lcp1_path_1, &_L_25, &_L_23);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_25, "') must be a filename that ends with '.cp1', for example: main.cp1\n", 67u, _L_24);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_25);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_25, "Error, [cp1 file] (which is '", 29u, _L_22);
_Tchar_Pstdout_arr_3(_Lcp1_path_1, &_L_25, _L_23);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_25, "') must be a filename that ends with '.cp1', for example: main.cp1\n", 67u, _L_24);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_25);
exit(_NLibC_NExit_Cfailure);
}
}
static inline void _NLibCp1_Pstdout_1(struct _NLibCp1_NStdOut* _Lso_0) {
(*_Lso_0)._Freserve = 0;
}
static inline void _NLibCp1_NStdOut_Pstdout_reserve_cstr_4(struct _NLibCp1_NStdOut* _Lso_0, char* _Lstr_1, uint32_t _Llen_2, int _Lunused_3) {
(*_Lso_0)._Freserve += _Llen_2;
}
static inline void _Tchar_Pstdout_reserve_arr_3(char* _Lstr_0, struct _NLibCp1_NStdOut* _Lso_1, uint32_t* _Llen_2) {
(*_Lso_1)._Freserve += ((*_Llen_2) = strlen(_Lstr_0));
}
static inline void _Tchar_Pstdout_reserve_3(char _Lval_0, struct _NLibCp1_NStdOut* _Lso_1, int _Lunused_2) {
(*_Lso_1)._Freserve++;
}
static inline void _NLibCp1_NStdOut_Pstdout_reserve_end_1(struct _NLibCp1_NStdOut* _Lso_0) {
_NLibCp1_Pstdout_reserve_1((*_Lso_0)._Freserve);
}
static inline void _NLibCp1_NStdOut_Pstdout_cstr_4(struct _NLibCp1_NStdOut* _Lso_0, char* _Lstr_1, uint32_t _Llen_2, int _Lunused_3) {
_NLibCp1_Pstdout_bytes_nr_2(_Lstr_1, _Llen_2);
}
static inline void _Tchar_Pstdout_arr_3(char* _Lstr_0, struct _NLibCp1_NStdOut* _Lso_1, uint32_t _Llen_2) {
_NLibCp1_Pstdout_bytes_nr_2(_Lstr_0, _Llen_2);
}
static inline void _Tchar_Pstdout_3(char _Lval_0, struct _NLibCp1_NStdOut* _Lso_1, int _Lunused_2) {
_NLibCp1_Pstdout_char_nr_1(_Lval_0);
}
static inline void _NLibCp1_NStdOut_Pstdout_end_1(struct _NLibCp1_NStdOut* _Lso_0) {
_NLibCp1_Pstdout_flush_0();
}
void _Pget_compiler_2(char* _Lbin_0, char* _Lcompiler_1) {
char* _Lpath_2;
char* _Lfound_4 = {0};
int _L_7 = {0};
uint32_t _L_8 = {0};
int _L_9 = {0};
struct _NLibCp1_NStdOut _L_10 = {0};
_Lpath_2 = strdup(getenv("PATH"));
#ifdef _WIN32
int32_t _Li_3;
_Li_3 = 0;
while(1) {
if(_Lpath_2[_Li_3] == '\0') {
goto break_0;
} else if(_Lpath_2[_Li_3] == '\\') {
_Lpath_2[_Li_3] = '/';
}
continue_0:;
_Li_3++;
}
break_0:;
#endif
#ifdef _WIN32
_Lfound_4 = strtok(_Lpath_2, ";");
#else
_Lfound_4 = strtok(_Lpath_2, ":");
#endif
while(_Lfound_4 != NULL) {
_NPosix_NFd _Lfd_5 = {0};
char _Lcompile_6[512] = {0};
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/tcc.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/tcc", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
strcpy(_Lcompiler_1, "tcc");
return;
}
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/clang.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/clang", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
strcpy(_Lcompiler_1, "clang");
return;
}
#ifdef _WIN32
sprintf(_Lcompile_6, "%s/gcc.exe", _Lfound_4);
#else
sprintf(_Lcompile_6, "%s/gcc", _Lfound_4);
#endif
_Lfd_5 = _NPosix_Popen_2(_Lcompile_6, O_RDONLY);
if(_Lfd_5 != _NPosix_NFd_Cnil) {
strcpy(_Lcompiler_1, "gcc");
return;
}
#ifdef _WIN32
_Lfound_4 = strtok(NULL, ";");
#else
_Lfound_4 = strtok(NULL, ":");
#endif
continue_1:;
}
break_1:;
_NLibCp1_Pstdout_1(&_L_10);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_10, "Cannot execute '", 16u, _L_7);
_Tchar_Pstdout_reserve_arr_3(_Lbin_0, &_L_10, &_L_8);
_NLibCp1_NStdOut_Pstdout_reserve_cstr_4(&_L_10, " run' because the required compile was not found: tcc clang or gcc\n", 67u, _L_9);
_NLibCp1_NStdOut_Pstdout_reserve_end_1(&_L_10);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_10, "Cannot execute '", 16u, _L_7);
_Tchar_Pstdout_arr_3(_Lbin_0, &_L_10, _L_8);
_NLibCp1_NStdOut_Pstdout_cstr_4(&_L_10, " run' because the required compile was not found: tcc clang or gcc\n", 67u, _L_9);
_NLibCp1_NStdOut_Pstdout_end_1(&_L_10);
exit(_NLibC_NExit_Cfailure);
}
void _NLibCp1_Pstdout_reserve_1(uint32_t _Llen_0) {
uint32_t _Lspace_1;
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
if(_Lspace_1 < _Llen_0) {
if(_Gstdout_buf_cap == 0) {
_Gstdout_buf_cap = 256;
} else {
_Gstdout_buf_cap += _Gstdout_buf_cap;
}
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
while(_Lspace_1 < _Llen_0) {
_Gstdout_buf_cap += _Gstdout_buf_cap;
_Lspace_1 = (_Gstdout_buf_cap - _Gstdout_buf_len);
continue_0:;
}
break_0:;
_NLibC_Prealloc_arr_2(_Gstdout_buf_data, _Gstdout_buf_cap);
}
}
static inline void _NLibCp1_Pstdout_bytes_nr_2(void* _Ldata_0, size_t _Lsize_1) {
memcpy(&_Gstdout_buf_data[_Gstdout_buf_len], _Ldata_0, _Lsize_1);
_Gstdout_buf_len += _Lsize_1;
}
static inline void _NLibCp1_Pstdout_char_nr_1(char _Lval_0) {
_Gstdout_buf_data[_Gstdout_buf_len++] = _Lval_0;
}
static inline void _NLibCp1_Pstdout_flush_0() {
write(((_NPosix_NFd)(1)), _Gstdout_buf_data, _Gstdout_buf_len);
_Gstdout_buf_len = 0;
}
